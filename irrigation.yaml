substitutions:
  dev1_what: Lawn
  devicename1: ${dev1_what}_irrigation_controller
  upper_devicename1: "${dev1_what} Irrigation Controller"
  dev1_zone1: Lawn Zone1
  dev1_zone2: Lawn Zone2
  dev1_zone3: Lawn Zone3
  dev1_zone4: Lawn Zone4
  dev1_zone5: Lawn Zone5
  dev1_zone6: Lawn Zone6
  dev1_zone7: Lawn Zone7
  dev1_zone8: Lawn Zone8
  master_valve_pin: GPIO27  # Master valve control (like Hunter Pro-C) - optional
  software_revision: V2.2-PW
  date_revision: 2025 02 05
  sensor_update_frequency: 1s
  log_level: info # Enable levels logging https://esphome.io/components/logger.html
  # none, error, warn, info, debug (default), verbose, very_verbose

###################################
#  CHANGE BELOW LINES IF NEEDED ###
###################################
  esphome_name: "irrigation"
  esphome_board: esp32dev
  esp32_board: "esp32dev"
  esphome_comment: Irrigation Control System
  esphome_project_name: AG.Irrigation Control System
  esphome_project_version: ICS, $software_revision
  uom: Min # this overrides the uom in sprinkler -> run_duration

#Define Project Details and ESP Board Type
esphome:
  name: $esphome_name
  comment: $esphome_comment
  friendly_name: Irrigation Controller
  project:
    name: $esphome_project_name
    version: $esphome_project_version
  on_boot:
    priority: -100
    then:
      # Set default state for Valve Status
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      # reset multiplier at reboot
      - lambda: |-
          // === 3-ITEM QUEUE SYSTEM INITIALIZATION ===
            id(irrigation_busy) = false;
            id(in_program_run) = false;
            
            // Initialize queue arrays
            id(queue_count) = 0;
            for (int i = 0; i < 3; i++) {
              id(queue_types)[i] = 0;
              id(queue_programs)[i] = 0;
              id(queue_zones)[i] = 0;
              id(queue_durations)[i] = 0;
              id(queue_add_delays)[i] = false;
            }
            ESP_LOGI("irrigation", "ğŸ”„ BOOT: 3-slot queue initialized (Hunter Pro-C style)");
            
            // Initialize Predictive Watering variables
            id(pw_last_calculation_time) = 0;
            id(pw_current_multiplier) = 1.0;
            ESP_LOGI("irrigation", "ğŸ’§ Predictive Wateringâ„¢ system initialized");
            
            // Initialize Smart ET variables
            id(et_last_calculation_time) = 0;
            id(et_pending_irrigation) = false;
            ESP_LOGI("irrigation", "ğŸŒ± Smart ET Watering system initialized");

      - sprinkler.set_multiplier:
          id: $devicename1
          multiplier: 1
# Set smart multiplier on boot based on temperature and season
      - lambda: |-
          auto time = id(homeassistant_time).now();
          if (!time.is_valid()) {
            ESP_LOGW("irrigation", "Time not synchronized yet - will retry in 30 seconds");
            return;
          }
          
          int month = time.month;
          float temp = id(outside_temperature).state;
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
            temp = 20.0;
          }
          
          float multiplier = 1.0;
          
          // Base seasonal multiplier
          if (month >= 12 || month <= 2) {
            multiplier = 1.3;  // Summer base
            // Hot days need more water
            if (temp > 25) multiplier = 1.6;
            if (temp > 30) multiplier = 1.8;
          } else if (month >= 6 && month <= 8) {
            multiplier = 0.5;  // Winter base
            // Cold days need less
            if (temp < 10) multiplier = 0.3;
          } else {
            // Spring/Autumn
            multiplier = 0.8;
            if (temp > 20) multiplier = 1.0;
          }
          
          id($devicename1).set_multiplier(multiplier);
          ESP_LOGI("irrigation", "Boot multiplier set to %.1f (temp: %.1fÂ°C)", multiplier, temp);
      
      # Retry multiplier setup if time wasn't synced on first attempt
      - delay: 30s
      - lambda: |-
          // Only retry if multiplier is still at default 1.0
          if (id($devicename1).multiplier() == 1.0) {
            auto time = id(homeassistant_time).now();
            if (!time.is_valid()) {
              ESP_LOGW("irrigation", "Time still not synchronized after 30s - will retry at midnight");
              return;
            }
            
            int month = time.month;
            float temp = id(outside_temperature).state;
            if (isnan(temp)) {
              ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
              temp = 20.0;
            }
            
            float multiplier = 1.0;
            
            // Base seasonal multiplier
            if (month >= 12 || month <= 2) {
              multiplier = 1.3;  // Summer base
              // Hot days need more water
              if (temp > 25) multiplier = 1.6;
              if (temp > 30) multiplier = 1.8;
            } else if (month >= 6 && month <= 8) {
              multiplier = 0.5;  // Winter base
              // Cold days need less
              if (temp < 10) multiplier = 0.3;
            } else {
              // Spring/Autumn
              multiplier = 0.8;
              if (temp > 20) multiplier = 1.0;
            }
            
            id($devicename1).set_multiplier(multiplier);
            ESP_LOGI("irrigation", "RETRY: Boot multiplier set to %.1f (temp: %.1fÂ°C)", multiplier, temp);
          } else {
            ESP_LOGI("irrigation", "Multiplier already set to %.1f - no retry needed", id($devicename1).multiplier());
          }
      
      # Initialize time restriction check
      - delay: 2s
      - script.execute: check_time_restriction
      
      # Initialize Predictive Watering calculation
      - delay: 5s
      - script.execute: calculate_predictive_watering
      
      # Initialize Smart ET calculation
      - delay: 2s
      - script.execute: calculate_smart_et
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STARTUP VALIDATION (Production Feature)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - delay: 10s
      - lambda: |-
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ” SYSTEM STARTUP VALIDATION");
          ESP_LOGI("irrigation", "ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          int errors = 0;
          int warnings = 0;
          
          // Check 1: Time Synchronization
          auto time = id(homeassistant_time).now();
          if (!time.is_valid()) {
            ESP_LOGE("irrigation", "âŒ CRITICAL: Time not synchronized!");
            errors++;
          } else {
            ESP_LOGI("irrigation", "âœ… Time synchronized: %d/%d/%d %d:%02d", 
                     time.day_of_month, time.month, time.year, time.hour, time.minute);
          }
          
          // Check 2: Weather Sensors
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "âš ï¸ WARNING: Temperature sensor unavailable");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "âœ… Temperature: %.1fÂ°C", temp);
            
            // Check freeze condition
            if (temp < id(freeze_threshold)) {
              ESP_LOGW("irrigation", "âš ï¸ FREEZE RISK: Temperature below %.1fÂ°C - protection will activate", id(freeze_threshold));
              warnings++;
            }
          }
          
          if (isnan(humidity)) {
            ESP_LOGW("irrigation", "âš ï¸ WARNING: Humidity sensor unavailable");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "âœ… Humidity: %.1f%%", humidity);
          }
          
          if (isnan(wind)) {
            ESP_LOGW("irrigation", "âš ï¸ WARNING: Wind sensor unavailable");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "âœ… Wind: %.1f km/h", wind);
          }
          
          // Check 3: Predictive Watering Status
          if (id(predictive_watering_enabled)) {
            ESP_LOGI("irrigation", "âœ… Predictive Watering: ENABLED (multiplier: %.2f)", id(pw_current_multiplier));
          } else {
            ESP_LOGI("irrigation", "â„¹ï¸ Predictive Watering: Disabled");
          }
          
          // Check 4: Smart ET Status
          if (id(smart_et_enabled)) {
            ESP_LOGI("irrigation", "âœ… Smart ET: ENABLED (deficit: %.1fmm)", id(et_soil_moisture_deficit));
          } else {
            ESP_LOGI("irrigation", "â„¹ï¸ Smart ET: Disabled");
          }
          
          // Check 5: Master Valve Configuration
          if (id(master_valve_enabled)) {
            ESP_LOGI("irrigation", "âœ… Master Valve: ENABLED");
          } else {
            ESP_LOGI("irrigation", "â„¹ï¸ Master Valve: Disabled (zones operate independently)");
          }
          
          // Check 6: Rain Delay Status
          if (id(rain_delay_end_time) > time.timestamp) {
            long remaining = id(rain_delay_end_time) - time.timestamp;
            ESP_LOGI("irrigation", "âš ï¸ Rain Delay ACTIVE: %.1f days remaining", remaining / 86400.0);
            warnings++;
          }
          
          // Check 7: Water Budget Status
          if (id(current_month_usage) > 0) {
            float percent = (id(current_month_usage) / id(monthly_water_budget)) * 100.0;
            ESP_LOGI("irrigation", "ğŸ“Š Water Budget: %.1fL / %.1fL (%.1f%%)", 
                     id(current_month_usage), id(monthly_water_budget), percent);
            if (percent > 80) {
              ESP_LOGW("irrigation", "âš ï¸ WARNING: Water budget >80%% used");
              warnings++;
            }
          }
          
          // Check 8: Network Mode
          if (id(network_offline_mode)) {
            ESP_LOGW("irrigation", "âš ï¸ Network: Offline mode active (using fallback multiplier)");
            warnings++;
          }
          
          // Summary
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ VALIDATION SUMMARY:");
          ESP_LOGI("irrigation", "   Errors: %d | Warnings: %d", errors, warnings);
          
          if (errors == 0 && warnings == 0) {
            ESP_LOGI("irrigation", "   âœ… ALL SYSTEMS OPERATIONAL");
          } else if (errors == 0) {
            ESP_LOGI("irrigation", "   âš ï¸ OPERATIONAL WITH WARNINGS");
          } else {
            ESP_LOGE("irrigation", "   âŒ CRITICAL ERRORS DETECTED");
          }
          
          ESP_LOGI("irrigation", "ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "");
      
esp32:
  board: $esphome_board
  framework:
    type: esp-idf

api:
  encryption:
    key: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

ota:
  - platform: esphome
    password: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Irrigation-Controller"
    password: "uaRTa8vRL7uc"

captive_portal:

logger:
  level: ${log_level}
  logs:
    text_sensor: WARN

# Enable Web server
web_server:
  port: 80

globals:
  - id: rain_delay_days
    type: int
    restore_value: True
    initial_value: '0'
  - id: rain_delay_end_time
    type: long
    restore_value: True
    initial_value: '0'
  - id: master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'false'  # Optional feature, off by default
  - id: test_mode_active
    type: bool
    restore_value: False
    initial_value: 'false'  # True during diagnostics/tests to prevent watchdog interference
  - id: cycle_soak_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: cycle_duration_minutes
    type: int
    restore_value: True
    initial_value: '10'
  - id: soak_duration_minutes
    type: int
    restore_value: True
    initial_value: '10'
  - id: current_cycle
    type: int
    restore_value: False
    initial_value: '0'
  - id: total_cycles
    type: int
    restore_value: False
    initial_value: '0'
  - id: active_zone_number
    type: int
    restore_value: False
    initial_value: '-1'
  - id: zone_total_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: station_delay_seconds
    type: int
    restore_value: True
    initial_value: '5'  # Default 5 seconds between zones

  # ============================================================
  # PREDICTIVE WATERINGâ„¢ GLOBALS
  # ============================================================
  - id: predictive_watering_enabled
    type: bool
    restore_value: True
    initial_value: 'true'  # Predictive Wateringâ„¢ ON by default
    
  - id: pw_last_calculation_time
    type: long
    restore_value: False
    initial_value: '0'  # Timestamp of last calculation
    
  - id: pw_current_multiplier
    type: float
    restore_value: True
    initial_value: '1.0'  # Current calculated multiplier
    
  - id: pw_temperature_factor
    type: float
    restore_value: False
    initial_value: '1.0'
    
  - id: pw_rain_factor
    type: float
    restore_value: False
    initial_value: '1.0'
    
  - id: pw_humidity_factor
    type: float
    restore_value: False
    initial_value: '1.0'
    
  - id: pw_wind_factor
    type: float
    restore_value: False
    initial_value: '1.0'

  # ============================================================
  # SMART ET WATERING GLOBALS
  # ============================================================
  - id: smart_et_enabled
    type: bool
    restore_value: True
    initial_value: 'false'  # Smart ET OFF by default
    
  - id: et_soil_moisture_deficit
    type: float
    restore_value: True
    initial_value: '0.0'  # mm of water deficit
    
  - id: et_water_threshold
    type: float
    restore_value: True
    initial_value: '25.0'  # Water when deficit reaches 25mm
    
  - id: et_last_calculation_time
    type: long
    restore_value: False
    initial_value: '0'
    
  - id: et_daily_et
    type: float
    restore_value: False
    initial_value: '0.0'  # Today's ET in mm
    
  - id: et_last_water_time
    type: long
    restore_value: True
    initial_value: '0'
    
  - id: et_pending_irrigation
    type: bool
    restore_value: False
    initial_value: 'false'
  
  - id: et_duration_multiplier
    type: float
    restore_value: False
    initial_value: '1.0'  # Smart ET's additional multiplier based on deficit
  
  # Smart ET Schedule Time
  - id: et_schedule_hour
    type: int
    restore_value: True
    initial_value: '6'  # Default 6 AM
    
  - id: et_schedule_minute
    type: int
    restore_value: True
    initial_value: '0'  # Default :00
    
  - id: et_schedule_am_pm
    type: int
    restore_value: True
    initial_value: '0'  # 0=AM, 1=PM

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER USAGE TRACKING (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Zone flow rates (liters per minute) - configurable per zone
  - id: zone1_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'  # 15 L/min default
  - id: zone2_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'
  - id: zone3_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'
  - id: zone4_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'
  - id: zone5_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'
  - id: zone6_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'
  - id: zone7_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'
  - id: zone8_flow_rate
    type: float
    restore_value: True
    initial_value: '15.0'
  
  # Water used per zone (liters) - accumulated total
  - id: zone1_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone2_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone3_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone4_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone5_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone6_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone7_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone8_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  
  # Total system water usage (liters)
  - id: total_water_used
    type: float
    restore_value: True
    initial_value: '0.0'
  
  # Last water usage reset timestamp
  - id: water_usage_reset_time
    type: long
    restore_value: True
    initial_value: '0'

  # Zone-specific schedule times
  - id: zone1_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone1_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone1_am_pm
    type: int
    restore_value: True
    initial_value: '0'  # 0=AM, 1=PM
  
  - id: zone2_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone2_start_minute
    type: int
    restore_value: True
    initial_value: '15'
  - id: zone2_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone3_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone3_start_minute
    type: int
    restore_value: True
    initial_value: '30'
  - id: zone3_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone4_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone4_start_minute
    type: int
    restore_value: True
    initial_value: '45'
  - id: zone4_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone5_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone5_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone5_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone6_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone6_start_minute
    type: int
    restore_value: True
    initial_value: '15'
  - id: zone6_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone7_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone7_start_minute
    type: int
    restore_value: True
    initial_value: '30'
  - id: zone7_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone8_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone8_start_minute
    type: int
    restore_value: True
    initial_value: '45'
  - id: zone8_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  # Zone schedule enable flags
  - id: zone1_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone2_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone3_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone4_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone5_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone6_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone7_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone8_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
    
  # Master Valve per-zone enable (Hunter Pro-C style)
  - id: zone1_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'  # Default ON for all zones
  - id: zone2_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone3_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone4_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone5_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone6_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone7_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone8_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SOIL TYPE SETTINGS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: soil_type
    type: int
    restore_value: True
    initial_value: '0'  # 0=Sand, 1=Loam, 2=Clay (Default: Sand for Whanganui)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SEASONAL ADJUSTMENT MULTIPLIERS (Southern Hemisphere - Whanganui)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: seasonal_jan
    type: float
    restore_value: True
    initial_value: '1.4'  # Peak summer
  - id: seasonal_feb
    type: float
    restore_value: True
    initial_value: '1.4'  # Peak summer
  - id: seasonal_mar
    type: float
    restore_value: True
    initial_value: '1.2'  # Early autumn
  - id: seasonal_apr
    type: float
    restore_value: True
    initial_value: '1.0'  # Autumn
  - id: seasonal_may
    type: float
    restore_value: True
    initial_value: '0.9'  # Late autumn
  - id: seasonal_jun
    type: float
    restore_value: True
    initial_value: '0.7'  # Winter
  - id: seasonal_jul
    type: float
    restore_value: True
    initial_value: '0.6'  # Winter
  - id: seasonal_aug
    type: float
    restore_value: True
    initial_value: '0.7'  # Late winter
  - id: seasonal_sep
    type: float
    restore_value: True
    initial_value: '0.9'  # Early spring
  - id: seasonal_oct
    type: float
    restore_value: True
    initial_value: '1.1'  # Spring
  - id: seasonal_nov
    type: float
    restore_value: True
    initial_value: '1.3'  # Late spring
  - id: seasonal_dec
    type: float
    restore_value: True
    initial_value: '1.4'  # Early summer
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FREEZE PROTECTION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: freeze_threshold
    type: float
    restore_value: True
    initial_value: '2.0'  # Celsius - disable watering below this
  - id: freeze_protection_active
    type: bool
    restore_value: False
    initial_value: 'false'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER BUDGET LIMITS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: monthly_water_budget
    type: float
    restore_value: True
    initial_value: '10000.0'  # Liters per month
  - id: current_month_usage
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: last_reset_month
    type: int
    restore_value: True
    initial_value: '0'
  - id: budget_warning_sent
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: budget_exceeded
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: budget_override_active
    type: bool
    restore_value: False
    initial_value: 'false'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ZONE RUNTIME LIMITS (Daily)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: max_zone_runtime_daily
    type: int
    restore_value: True
    initial_value: '60'  # Minutes per day per zone
  - id: zone1_runtime_today
    type: int
    restore_value: True
    initial_value: '0'  # Seconds
  - id: zone2_runtime_today
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone3_runtime_today
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone4_runtime_today
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone5_runtime_today
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone6_runtime_today
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone7_runtime_today
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone8_runtime_today
    type: int
    restore_value: True
    initial_value: '0'
  - id: last_runtime_reset_day
    type: int
    restore_value: True
    initial_value: '0'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYSTEM IDLE DETECTION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: last_watering_timestamp
    type: long
    restore_value: True
    initial_value: '0'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NETWORK LOSS HANDLING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: fallback_multiplier
    type: float
    restore_value: True
    initial_value: '1.0'  # Last known good multiplier
  - id: network_offline_mode
    type: bool
    restore_value: False
    initial_value: 'false'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATERING WINDOW ENFORCEMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: window1_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: window1_start_hour
    type: int
    restore_value: True
    initial_value: '6'  # 6 AM
  - id: window1_end_hour
    type: int
    restore_value: True
    initial_value: '9'  # 9 AM
  - id: window2_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: window2_start_hour
    type: int
    restore_value: True
    initial_value: '18'  # 6 PM
  - id: window2_end_hour
    type: int
    restore_value: True
    initial_value: '21'  # 9 PM
    
  - id: manual_rain_delay_override
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: manual_weather_override
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: last_weather_log_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: last_time_restriction_log
    type: long
    restore_value: False
    initial_value: '0'
  - id: vacation_mode_active
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: normal_multiplier
    type: float
    restore_value: True
    initial_value: '1.0'
# Last watered timestamps for each zone
  - id: zone1_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone2_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone3_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone4_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone5_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone6_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone7_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone8_last_watered
    type: long
    restore_value: True
    initial_value: '0'
# Zone start times (for duration tracking)
  - id: zone1_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone2_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone3_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone4_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone5_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone6_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone7_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone8_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: cycle_soak_total_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: cycle_soak_elapsed_time
    type: int
    restore_value: False
    initial_value: '0'
  - id: is_paused
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: paused_zone
    type: int
    restore_value: False
    initial_value: '-1'
  - id: paused_cycle
    type: int
    restore_value: False
    initial_value: '0'
  - id: time_remaining_when_paused
    type: int
    restore_value: False
    initial_value: '0'

  # --- Preserve cycle/soak state across Pause/Resume ---
  - id: paused_total_cycles
    type: int
    restore_value: False
    initial_value: '0'
  - id: paused_cycle_soak_total_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: paused_cycle_soak_elapsed_time
    type: int
    restore_value: False
    initial_value: '0'

  # --- Track soak phase for true pause/resume ---
  - id: cycle_soak_is_soaking
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: cycle_soak_soak_end_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: paused_was_soaking
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: paused_soak_remaining_seconds
    type: int
    restore_value: False
    initial_value: '0'
  - id: soak_countdown_seconds
    type: int
    restore_value: False
    initial_value: '0'

  # --- Configurable Time Restriction Window (12-hour + AM-PM) ---
  - id: restrict_start_hour
    type: int
    restore_value: True
    initial_value: '10'   # 10 AM
  - id: restrict_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: restrict_start_am_pm
    type: int
    restore_value: True
    initial_value: '1'    # 0=AM, 1=PM

  - id: restrict_end_hour
    type: int
    restore_value: True
    initial_value: '3'    # 3.30 PM
  - id: restrict_end_minute
    type: int
    restore_value: True
    initial_value: '30'
  - id: restrict_end_am_pm
    type: int
    restore_value: True
    initial_value: '1'    # PM

  # --- Run lock / queue (prevents overlapping starts) ---
  - id: irrigation_busy
    type: bool
    restore_value: False
    initial_value: 'false'

  # True while run_program is executing
  - id: watchdog_last_activity
    type: long
    restore_value: False
    initial_value: '0'
  - id: in_program_run
    type: bool
    restore_value: False
    initial_value: 'false'

  # one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
  # Queue system - supports up to 3 items (Hunter-style)
  - id: queue_types
    type: int[3]
    restore_value: False
  - id: queue_programs
    type: int[3]
    restore_value: False
  - id: queue_zones
    type: int[3]
    restore_value: False
  - id: queue_durations
    type: int[3]
    restore_value: False
  - id: queue_add_delays
    type: bool[3]
    restore_value: False
  - id: queue_count
    type: int
    restore_value: False
    initial_value: '0'
  
  # Legacy queue variables (kept for backward compatibility during transition)
  - id: queued_type
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_program
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_zone
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_zone_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_zone_add_delay
    type: bool
    restore_value: False
    initial_value: 'false'

# Program management
  - id: active_program
    type: int
    restore_value: False
    initial_value: '0'  # 0=A, 1=B, 2=C
    
  # Program A settings
  - id: program_a_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: program_a_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: program_a_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_a_am_pm
    type: int
    restore_value: True
    initial_value: '0'  # 0=AM, 1=PM
  - id: program_a_schedule_type
    type: int
    restore_value: True
    initial_value: '0'  # 0=specific days, 1=odd days, 2=even days, 3=interval
  - id: program_a_interval_days
    type: int
    restore_value: True
    initial_value: '3'
  - id: program_a_last_run
    type: long
    restore_value: True
    initial_value: '0'
    
  # Program B settings
  - id: program_b_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: program_b_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: program_b_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_b_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_b_schedule_type
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_b_interval_days
    type: int
    restore_value: True
    initial_value: '3'
  - id: program_b_last_run
    type: long
    restore_value: True
    initial_value: '0'
    
  # Program C settings
  - id: program_c_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: program_c_start_hour
    type: int
    restore_value: True
    initial_value: '8'
  - id: program_c_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_c_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_c_schedule_type
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_c_interval_days
    type: int
    restore_value: True
    initial_value: '3'
  - id: program_c_last_run
    type: long
    restore_value: True
    initial_value: '0'
    
  # Zone assignment to programs (0=none, 1=A, 2=B, 3=C)
  - id: zone1_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone2_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone3_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone4_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone5_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone6_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone7_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone8_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: is_time_restricted
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: last_time_restriction_state
    type: int
    restore_value: False
    initial_value: '0'
  - id: auto_advance_enabled
    type: bool
    restore_value: true
    initial_value: 'true'

  - id: stop_cooldown
    type: bool
    restore_value: false
    initial_value: "false"
  # Adjust this if your shutdown window is longer/shorter
  - id: stop_restart_delay_seconds
    type: int
    restore_value: true
    initial_value: "8"
  - id: pending_normal_start
    type: bool
    restore_value: false
    initial_value: "false"
  - id: normal_start_attempts
    type: int
    restore_value: false
    initial_value: "0"
  - id: normal_last_attempt_ms
    type: uint32_t
    restore_value: false
    initial_value: "0"
   
# Sync time with Home Assistant
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      # Check weather every 4 hours and set/clear rain delay
      - seconds: 0
        minutes: 0
        hours: /4  # Runs at 0:00, 4:00, 8:00, 12:00, 16:00, 20:00
        then:
          - lambda: |-
              // Only auto-manage rain delay if manual override is OFF
              if (!id(manual_rain_delay_override)) {
                std::string weather = id(weather_forecast_home).state;
                if (weather.empty() || weather == "unknown" || weather == "unavailable") {
                  ESP_LOGW("irrigation", "Weather state unavailable - skipping scheduled rain delay update");
                  return;
                }
                
                // Set rain delay if it's raining
                if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                  id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (86400 * 2); // 2 day delay
                  id(rain_delay_days) = 2;
                  id(rain_delay_days_input).publish_state(2);
                  ESP_LOGI("irrigation", "Auto rain delay activated - weather is %s", weather.c_str());
                }
                // Clear rain delay if weather is good
                else if (weather == "sunny" || weather == "clear" || weather == "partlycloudy" || weather == "cloudy") {
                  if (id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
                    id(rain_delay_end_time) = 0;
                    id(rain_delay_days) = 0;
                    id(rain_delay_days_input).publish_state(0);
                    ESP_LOGI("irrigation", "Auto rain delay cleared - weather is %s", weather.c_str());
                  }
                }
              }
      
      # Run Predictive Watering calculation every hour
      - seconds: 0
        minutes: 0
        # Runs every hour on the hour
        then:
          - script.execute: calculate_predictive_watering
      
      # Run Smart ET calculation every hour
      - seconds: 0
        minutes: 0
        # Runs every hour on the hour
        then:
          - script.execute: calculate_smart_et
      
      # Check for pending Smart ET irrigation at scheduled time
      - seconds: 0
        minutes: 0,5,10,15,20,25,30,35,40,45,50,55  # Check every 5 minutes
        then:
          - lambda: |-
              if (id(smart_et_enabled) && id(et_pending_irrigation)) {
                if (!id(is_time_restricted) && id(irrigation_system_enable).state) {
                  
                  // Check if current time matches Smart ET schedule
                  auto time = id(homeassistant_time).now();
                  int current_hour = time.hour;
                  int current_minute = time.minute;
                  
                  // Convert schedule to 24-hour format
                  int schedule_hour = id(et_schedule_hour);
                  if (id(et_schedule_am_pm) == 1 && schedule_hour != 12) {
                    schedule_hour += 12;  // PM conversion
                  } else if (id(et_schedule_am_pm) == 0 && schedule_hour == 12) {
                    schedule_hour = 0;  // Midnight conversion
                  }
                  
                  // Check if we're within 5 minutes of scheduled time
                  bool time_match = (current_hour == schedule_hour && abs(current_minute - id(et_schedule_minute)) < 5);
                  
                  if (time_match) {
                    ESP_LOGI("irrigation", "ğŸŒ± Smart ET: Executing pending irrigation at scheduled time");
                    
                    // Recalculate and apply ET multiplier
                    float deficit = id(et_soil_moisture_deficit);
                    float threshold = id(et_water_threshold);
                    float deficit_ratio = deficit / threshold;
                    float et_multiplier = deficit_ratio;
                    if (et_multiplier > 2.0) et_multiplier = 2.0;
                    if (et_multiplier < 1.0) et_multiplier = 1.0;
                    
                    id(et_duration_multiplier) = et_multiplier;
                    
                    // Apply combined multiplier
                    float pw_mult = id(pw_current_multiplier);
                    float combined = pw_mult * et_multiplier;
                    if (combined > 2.0) combined = 2.0;
                    
                    ESP_LOGI("irrigation", "   ET Multiplier: %.2fx, PW: %.2fx, Combined: %.2fx", 
                             et_multiplier, pw_mult, combined);
                    
                    id($devicename1).set_multiplier(combined);
                    id(start_all_zones_cycle_soak).press();
                    id(et_soil_moisture_deficit) = 0;
                    id(et_last_water_time) = id(homeassistant_time).now().timestamp;
                    id(et_pending_irrigation) = false;
                  }
                }
              }
      
      # Restore Predictive Watering multiplier if Smart ET finished watering
      - seconds: 0
        minutes: /5  # Every 5 minutes
        then:
          - lambda: |-
              // Only restore if Smart ET is enabled and we're not currently watering
              if (!id(smart_et_enabled)) {
                return;
              }
              
              // Check if any valve is active
              bool is_watering = id($devicename1).active_valve().has_value();
              
              // If not watering and ET multiplier is not 1.0, restore PW multiplier
              if (!is_watering && id(et_duration_multiplier) != 1.0) {
                id(restore_pw_multiplier).execute();
              }
      
      # Check valve status and reset to Idle if no valves active
      - seconds: 0
        minutes: /1  # Every minute
        then:
          - lambda: |-
              // Check if any valve is currently active
              bool is_active = id($devicename1).active_valve().has_value();
              
              // If no valve is active and status isn't "Idle", reset it
              if (!is_active && id(dev1_valve_status).state != "Idle") {
                ESP_LOGI("irrigation", "No active valve detected - resetting status to Idle");
                id(dev1_valve_status).publish_state("Idle");
              }
      
# Check every minute if it's time to start programs
      - seconds: 0
        # NO minutes filter - check EVERY minute!
        then:
          # Check Program A
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_a_enabled)) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping Program A check");
                    return false;
                  }
                  
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        // Only log once per hour to reduce spam
                        long now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= 3600) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction check
                  if (id(is_time_restricted)) {
                    // Only log once per hour to reduce spam
                    long now = id(homeassistant_time).now().timestamp;
                    if (now - id(last_time_restriction_log) >= 3600) {
                      ESP_LOGW("irrigation", "â° SCHEDULES BLOCKED - Time restriction active (outside allowed hours)");
                      id(last_time_restriction_log) = now;
                    }
                    return false;
                  }
                  
                  // Convert 12-hour to 24-hour
                  int start_hour = id(program_a_start_hour);
                  if (id(program_a_am_pm) == 1) {  // PM
                    start_hour = (start_hour == 12) ? 12 : start_hour + 12;
                  } else {  // AM
                    start_hour = (start_hour == 12) ? 0 : start_hour;
                  }
                  
                  // Check if it's the right time
                  if (time.hour != start_hour || time.minute != id(program_a_start_minute)) return false;
                  
                  // Check schedule type
                  int schedule_type = id(program_a_schedule_type);
                  int day_of_month = time.day_of_month;
                  int day_of_week = time.day_of_week;  // 1=Sun, 2=Mon, 3=Tue, 4=Wed, 5=Thu, 6=Fri, 7=Sat
                  
                  if (schedule_type == 0) {  // Specific days
                    return (day_of_week == 2 && id(program_a_monday).state) ||
                           (day_of_week == 3 && id(program_a_tuesday).state) ||
                           (day_of_week == 4 && id(program_a_wednesday).state) ||
                           (day_of_week == 5 && id(program_a_thursday).state) ||
                           (day_of_week == 6 && id(program_a_friday).state) ||
                           (day_of_week == 7 && id(program_a_saturday).state) ||
                           (day_of_week == 1 && id(program_a_sunday).state);
                  } else if (schedule_type == 1) {  // Odd days
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {  // Even days
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {  // Interval
                    if (id(program_a_last_run) == 0) return true;  // Never run before
                    long days_since = (time.timestamp - id(program_a_last_run)) / 86400;
                    return (days_since >= id(program_a_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    
                    // Count zones in Program A
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 1 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 1 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 1 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 1 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 1 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 1 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 1 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 1 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM A TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 1
                    allow_queue: true  # Changed to true so programs can queue
          # Check Program B
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_b_enabled)) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping Program B check");
                    return false;
                  }
                  
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        // Only log once per hour to reduce spam
                        long now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= 3600) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  int current_hour = time.hour;
                  int start_hour = id(program_b_start_hour);
                  if (id(program_b_am_pm) == 1) {
                    start_hour = (start_hour == 12) ? 12 : start_hour + 12;
                  } else {
                    start_hour = (start_hour == 12) ? 0 : start_hour;
                  }
                  
                  if (current_hour != start_hour || time.minute != id(program_b_start_minute)) return false;
                  
                  int schedule_type = id(program_b_schedule_type);
                  int day_of_month = time.day_of_month;
                  int day_of_week = time.day_of_week;  // 1=Sun, 2=Mon, 3=Tue, 4=Wed, 5=Thu, 6=Fri, 7=Sat
                  
                  if (schedule_type == 0) {  // Specific Days
                    return (day_of_week == 2 && id(program_b_monday).state) ||
                           (day_of_week == 3 && id(program_b_tuesday).state) ||
                           (day_of_week == 4 && id(program_b_wednesday).state) ||
                           (day_of_week == 5 && id(program_b_thursday).state) ||
                           (day_of_week == 6 && id(program_b_friday).state) ||
                           (day_of_week == 7 && id(program_b_saturday).state) ||
                           (day_of_week == 1 && id(program_b_sunday).state);
                  } else if (schedule_type == 1) {  // Odd days
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {
                    if (id(program_b_last_run) == 0) return true;
                    long days_since = (time.timestamp - id(program_b_last_run)) / 86400;
                    return (days_since >= id(program_b_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    
                    // Count zones in Program B
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 2 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 2 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 2 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 2 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 2 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 2 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 2 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 2 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM B TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 2
                    allow_queue: true  # Changed to true so programs can queue
          # Check Program C
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_c_enabled)) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping Program C check");
                    return false;
                  }
                  
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        // Only log once per hour to reduce spam
                        long now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= 3600) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  int current_hour = time.hour;
                  int start_hour = id(program_c_start_hour);
                  if (id(program_c_am_pm) == 1) {
                    start_hour = (start_hour == 12) ? 12 : start_hour + 12;
                  } else {
                    start_hour = (start_hour == 12) ? 0 : start_hour;
                  }
                  
                  if (current_hour != start_hour || time.minute != id(program_c_start_minute)) return false;
                  
                  int schedule_type = id(program_c_schedule_type);
                  int day_of_month = time.day_of_month;
                  int day_of_week = time.day_of_week;  // 1=Sun, 2=Mon, 3=Tue, 4=Wed, 5=Thu, 6=Fri, 7=Sat
                  
                  if (schedule_type == 0) {  // Specific Days
                    return (day_of_week == 2 && id(program_c_monday).state) ||
                           (day_of_week == 3 && id(program_c_tuesday).state) ||
                           (day_of_week == 4 && id(program_c_wednesday).state) ||
                           (day_of_week == 5 && id(program_c_thursday).state) ||
                           (day_of_week == 6 && id(program_c_friday).state) ||
                           (day_of_week == 7 && id(program_c_saturday).state) ||
                           (day_of_week == 1 && id(program_c_sunday).state);
                  } else if (schedule_type == 1) {  // Odd days
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {
                    if (id(program_c_last_run) == 0) return true;
                    long days_since = (time.timestamp - id(program_c_last_run)) / 86400;
                    return (days_since >= id(program_c_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    
                    // Count zones in Program C
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 3 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 3 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 3 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 3 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 3 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 3 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 3 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 3 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM C TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 3
                    allow_queue: true  # Changed to true so programs can queue

      # Update smart multiplier at midnight based on temperature and season
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              auto time = id(homeassistant_time).now();
              if (!time.is_valid()) {
                ESP_LOGW("irrigation", "Time not synchronized - skipping multiplier update");
                return;
              }
              
              int month = time.month;
              float temp = id(outside_temperature).state;
              if (isnan(temp)) {
                ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
                temp = 20.0;
              }
              
              float multiplier = 1.0;
              
              // Base seasonal multiplier
              if (month >= 12 || month <= 2) {
                multiplier = 1.3;  // Summer base
                // Hot days need more water
                if (temp > 25) multiplier = 1.6;
                if (temp > 30) multiplier = 1.8;
              } else if (month >= 6 && month <= 8) {
                multiplier = 0.5;  // Winter base
                // Cold days need less
                if (temp < 10) multiplier = 0.3;
              } else {
                // Spring/Autumn
                multiplier = 0.8;
                if (temp > 20) multiplier = 1.0;
              }
              
              id($devicename1).set_multiplier(multiplier);
              ESP_LOGI("irrigation", "Multiplier set to %.1f (temp: %.1fÂ°C)", multiplier, temp);

# Check every minute for individual zone schedules
      - seconds: 0
        # NO minutes filter - check EVERY minute!
        then:
          # Zone 1 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone1_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone1_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone1_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  // Debug logging every minute when zone schedule is enabled
                  if (id(zone1_schedule_enabled)) {
                    ESP_LOGD("irrigation", "Zone 1 Check: Now=%02d:%02d, Set=%d:%02d %s (24h=%02d:%02d), Match=%d",
                             time.hour, time.minute,
                             hour_12, id(zone1_start_minute), id(zone1_am_pm) == 0 ? "AM" : "PM",
                             hour_24, id(zone1_start_minute),
                             (time.hour == hour_24 && time.minute == id(zone1_start_minute)) ? 1 : 0);
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone1_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_1_duration).state;
                    int hour_12 = id(zone1_start_hour);
                    int minute = id(zone1_start_minute);
                    const char* ampm = (id(zone1_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 1 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 0
                    duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                    add_delay: true
                    allow_queue: true

          # Zone 2 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone2_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone2_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone2_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone2_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_2_duration).state;
                    int hour_12 = id(zone2_start_hour);
                    int minute = id(zone2_start_minute);
                    const char* ampm = (id(zone2_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 2 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 1
                    duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 3 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone3_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone3_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone3_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone3_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_3_duration).state;
                    int hour_12 = id(zone3_start_hour);
                    int minute = id(zone3_start_minute);
                    const char* ampm = (id(zone3_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 3 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 2
                    duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 4 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone4_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone4_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone4_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone4_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_4_duration).state;
                    int hour_12 = id(zone4_start_hour);
                    int minute = id(zone4_start_minute);
                    const char* ampm = (id(zone4_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 4 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 3
                    duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 5 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone5_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone5_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone5_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone5_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_5_duration).state;
                    int hour_12 = id(zone5_start_hour);
                    int minute = id(zone5_start_minute);
                    const char* ampm = (id(zone5_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 5 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 4
                    duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 6 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone6_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone6_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone6_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone6_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_6_duration).state;
                    int hour_12 = id(zone6_start_hour);
                    int minute = id(zone6_start_minute);
                    const char* ampm = (id(zone6_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 6 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 5
                    duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 7 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;


                  if (!id(zone7_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) return false;
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone7_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone7_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone7_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_7_duration).state;
                    int hour_12 = id(zone7_start_hour);
                    int minute = id(zone7_start_minute);
                    const char* ampm = (id(zone7_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 7 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 6
                    duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 8 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone8_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) return false;
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone8_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone8_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone8_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_8_duration).state;
                    int hour_12 = id(zone8_start_hour);
                    int minute = id(zone8_start_minute);
                    const char* ampm = (id(zone8_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 8 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 7
                    duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                    add_delay: true
                    allow_queue: true

          # Weekly Schedule (Schedule 1-7: Monday-Sunday)
          # Like Hunter Pro-C: Runs ALL enabled zones at set time on selected days
          - if:
              condition:
                lambda: |-
                  // Must have irrigation system enabled
                  if (!id(irrigation_system_enable).state) return false;
                  
                  // Must have weekly schedule enabled
                  if (!id(weekly_schedule_switch).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Weekly schedule: Time not synchronized");
                    return false;
                  }
                  
                  // Check rain delay
                  if (id(rain_delay_end_time) > time.timestamp) {
                    ESP_LOGD("irrigation", "Weekly schedule blocked - rain delay active");
                    return false;
                  }
                  
                  // Weather check (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Weekly schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction check
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Get scheduled time
                  int hour_12 = (int)id(schedule_start_hour).state;
                  int minute = (int)id(schedule_start_minute).state;
                  int hour_24 = hour_12;
                  
                  // Convert 12-hour + AM/PM to 24-hour
                  std::string am_pm = id(schedule_am_pm).current_option();
                  if (am_pm == "PM") {
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  // Check if current time matches scheduled time
                  if (time.hour != hour_24 || time.minute != minute) return false;
                  
                  // Check if today is a scheduled day
                  // ESPHome day_of_week: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday
                  int day_of_week = time.day_of_week;
                  
                  bool day_enabled = (day_of_week == 2 && id(schedule_monday).state) ||
                                     (day_of_week == 3 && id(schedule_tuesday).state) ||
                                     (day_of_week == 4 && id(schedule_wednesday).state) ||
                                     (day_of_week == 5 && id(schedule_thursday).state) ||
                                     (day_of_week == 6 && id(schedule_friday).state) ||
                                     (day_of_week == 7 && id(schedule_saturday).state) ||
                                     (day_of_week == 1 && id(schedule_sunday).state);
                  
                  if (!day_enabled) {
                    ESP_LOGD("irrigation", "Weekly schedule: Today not scheduled (day_of_week=%d)", day_of_week);
                  }
                  
                  return day_enabled;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    const char* day_names[] = {"", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
                    int dow = time.day_of_week;
                    
                    // Count enabled zones
                    int enabled_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_enable).state) { enabled_count++; zones_list += "Z1 "; }
                    if (id(zone2_enable).state) { enabled_count++; zones_list += "Z2 "; }
                    if (id(zone3_enable).state) { enabled_count++; zones_list += "Z3 "; }
                    if (id(zone4_enable).state) { enabled_count++; zones_list += "Z4 "; }
                    if (id(zone5_enable).state) { enabled_count++; zones_list += "Z5 "; }
                    if (id(zone6_enable).state) { enabled_count++; zones_list += "Z6 "; }
                    if (id(zone7_enable).state) { enabled_count++; zones_list += "Z7 "; }
                    if (id(zone8_enable).state) { enabled_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ”” WEEKLY SCHEDULE TRIGGERED                              â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Day: %-20s @ %02d:%02d                       â•‘",
                             day_names[dow], time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                        â•‘",
                             enabled_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•‘  Mode: Hunter Pro-C (full cycle with auto-advance)        â•‘");
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                    
                    // Check if system is busy
                    bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
                    
                    if (busy) {
                      // Queue as type 3 (full cycle)
                      if (id(queue_count) < 3) {
                        int pos = id(queue_count);
                        id(queue_types)[pos] = 3;  // 3 = Full Cycle (Weekly Schedule)
                        id(queue_programs)[pos] = 0;
                        id(queue_zones)[pos] = 0;
                        id(queue_durations)[pos] = 0;
                        id(queue_add_delays)[pos] = false;
                        id(queue_count)++;
                        
                        ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Weekly Schedule â†’ Slot %d/3 (%d zones will run when idle)",
                                 pos + 1, enabled_count);
                      } else {
                        ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Weekly Schedule will NOT run!");
                      }
                    } else {
                      ESP_LOGI("irrigation", "â–¶ï¸ STARTING Weekly Schedule immediately (system idle)");
                      // Start immediately
                      id(pending_normal_start) = true;
                      id(normal_start_attempts) = 0;
                      id(normal_last_attempt_ms) = 0;
                    }

interval:
  - interval: 500ms
    then:
      - if:
          condition:
            lambda: |-
              // Only act if a normal run is pending
              return id(pending_normal_start);
          then:
            - lambda: |-
                // If paused, don't attempt to start
                if (id(is_paused)) return;

                // If a valve is already active, we succeeded - clear pending
                if (id($devicename1).active_valve().has_value()) {
                  ESP_LOGI("irrigation", "âœ… Normal start succeeded (valve active) - clearing pending flag");
                  id(pending_normal_start) = false;
                  id(normal_start_attempts) = 0;
                  return;
                }

                // Throttle attempts to 1/sec max
                uint32_t now = millis();
                if (now - id(normal_last_attempt_ms) < 1000) return;
                id(normal_last_attempt_ms) = now;

                // Safety: stop retrying after 30 attempts (~30s)
                if (id(normal_start_attempts) >= 30) {
                  ESP_LOGE("irrigation", "âŒ Normal start failed after 30 attempts - giving up");
                  id(pending_normal_start) = false;
                  id(normal_start_attempts) = 0;
                  return;
                }

                id(normal_start_attempts)++;
                ESP_LOGI("irrigation", "â–¶ Attempting Normal start (attempt %d)", id(normal_start_attempts));

            # Try to start full cycle; if it's still stopping, next interval will retry
            - sprinkler.start_full_cycle: $devicename1

  # Update cycle & soak progress and master valve control every 500ms
  - interval: 500ms
    then:
      - lambda: |-
          // ====================================================================
          // MASTER VALVE CONTROL (Hunter Pro-C Style)
          // ====================================================================
          // Master valve opens ONLY if:
          // 1. Master valve system is enabled globally
          // 2. A zone is currently active
          // 3. That specific zone has MV enabled for it
          
          if (id(master_valve_enabled)) {
            auto active_valve = id($devicename1).active_valve();
            bool any_zone_active = active_valve.has_value();
            bool master_should_be_on = false;
            
            if (any_zone_active) {
              int zone = active_valve.value();  // 0-7
              
              // Check if this specific zone has master valve enabled
              bool zone_mv_enabled = false;
              switch(zone) {
                case 0: zone_mv_enabled = id(zone1_master_valve_enabled); break;
                case 1: zone_mv_enabled = id(zone2_master_valve_enabled); break;
                case 2: zone_mv_enabled = id(zone3_master_valve_enabled); break;
                case 3: zone_mv_enabled = id(zone4_master_valve_enabled); break;
                case 4: zone_mv_enabled = id(zone5_master_valve_enabled); break;
                case 5: zone_mv_enabled = id(zone6_master_valve_enabled); break;
                case 6: zone_mv_enabled = id(zone7_master_valve_enabled); break;
                case 7: zone_mv_enabled = id(zone8_master_valve_enabled); break;
              }
              
              master_should_be_on = zone_mv_enabled;
              
              // Log zone MV status (debug level to avoid spam)
              static int last_logged_zone = -1;
              static bool last_logged_mv_state = false;
              if (zone != last_logged_zone || zone_mv_enabled != last_logged_mv_state) {
                ESP_LOGD("irrigation", "Zone %d active - MV for this zone: %s",
                         zone + 1, zone_mv_enabled ? "ENABLED" : "DISABLED");
                last_logged_zone = zone;
                last_logged_mv_state = zone_mv_enabled;
              }
            }
            
            bool master_is_on = id(master_valve_relay).state;
            
            // Control master valve based on zone requirements
            // SKIP auto-control during test mode to prevent interference
            if (!id(test_mode_active)) {
              if (master_should_be_on && !master_is_on) {
                id(master_valve_relay).turn_on();
                if (any_zone_active) {
                  auto active = id($devicename1).active_valve();
                  ESP_LOGI("irrigation", "âœ… Master Valve OPENED (Zone %d active, MV enabled for this zone)",
                           active.value() + 1);
                }
              } else if (!master_should_be_on && master_is_on) {
                id(master_valve_relay).turn_off();
                ESP_LOGI("irrigation", "ğŸ”’ Master Valve CLOSED (no zones active or zone MV disabled)");
              }
            }
          } else {
            // Master valve system disabled - ensure it's off (UNLESS testing)
            if (!id(test_mode_active) && id(master_valve_relay).state) {
              id(master_valve_relay).turn_off();
              ESP_LOGD("irrigation", "Master valve turned off (system disabled)");
            }
          }
          
          // Update soak countdown if currently soaking
          if (id(cycle_soak_is_soaking) && id(cycle_soak_soak_end_time) > 0) {
            long now = id(homeassistant_time).now().timestamp;
            int remaining = id(cycle_soak_soak_end_time) - now;
            if (remaining < 0) remaining = 0;
            id(soak_countdown_seconds) = remaining;
          } else {
            id(soak_countdown_seconds) = 0;
          }
          
          // Only increment if ALL conditions are met:
          // 1. Cycle & soak is active (total_duration > 0)
          // 2. Not finished yet (elapsed < total)
          // 3. NOT paused
          if (id(cycle_soak_total_duration) > 0 &&
              id(cycle_soak_elapsed_time) < id(cycle_soak_total_duration) &&
              !id(is_paused)) {
            
            bool valve_active = id($devicename1).active_valve().has_value();
            bool is_soaking = id(cycle_soak_is_soaking);
            
            // Increment if we're in an active cycle/soak session
            // (either watering OR soaking, but not idle between operations)
            if (valve_active || is_soaking) {
              id(cycle_soak_elapsed_time) += 2;  // Increment by 2 (interval is 2s)
              
              // Cap at total duration
              if (id(cycle_soak_elapsed_time) > id(cycle_soak_total_duration)) {
                id(cycle_soak_elapsed_time) = id(cycle_soak_total_duration);
              }
              
              // Debug logging every 10 seconds
              static int log_counter = 0;
              log_counter++;
              if (log_counter >= 5) {  // Every 10 seconds (5 * 2s intervals)
                ESP_LOGD("irrigation", "Progress: %d/%d sec (valve=%d, soaking=%d)",
                         id(cycle_soak_elapsed_time), id(cycle_soak_total_duration),
                         valve_active, is_soaking);
                log_counter = 0;
              }
            }
          }
  
# Watchdog - Check for stuck states every 30 seconds
  - interval: 30s
    then:
      - lambda: |-
          long now = id(homeassistant_time).now().timestamp;
          if (now == 0) return;  // Time not synced yet
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // PRODUCTION FEATURE CHECKS (Every 30s)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // 1. FREEZE PROTECTION
          float temp = id(outside_temperature).state;
          if (!isnan(temp)) {
            bool freeze_risk = temp < id(freeze_threshold);
            
            if (freeze_risk && !id(freeze_protection_active)) {
              // Activate freeze protection
              id(freeze_protection_active) = true;
              ESP_LOGW("irrigation", "");
              ESP_LOGW("irrigation", "â„ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGW("irrigation", "â„ï¸ FREEZE PROTECTION ACTIVATED");
              ESP_LOGW("irrigation", "â„ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGW("irrigation", "â„ï¸ Temperature: %.1fÂ°C (threshold: %.1fÂ°C)", temp, id(freeze_threshold));
              ESP_LOGW("irrigation", "â„ï¸ All watering DISABLED until temperature rises above %.1fÂ°C", id(freeze_threshold) + 3.0);
              
              // Close master valve for safety
              if (id(master_valve_relay).state) {
                id(master_valve_relay).turn_off();
                ESP_LOGW("irrigation", "â„ï¸ Master valve CLOSED for safety");
              }
              
              // Stop any active watering
              if (id($devicename1).active_valve().has_value()) {
                id($devicename1).shutdown();
                ESP_LOGW("irrigation", "â„ï¸ Active watering STOPPED");
              }
              
              ESP_LOGW("irrigation", "â„ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGW("irrigation", "");
              
            } else if (!freeze_risk && id(freeze_protection_active) && temp > (id(freeze_threshold) + 3.0)) {
              // Deactivate freeze protection (with 3Â°C hysteresis)
              id(freeze_protection_active) = false;
              ESP_LOGI("irrigation", "");
              ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "âœ… FREEZE PROTECTION DEACTIVATED");
              ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "âœ… Temperature: %.1fÂ°C - Normal operation resumed", temp);
              ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "");
            }
          }
          
          // 2. DAILY RUNTIME RESET (at midnight)
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            int current_day = time.day_of_month;
            if (current_day != id(last_runtime_reset_day)) {
              ESP_LOGI("irrigation", "ğŸŒ… New day detected - resetting daily runtime counters");
              id(zone1_runtime_today) = 0;
              id(zone2_runtime_today) = 0;
              id(zone3_runtime_today) = 0;
              id(zone4_runtime_today) = 0;
              id(zone5_runtime_today) = 0;
              id(zone6_runtime_today) = 0;
              id(zone7_runtime_today) = 0;
              id(zone8_runtime_today) = 0;
              id(last_runtime_reset_day) = current_day;
            }
          }
          
          // 3. MONTHLY BUDGET RESET
          if (time.is_valid()) {
            int current_month = time.month;
            if (current_month != id(last_reset_month)) {
              ESP_LOGI("irrigation", "ğŸ“… New month detected - resetting water budget");
              ESP_LOGI("irrigation", "   Previous month usage: %.1fL", id(current_month_usage));
              id(current_month_usage) = 0;
              id(last_reset_month) = current_month;
              id(budget_warning_sent) = false;
              id(budget_exceeded) = false;
            }
          }
          
          // 4. WATER BUDGET MONITORING
          if (id(monthly_water_budget) > 0) {
            float budget_percent = (id(current_month_usage) / id(monthly_water_budget)) * 100.0;
            
            // 80% warning
            if (budget_percent >= 80.0 && !id(budget_warning_sent)) {
              ESP_LOGW("irrigation", "âš ï¸ WATER BUDGET WARNING: %.1f%% used (%.1fL / %.1fL)",
                       budget_percent, id(current_month_usage), id(monthly_water_budget));
              id(budget_warning_sent) = true;
            }
            
            // 100% limit (unless override active)
            if (budget_percent >= 100.0 && !id(budget_exceeded) && !id(budget_override_active)) {
              ESP_LOGE("irrigation", "ğŸš« WATER BUDGET EXCEEDED: %.1f%% used!", budget_percent);
              ESP_LOGE("irrigation", "ğŸš« Watering will be BLOCKED until next month or override activated");
              id(budget_exceeded) = true;
              
              // Stop any active watering
              if (id($devicename1).active_valve().has_value()) {
                id($devicename1).shutdown();
                ESP_LOGW("irrigation", "ğŸš« Active watering STOPPED due to budget exceeded");
              }
            }
          }
          
          // 5. NETWORK LOSS DETECTION
          float temp_check = id(outside_temperature).state;
          float hum_check = id(outside_humidity).state;
          static int sensor_fail_count = 0;
          
          if (isnan(temp_check) && isnan(hum_check)) {
            sensor_fail_count++;
            if (sensor_fail_count >= 3 && !id(network_offline_mode)) {
              // 3 consecutive failures (90 seconds) = network likely offline
              id(network_offline_mode) = true;
              ESP_LOGW("irrigation", "ğŸ“¡ NETWORK OFFLINE MODE ACTIVATED");
              ESP_LOGW("irrigation", "ğŸ“¡ Using fallback multiplier: %.2f", id(fallback_multiplier));
              id($devicename1).set_multiplier(id(fallback_multiplier));
            }
          } else {
            sensor_fail_count = 0;
            if (id(network_offline_mode)) {
              id(network_offline_mode) = false;
              ESP_LOGI("irrigation", "ğŸ“¡ NETWORK ONLINE - Normal operation resumed");
            }
          }

          // --------------------------------------------------
          // PAUSE STATE WATCHDOG (24h safety)
          // --------------------------------------------------
          if (id(is_paused)) {
            static long pause_start_time = 0;
            if (pause_start_time == 0) {
              pause_start_time = now;
            }

            long paused_duration = now - pause_start_time;

            if (paused_duration > 86400) {
              ESP_LOGE("irrigation",
                "WATCHDOG: Paused for >24 hours (%ld sec) - auto-clearing abandoned pause",
                paused_duration);

              id(is_paused) = false;
              id(irrigation_busy) = false;
              id(in_program_run) = false;

              id(paused_zone) = -1;
              id(paused_cycle) = 0;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              id(paused_total_cycles) = 0;
              id(paused_cycle_soak_total_duration) = 0;
              id(paused_cycle_soak_elapsed_time) = 0;

              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;

              pause_start_time = 0;
              id(drain_queue).execute();
            }
            else if (paused_duration > 3600) {
              if ((paused_duration % 3600) < 30) {
                ESP_LOGW("irrigation",
                  "WATCHDOG: System paused for %ld hours",
                  paused_duration / 3600);
              }
            }

            return;
          }
          else {
            static long pause_start_time = 0;
            pause_start_time = 0;
          }

          // --------------------------------------------------
          // ACTIVE STATE CHECK
          // --------------------------------------------------
          bool valve_active = id($devicename1).active_valve().has_value();
          bool script_running =
            id(run_zone_with_cycles).is_running() ||
            id(run_program).is_running() ||
            id(run_all_zones_cycle_soak_script).is_running();
          bool soaking = id(cycle_soak_is_soaking);

          if (valve_active || script_running || soaking) {
            id(watchdog_last_activity) = now;
            return;
          }

          // --------------------------------------------------
          // SIMPLE FIX: CLEAN COMPLETION AUTO-CLEAR
          // --------------------------------------------------
          if (id(irrigation_busy) &&
              !valve_active &&
              !script_running &&
              !soaking &&
              !id(is_paused)) {

            ESP_LOGI("irrigation",
              "Run finished cleanly â€” auto-clearing busy flag");

            id(irrigation_busy) = false;
            id(in_program_run) = false;
            id(active_zone_number) = -1;
            id(current_cycle) = 0;
            id(total_cycles) = 0;

            id(drain_queue).execute();
            return;
          }

          // --------------------------------------------------
          // WATCHDOG ESCALATION (REAL STUCK STATES)
          // --------------------------------------------------
          if (id(irrigation_busy)) {
            long last = id(watchdog_last_activity);
            if (last == 0) last = now;
            long idle_seconds = now - last;

            if (idle_seconds >= 60) {
              ESP_LOGE("irrigation",
                "WATCHDOG: System stuck for %ld seconds - clearing busy flag",
                idle_seconds);
              ESP_LOGE("irrigation",
                "  valve_active=%d, script_running=%d, soaking=%d, busy=%d",
                valve_active, script_running, soaking, id(irrigation_busy));

              id(irrigation_busy) = false;
              id(in_program_run) = false;
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;

              id(drain_queue).execute();
            }
            else if (idle_seconds >= 30) {
              ESP_LOGW("irrigation",
                "WATCHDOG: System idle for %ld seconds (busy=%d)",
                idle_seconds, id(irrigation_busy));
            }
          }

          // --------------------------------------------------
          // QUEUE SAFETY CHECK
          // --------------------------------------------------
          if (id(queued_type) != 0 &&
              !id(irrigation_busy) &&
              !id(is_paused) &&
              !valve_active &&
              !script_running &&
              !soaking) {

            ESP_LOGI("irrigation",
              "WATCHDOG: Queue has items but system is idle - draining");
            id(drain_queue).execute();
          }

  # Update time restriction status every 5 seconds for faster response
  - interval: 5s
    then:
      - script.execute: check_time_restriction

###############################################
# Text sensors with general information
###############################################
text_sensor:
  - platform: version
    name: $esphome_name ESPHome Version
    hide_timestamp: false
    internal: true

# Current Time and Day Display
  - platform: template
    id: current_time_display
    name: "Current Time"
    icon: "mdi:clock-digital"
    update_interval: 1s
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) return {"Time not synced"};
      
      int hour_12 = time.hour;
      std::string am_pm = "AM";
      
      if (hour_12 >= 12) {
        am_pm = "PM";
        if (hour_12 > 12) hour_12 -= 12;
      }
      if (hour_12 == 0) hour_12 = 12;
      
      char buffer[20];
      sprintf(buffer, "%d:%02d %s", hour_12, time.minute, am_pm.c_str());
      return {std::string(buffer)};

  - platform: template
    id: current_day_display
    name: "Current Day"
    icon: "mdi:calendar-today"
    update_interval: 60s
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) return {"Day unknown"};
      
      const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
      // ESPHome: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday
      int day_index = time.day_of_week - 1;
      if (day_index < 0 || day_index > 6) return {"Error"};
      
      return {std::string(days[day_index])};

  - platform: template
    id: current_datetime_display
    name: "Current Date & Time"
    icon: "mdi:calendar-clock"
    update_interval: 1s
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) return {"Not synced"};
      
      const char* days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
      int day_index = time.day_of_week - 1;
      
      int hour_12 = time.hour;
      std::string am_pm = "AM";
      if (hour_12 >= 12) {
        am_pm = "PM";
        if (hour_12 > 12) hour_12 -= 12;
      }
      if (hour_12 == 0) hour_12 = 12;
      
      char buffer[50];
      sprintf(buffer, "%s %d/%d/%d %d:%02d %s",
              days[day_index], time.day_of_month, time.month, time.year,
              hour_12, time.minute, am_pm.c_str());
      return {std::string(buffer)};

  # Predictive Wateringâ„¢ status
  - platform: template
    name: "$dev1_what Predictive Watering Status"
    icon: "mdi:water-check"
    update_interval: 10s
    lambda: |-
      if (!id(predictive_watering_enabled)) {
        return {"Disabled"};
      }
      
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        return {"Waiting for time sync"};
      }
      
      long last_calc = id(pw_last_calculation_time);
      
      if (last_calc == 0) {
        return {"Initializing..."};
      }
      
      float multiplier = id(pw_current_multiplier);
      int pct_change = (int)((multiplier - 1.0) * 100);
      
      // Calculate next update time (hourly updates)
      long current_time = time.timestamp;
      long time_since_calc = current_time - last_calc;
      long next_calc_sec = 3600 - (time_since_calc % 3600); // 3600 = 1 hour
      int mins_until = next_calc_sec / 60;
      
      char buf[80];
      
      // Determine status description
      if (multiplier >= 1.8) {
        snprintf(buf, sizeof(buf), "Very Hot (+%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 1.5) {
        snprintf(buf, sizeof(buf), "Hot Weather (+%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 1.2) {
        snprintf(buf, sizeof(buf), "Warm (+%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 0.95 && multiplier <= 1.05) {
        snprintf(buf, sizeof(buf), "Normal (%.2fx) - Next: %dm", multiplier, mins_until);
      } else if (multiplier >= 0.5) {
        snprintf(buf, sizeof(buf), "Reduced (%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 0.3) {
        snprintf(buf, sizeof(buf), "Cool/Rainy (%d%%) - Next: %dm", pct_change, mins_until);
      } else {
        snprintf(buf, sizeof(buf), "Minimal (%d%%) - Next: %dm", pct_change, mins_until);
      }
      
      return {buf};

  # Smart ET Watering status
  - platform: template
    name: "$dev1_what Smart ET Status"
    icon: "mdi:sprinkler-variant"
    update_interval: 5s
    lambda: |-
      if (!id(smart_et_enabled)) {
        return {"Disabled"};
      }
      
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        return {"Waiting for time sync"};
      }
      
      float deficit = id(et_soil_moisture_deficit);
      float threshold = id(et_water_threshold);
      float pct = (deficit / threshold) * 100.0;
      float et_mult = id(et_duration_multiplier);
      
      char buf[80];
      
      if (id(et_pending_irrigation)) {
        // Show scheduled time when pending
        snprintf(buf, sizeof(buf), "PENDING - Next: %d:%02d %s", 
                 id(et_schedule_hour),
                 id(et_schedule_minute),
                 id(et_schedule_am_pm) == 0 ? "AM" : "PM");
        return {buf};
      }
      
      if (deficit >= threshold) {
        // Show that watering is ready and when it will happen
        float deficit_ratio = deficit / threshold;
        snprintf(buf, sizeof(buf), "READY @ %d:%02d %s (%.0f%% over)", 
                 id(et_schedule_hour),
                 id(et_schedule_minute),
                 id(et_schedule_am_pm) == 0 ? "AM" : "PM",
                 (deficit_ratio - 1.0) * 100);
        return {buf};
      }
      
      if (et_mult > 1.0) {
        snprintf(buf, sizeof(buf), "OK (%.1fmm, %.0f%%) [%.2fx]", deficit, pct, et_mult);
      } else {
        snprintf(buf, sizeof(buf), "OK (%.1fmm, %.0f%%)", deficit, pct);
      }
      return {buf};

# Master Valve Status Display (Hunter Pro-C Style)
  - platform: template
    id: master_valve_status
    name: "Master Valve Status"
    icon: "mdi:valve"
    update_interval: 2s
    lambda: |-
      if (!id(master_valve_enabled)) {
        return {"System Disabled"};
      }
      
      bool mv_is_on = id(master_valve_relay).state;
      auto active_valve = id($devicename1).active_valve();
      
      if (!active_valve.has_value()) {
        if (mv_is_on) {
          return std::string("âš ï¸ ON (no zone active)");
        } else {
          return std::string("Closed (Standby)");
        }
      }
      
      int zone = active_valve.value();
      bool zone_mv_enabled = false;
      
      switch(zone) {
        case 0: zone_mv_enabled = id(zone1_master_valve_enabled); break;
        case 1: zone_mv_enabled = id(zone2_master_valve_enabled); break;
        case 2: zone_mv_enabled = id(zone3_master_valve_enabled); break;
        case 3: zone_mv_enabled = id(zone4_master_valve_enabled); break;
        case 4: zone_mv_enabled = id(zone5_master_valve_enabled); break;
        case 5: zone_mv_enabled = id(zone6_master_valve_enabled); break;
        case 6: zone_mv_enabled = id(zone7_master_valve_enabled); break;
        case 7: zone_mv_enabled = id(zone8_master_valve_enabled); break;
      }
      
      char buffer[80];
      if (zone_mv_enabled) {
        sprintf(buffer, "âœ… OPEN - Zone %d (MV Enabled)", zone + 1);
      } else {
        sprintf(buffer, "ğŸ”’ Closed - Zone %d (MV Disabled)", zone + 1);
      }
      return {std::string(buffer)};

# Weekly Schedule Status (Hunter Pro-C Style)
  - platform: template
    id: weekly_schedule_status
    name: "Weekly Schedule Status"
    icon: "mdi:calendar-clock"
    update_interval: 30s
    lambda: |-
      if (!id(weekly_schedule_switch).state) {
        return {"Disabled"};
      }
      
      // Build list of enabled days
      std::string days = "";
      if (id(schedule_monday).state) days += "Mon ";
      if (id(schedule_tuesday).state) days += "Tue ";
      if (id(schedule_wednesday).state) days += "Wed ";
      if (id(schedule_thursday).state) days += "Thu ";
      if (id(schedule_friday).state) days += "Fri ";
      if (id(schedule_saturday).state) days += "Sat ";
      if (id(schedule_sunday).state) days += "Sun ";
      
      if (days.empty()) {
        return {"Enabled - No days selected!"};
      }
      
      // Remove trailing space
      if (!days.empty()) days.pop_back();
      
      // Get scheduled time
      int hour = (int)id(schedule_start_hour).state;
      int minute = (int)id(schedule_start_minute).state;
      std::string am_pm = id(schedule_am_pm).current_option();
      
      char buffer[150];
      sprintf(buffer, "âœ“ Active: %s @ %d:%02d %s (All enabled zones)",
              days.c_str(), hour, minute, am_pm.c_str());
      return {std::string(buffer)};

# Program status sensors
  - platform: template
    id: program_a_status
    name: "Program A Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_a_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_a_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_a_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_a_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_a_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_a_interval_days)) + " days";
      
      int hour = id(program_a_start_hour);
      std::string am_pm = (id(program_a_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_a_start_minute) < 10 ? "0" : "") + std::to_string(id(program_a_start_minute)) + " " + am_pm};

  - platform: template
    id: program_b_status
    name: "Program B Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_b_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_b_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_b_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_b_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_b_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_b_interval_days)) + " days";
      
      int hour = id(program_b_start_hour);
      std::string am_pm = (id(program_b_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_b_start_minute) < 10 ? "0" : "") + std::to_string(id(program_b_start_minute)) + " " + am_pm};

  - platform: template
    id: program_c_status
    name: "Program C Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_c_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_c_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_c_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_c_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_c_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_c_interval_days)) + " days";
      
      int hour = id(program_c_start_hour);
      std::string am_pm = (id(program_c_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_c_start_minute) < 10 ? "0" : "") + std::to_string(id(program_c_start_minute)) + " " + am_pm};

# Vacation Mode Status
  - platform: template
    id: vacation_mode_status
    name: "Vacation Mode Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (id(vacation_mode_active)) {
        float current_mult = id($devicename1).multiplier();
        return {"Active - Watering at " + std::to_string((int)(current_mult * 100)) + "%"};
      }
      return {"Inactive"};

  # Expose Time Remaining as a sensor
  - platform: template
    id: dev1_time_remaining
    name: $upper_devicename1 Time Remaining
    update_interval: $sensor_update_frequency
    icon: "mdi:timer-sand"
    lambda: |-
      int seconds = round(id($devicename1).time_remaining_active_valve().value_or(0));
      int days = seconds / (24 * 3600);
      seconds = seconds % (24 * 3600);
      int hours = seconds / 3600;
      seconds = seconds % 3600;
      int minutes = seconds /  60;
      seconds = seconds % 60;
      std::string result = "";
      if (days) result += std::to_string(days) + "d ";
      if (hours) result += std::to_string(hours) + "h ";
      if (minutes) result += std::to_string(minutes) + "m ";
      result += std::to_string(seconds) + "s";
      return result;
          
# Expose Progress Percent as a sensor
  - platform: template
    id: dev1_progress_percent
    name: $upper_devicename1 Progress %
    update_interval: $sensor_update_frequency
    icon: "mdi:progress-clock"
    lambda: |-
      // Check if a valve is active
      if (!id($devicename1).active_valve().has_value()) {
        return {"0%"};
      }
      
      auto valve_num = id($devicename1).active_valve().value();
      auto remaining = id($devicename1).time_remaining_active_valve().value_or(0);
      auto duration = id($devicename1).valve_run_duration_adjusted(valve_num);
      
      if (duration <= 0 || remaining < 0) {
        return {"0%"};
      }
      
      float elapsed = duration - remaining;
      int progress = (int)((elapsed / duration) * 100.0);
      
      if (progress < 0) progress = 0;
      if (progress > 100) progress = 100;
      
      return {std::to_string(progress) + "%"};
      
  # Expose Valve Status as a sensor
  - platform: template
    id: dev1_valve_status
    name: $upper_devicename1 Status
    update_interval: never
    icon: "mdi:information-variant"
    
  - platform: template
    id: espboard_type
    icon: "mdi:developer-board"
    name: $esphome_name ESPBoard
    update_interval: 3600s
    internal: true
    lambda: |-
      return {"${esp32_board}"};

# Weather state from Home Assistant
  - platform: homeassistant
    id: weather_forecast_home
    entity_id: weather.home
    internal: true
    on_value:
      then:
        # Immediately react to weather changes
        - lambda: |-
            // Only auto-manage rain delay if manual override is OFF
            if (!id(manual_rain_delay_override)) {
              std::string weather = x;
              if (weather.empty() || weather == "unknown" || weather == "unavailable") {
                ESP_LOGW("irrigation", "Weather state unavailable - skipping auto rain delay update");
                return;
              }
              
              // Set rain delay if it starts raining
              if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (86400 * 2); // 2 day delay
                id(rain_delay_days) = 2;
                id(rain_delay_days_input).publish_state(2);
                ESP_LOGI("irrigation", "Auto rain delay activated immediately - weather changed to %s", weather.c_str());
              }
              // Clear rain delay if weather improves
              else if (weather == "sunny" || weather == "clear" || weather == "partlycloudy" || weather == "cloudy") {
                if (id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
                  id(rain_delay_end_time) = 0;
                  id(rain_delay_days) = 0;
                  id(rain_delay_days_input).publish_state(0);
                  ESP_LOGI("irrigation", "Auto rain delay cleared immediately - weather changed to %s", weather.c_str());
                }
              }
            }


  # Time Restriction Status (live)
  - platform: template
    id: time_restriction_status
    name: "Time Restriction Status"
    icon: "mdi:clock-alert"
    update_interval: 30s
    lambda: |-
      auto t = id(homeassistant_time).now();
      int sh = id(restrict_start_hour);
      int eh = id(restrict_end_hour);
      int s24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
      int e24 = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
      int now_min = t.hour * 60 + t.minute;
      int start_min = s24 * 60 + id(restrict_start_minute);
      int end_min   = e24 * 60 + id(restrict_end_minute);
      bool enabled = id(time_restriction_switch).state && !id(manual_time_restriction_override).state;
      bool blocked = enabled && ((start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                                       : (now_min >= start_min || now_min < end_min));
      char buf[96];
      snprintf(buf, sizeof(buf), "%s (%d:%02d %s - %d:%02d %s)",
               blocked ? "Restricted" : (enabled ? "Allowed" : "Disabled"),
               id(restrict_start_hour), id(restrict_start_minute), (id(restrict_start_am_pm) == 0 ? "AM" : "PM"),
               id(restrict_end_hour), id(restrict_end_minute), (id(restrict_end_am_pm) == 0 ? "AM" : "PM"));
      return {buf};

  - platform: template
    id: time_restriction_next_allowed
    name: "Time Restriction Next Allowed"
    icon: "mdi:calendar-clock"
    update_interval: 30s
    lambda: |-
      auto t = id(homeassistant_time).now();
      int sh = id(restrict_start_hour);
      int eh = id(restrict_end_hour);
      int s24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
      int e24 = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
      int now_min = t.hour * 60 + t.minute;
      int start_min = s24 * 60 + id(restrict_start_minute);
      int end_min   = e24 * 60 + id(restrict_end_minute);
      bool enabled = id(time_restriction_switch).state && !id(manual_time_restriction_override).state;
      if (!enabled) return {"Now"};
      bool blocked = (start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                           : (now_min >= start_min || now_min < end_min);
      if (!blocked) return {"Now"};
      int next_min = end_min;
      int h24 = next_min / 60;
      int mm = next_min % 60;
      int ampm = (h24 >= 12) ? 1 : 0;
      int h12 = h24 % 12;
      if (h12 == 0) h12 = 12;
      char buf[32];
      snprintf(buf, sizeof(buf), "%d:%02d %s", h12, mm, (ampm == 0 ? "AM" : "PM"));
      return {buf};

# Weather condition display
  - platform: template
    id: weather_condition
    name: "Weather Condition"
    icon: "mdi:weather-partly-cloudy"
    lambda: |-
      if (id(weather_forecast_home).state.empty() || id(weather_forecast_home).state == "unknown" || id(weather_forecast_home).state == "unavailable") {
        return {"clear"};  // Default to clear if no data
      }
      return id(weather_forecast_home).state;


# Next scheduled watering day
  - platform: template
    id: next_watering_day
    name: "Next Watering Day"
    icon: "mdi:calendar-clock"
    update_interval: 30s  # Update every 30 seconds for faster response
    lambda: |-
      auto time = id(homeassistant_time).now();
      int current_day = time.day_of_week;
      
      const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
      
      // Check next 7 days
      for (int i = 1; i <= 7; i++) {
        int check_day = (current_day + i) % 7;
        if ((check_day == 1 && id(schedule_monday).state) ||
            (check_day == 2 && id(schedule_tuesday).state) ||
            (check_day == 3 && id(schedule_wednesday).state) ||
            (check_day == 4 && id(schedule_thursday).state) ||
            (check_day == 5 && id(schedule_friday).state) ||
            (check_day == 6 && id(schedule_saturday).state) ||
            (check_day == 0 && id(schedule_sunday).state)) {
          return {days[check_day]};
        }
      }
      return {"None scheduled"};

# Cycle & Soak detailed status
  - platform: template
    id: cycle_soak_detailed_status
    name: "Cycle & Soak Detailed Status"
    icon: "mdi:water-sync"
    update_interval: 1s  # Changed from 2s to 1s for faster updates
    lambda: |-
      // Check if we're in cycle & soak mode with active tracking
      if (id(cycle_soak_total_duration) > 0 && id(active_zone_number) >= 0) {
        // Check if a valve is currently watering
        if (id($devicename1).active_valve().has_value()) {
          int valve = id($devicename1).active_valve().value();
          return {"Zone " + std::to_string(valve + 1) + " - Cycle " +
                  std::to_string(id(current_cycle)) + "/" +
                  std::to_string(id(total_cycles)) + " - Watering"};
        } else {
          // No valve active but we're tracking - must be soaking
          if (id(current_cycle) <= id(total_cycles) && id(current_cycle) > 0) {
            int countdown_sec = id(soak_countdown_seconds);
            int countdown_min = countdown_sec / 60;
            int countdown_sec_remaining = countdown_sec % 60;
            
            return {"Zone " + std::to_string(id(active_zone_number) + 1) +
                    " - Soaking (" + std::to_string(countdown_min) + "m " +
                    std::to_string(countdown_sec_remaining) + "s remaining)"};
          }
        }
      }
      
      // Check if any valve is active in normal mode
      if (id($devicename1).active_valve().has_value()) {
        int valve = id($devicename1).active_valve().value();
        return {"Zone " + std::to_string(valve + 1) + " - Active"};
      }
      
      return {"Idle"};

# Zone 1 Last Watered
  - platform: template
    id: zone1_last_watered_text
    name: "Zone 1 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone1_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone1_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 2 Last Watered
  - platform: template
    id: zone2_last_watered_text
    name: "Zone 2 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone2_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone2_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 3 Last Watered
  - platform: template
    id: zone3_last_watered_text
    name: "Zone 3 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone3_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone3_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 4 Last Watered
  - platform: template
    id: zone4_last_watered_text
    name: "Zone 4 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone4_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone4_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 5 Last Watered
  - platform: template
    id: zone5_last_watered_text
    name: "Zone 5 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone5_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone5_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 6 Last Watered
  - platform: template
    id: zone6_last_watered_text
    name: "Zone 6 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone6_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone6_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 7 Last Watered
  - platform: template
    id: zone7_last_watered_text
    name: "Zone 7 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone7_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone7_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 8 Last Watered
  - platform: template
    id: zone8_last_watered_text
    name: "Zone 8 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone8_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone8_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Queue Status Display (Hunter Pro-C style)
  - platform: template
    id: queue_status_display
    name: "Queue Status"
    icon: "mdi:format-list-numbered"
    update_interval: 2s
    lambda: |-
      if (id(queue_count) == 0) {
        return {"Empty (0/3)"};
      }
      
      std::string result = std::to_string(id(queue_count)) + "/3: ";
      for (int i = 0; i < id(queue_count) && i < 3; i++) {
        if (i > 0) result += ", ";
        int type = id(queue_types)[i];
        if (type == 1) {
          // Program
          result += "Prg " + std::string(1, 'A' + id(queue_programs)[i] - 1);
        } else if (type == 2) {
          // Zone
          result += "Zone " + std::to_string(id(queue_zones)[i] + 1);
        }
      }
      return {result};

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MULTIPLIER BREAKDOWN DISPLAY (Whanganui - Sand Soil)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    id: multiplier_breakdown
    name: "$dev1_what Multiplier Breakdown"
    icon: "mdi:calculator"
    update_interval: 60s
    lambda: |-
      if (!id(predictive_watering_enabled)) {
        return {"Predictive Watering Disabled"};
      }
      
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) {
        return {"Time not synced"};
      }
      
      // Get seasonal factor
      float seasonal = 1.0;
      int month = time.month;
      switch (month) {
        case 1:  seasonal = id(seasonal_jan); break;
        case 2:  seasonal = id(seasonal_feb); break;
        case 3:  seasonal = id(seasonal_mar); break;
        case 4:  seasonal = id(seasonal_apr); break;
        case 5:  seasonal = id(seasonal_may); break;
        case 6:  seasonal = id(seasonal_jun); break;
        case 7:  seasonal = id(seasonal_jul); break;
        case 8:  seasonal = id(seasonal_aug); break;
        case 9:  seasonal = id(seasonal_sep); break;
        case 10: seasonal = id(seasonal_oct); break;
        case 11: seasonal = id(seasonal_nov); break;
        case 12: seasonal = id(seasonal_dec); break;
      }
      
      // Get soil factor
      float soil = 1.0;
      std::string soil_name = "Unknown";
      if (id(soil_type) == 0) {
        soil = 1.15;
        soil_name = "Sand";
      } else if (id(soil_type) == 1) {
        soil = 1.0;
        soil_name = "Loam";
      } else if (id(soil_type) == 2) {
        soil = 0.85;
        soil_name = "Clay";
      }
      
      // Get current multiplier
      float total = id(pw_current_multiplier);
      
      char buffer[150];
      sprintf(buffer, "Season: %.2f | Soil (%s): %.2f | Total: %.2f",
              seasonal, soil_name.c_str(), soil, total);
      return {std::string(buffer)};

sensor:
  # Uptime sensor
  - platform: uptime
    name: $upper_devicename1 Uptime
    internal: true

  # Internal sensors from Home Assistant (no template.publish here)
  - platform: homeassistant
    id: ha_temperature
    entity_id: weather.home
    attribute: temperature
    internal: true

  # Humidity from Met.no (weather.forecast_home) since Open-Meteo doesn't provide it
  - platform: homeassistant
    id: ha_humidity
    entity_id: weather.forecast_home
    attribute: humidity
    internal: true

  # Template sensors for display + fallback values
  - platform: template
    id: outside_temperature
    name: "Outside Temperature"
    icon: "mdi:thermometer"
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1
    lambda: |-
      if (isnan(id(ha_temperature).state)) {
        return 20.0;  // Default fallback temperature
      }
      return id(ha_temperature).state;

  - platform: template
    id: outside_humidity
    name: "Outside Humidity"
    icon: "mdi:water-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(ha_humidity).state)) {
        return 70.0;  // Default fallback humidity
      }
      return id(ha_humidity).state;
  
  # ============================================================
  # PREDICTIVE WATERINGâ„¢ WEATHER SENSORS
  # ============================================================
  # Wind speed sensor from Home Assistant
  - platform: homeassistant
    id: wind_speed
    entity_id: weather.home
    attribute: wind_speed
    internal: true
    filters:
      - lambda: |-
          if (isnan(x)) return 10.0;  // Default 10 km/h
          return x;
  
  # Rain forecast (precipitation amount in mm) from Home Assistant template sensor
  # This uses actual precipitation forecast instead of probability - MORE ACCURATE!
  # Create this sensor in Home Assistant configuration.yaml:
  # template:
  #   - sensor:
  #       - name: "Rain Forecast Today"
  #         unique_id: home_rain_forecast_0d
  #         state: >
  #           {% set forecast = state_attr('weather.home', 'forecast') %}
  #           {% if forecast and forecast|length > 0 %}
  #             {{ forecast[0].precipitation | default(0) }}
  #           {% else %}
  #             0
  #           {% endif %}
  #         unit_of_measurement: "mm"
  - platform: homeassistant
    id: rain_probability
    entity_id: sensor.home_rain_forecast_0d
    internal: true
    on_value:
      then:
        - lambda: |-
            // Only process valid numeric values
            if (!isnan(x) && x >= 0) {
              ESP_LOGD("irrigation", "Precipitation forecast updated: %.1f mm", x);
            }
    filters:
      - lambda: |-
          // Reject unavailable, unknown, or invalid values
          if (isnan(x) || x < 0) {
            // Keep previous value, don't update
            return {};
          }
          return x;  // Return actual mm value

  # Predictive Watering Multiplier Display
  - platform: template
    name: "$dev1_what Predictive Watering Multiplier"
    id: pw_multiplier_display
    icon: "mdi:water-percent"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 10s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_current_multiplier);
      }
      return {};

  # Individual factor displays
  - platform: template
    name: "$dev1_what PW Temperature Factor"
    icon: "mdi:thermometer"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_temperature_factor);
      }
      return {};

  - platform: template
    name: "$dev1_what PW Humidity Factor"
    icon: "mdi:water-percent"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_humidity_factor);
      }
      return {};

  - platform: template
    name: "$dev1_what PW Wind Factor"
    icon: "mdi:weather-windy"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_wind_factor);
      }
      return {};

  - platform: template
    name: "$dev1_what PW Rain Factor"
    icon: "mdi:weather-rainy"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_rain_factor);
      }
      return {};
  
  # ============================================================
  # SMART ET WATERING SENSORS
  # ============================================================
  - platform: template
    name: "$dev1_what ET Soil Moisture Deficit"
    id: et_deficit_display
    icon: "mdi:water-minus"
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      if (id(smart_et_enabled)) {
        return id(et_soil_moisture_deficit);
      }
      return {};

  - platform: template
    name: "$dev1_what ET Daily Evapotranspiration"
    icon: "mdi:water-outline"
    unit_of_measurement: "mm/day"
    accuracy_decimals: 1
    update_interval: 30s
    lambda: |-
      if (id(smart_et_enabled)) {
        return id(et_daily_et);
      }
      return {};

  - platform: template
    name: "$dev1_what ET Deficit Percentage"
    icon: "mdi:water-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      if (id(smart_et_enabled)) {
        float threshold = id(et_water_threshold);
        if (threshold > 0) {
          float pct = (id(et_soil_moisture_deficit) / threshold) * 100.0;
          if (pct > 100) pct = 100;
          return pct;
        }
      }
      return {};
  
  # Smart ET Duration Multiplier (shows deficit-based adjustment)
  - platform: template
    name: "$dev1_what ET Duration Multiplier"
    icon: "mdi:multiplication"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 10s
    lambda: |-
      if (id(smart_et_enabled)) {
        return id(et_duration_multiplier);
      }
      return {};
    
  # Rain delay countdown
  - platform: template
    id: rain_delay_remaining
    name: "Rain Delay Days Remaining"
    icon: "mdi:timer-sand"
    unit_of_measurement: "days"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      if (id(rain_delay_end_time) == 0) return 0.0f;
      long current_time = id(homeassistant_time).now().timestamp;
      long remaining_seconds = id(rain_delay_end_time) - current_time;
      if (remaining_seconds <= 0) {
        id(rain_delay_end_time) = 0;
        id(rain_delay_days) = 0;
        return 0.0f;
      }
      return remaining_seconds / 86400.0f;

  # Current seasonal multiplier
  - platform: template
    id: seasonal_multiplier
    name: "Seasonal Multiplier"
    icon: "mdi:calendar-month"
    unit_of_measurement: "x"
    accuracy_decimals: 1
    update_interval: 3600s
    lambda: |-
      return id($devicename1).multiplier();

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER USAGE TRACKING SENSORS (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Zone 1 Water Used
  - platform: template
    name: "$dev1_zone1 Water Used"
    id: zone1_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone1_water_used);"
    
  # Zone 2 Water Used
  - platform: template
    name: "$dev1_zone2 Water Used"
    id: zone2_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone2_water_used);"
    
  # Zone 3 Water Used
  - platform: template
    name: "$dev1_zone3 Water Used"
    id: zone3_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone3_water_used);"
    
  # Zone 4 Water Used
  - platform: template
    name: "$dev1_zone4 Water Used"
    id: zone4_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone4_water_used);"
    
  # Zone 5 Water Used
  - platform: template
    name: "$dev1_zone5 Water Used"
    id: zone5_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone5_water_used);"
    
  # Zone 6 Water Used
  - platform: template
    name: "$dev1_zone6 Water Used"
    id: zone6_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone6_water_used);"
    
  # Zone 7 Water Used
  - platform: template
    name: "$dev1_zone7 Water Used"
    id: zone7_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone7_water_used);"
    
  # Zone 8 Water Used
  - platform: template
    name: "$dev1_zone8 Water Used"
    id: zone8_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone8_water_used);"
    
  # Total System Water Used
  - platform: template
    name: "$dev1_what Total Water Used"
    id: total_water_sensor
    icon: "mdi:water-pump"
    unit_of_measurement: "L"
    accuracy_decimals: 1
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(total_water_used);"
  
  # Days Since Water Usage Reset
  - platform: template
    name: "$dev1_what Days Since Usage Reset"
    icon: "mdi:calendar-clock"
    unit_of_measurement: "days"
    accuracy_decimals: 1
    update_interval: 60s
    lambda: |-
      if (id(water_usage_reset_time) == 0) {
        return 0.0;
      }
      long now = id(homeassistant_time).now().timestamp;
      float days = (now - id(water_usage_reset_time)) / 86400.0;
      return days;

###############################################
# Binary Sensors (Status Indicators)
###############################################
binary_sensor:
  # Master Valve Status
  - platform: template
    name: "$dev1_what Master Valve Status"
    id: master_valve_status_sensor
    icon: "mdi:valve"
    device_class: opening
    lambda: "return id(master_valve_relay).state;"

###############################################
# Configuration to set multiplier via number
###############################################
number:
  # Manual multiplier override
  - platform: template
    id: "${dev1_what}_multiplier"
    name: "${devicename1}_multiplier"
    min_value: 0.01
    max_value: 2.00
    step: 0.01
    icon: "mdi:water-percent"
    mode: slider
    lambda: "return id($devicename1).multiplier();"
    set_action:
      - sprinkler.set_multiplier:
          id: $devicename1
          multiplier: !lambda 'return x;'

  # Rain delay days
  - platform: template
    id: rain_delay_days_input
    name: "Rain Delay Days"
    min_value: 0
    max_value: 14
    step: 1
    icon: "mdi:weather-rainy"
    mode: box
    lambda: "return id(rain_delay_days);"
    set_action:
      - lambda: |-
          id(rain_delay_days) = x;
          if (x > 0) {
            id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (x * 86400);
          } else {
            id(rain_delay_end_time) = 0;
          }

  # Smart ET watering threshold
  - platform: template
    id: et_threshold_input
    name: "$dev1_what ET Water Threshold"
    min_value: 10
    max_value: 50
    step: 1
    icon: "mdi:water-alert"
    mode: slider
    unit_of_measurement: "mm"
    lambda: "return id(et_water_threshold);"
    set_action:
      - lambda: |-
          id(et_water_threshold) = x;
          ESP_LOGI("irrigation", "ET threshold updated to %.0f mm", x);

  # Smart ET Schedule Time
  - platform: template
    id: et_schedule_hour_input
    name: "$dev1_what ET Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-time-four-outline"
    mode: box
    lambda: "return id(et_schedule_hour);"
    set_action:
      - lambda: |-
          id(et_schedule_hour) = (int)x;
          ESP_LOGI("irrigation", "Smart ET schedule hour updated to %d", (int)x);

  - platform: template
    id: et_schedule_minute_input
    name: "$dev1_what ET Schedule Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-outline"
    mode: box
    lambda: "return id(et_schedule_minute);"
    set_action:
      - lambda: |-
          id(et_schedule_minute) = (int)x;
          ESP_LOGI("irrigation", "Smart ET schedule minute updated to %02d", (int)x);

  # Quick run duration
  - platform: template
    id: quick_run_duration
    name: "Quick Run Duration"
    min_value: 1
    max_value: 15
    step: 1
    initial_value: 5
    icon: "mdi:timer"
    mode: slider
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ZONE FLOW RATES (For Water Usage Tracking)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    id: zone1_flow_rate_input
    name: "$dev1_zone1 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone1_flow_rate);"
    set_action:
      - lambda: "id(zone1_flow_rate) = x;"
      
  - platform: template
    id: zone2_flow_rate_input
    name: "$dev1_zone2 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone2_flow_rate);"
    set_action:
      - lambda: "id(zone2_flow_rate) = x;"
      
  - platform: template
    id: zone3_flow_rate_input
    name: "$dev1_zone3 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone3_flow_rate);"
    set_action:
      - lambda: "id(zone3_flow_rate) = x;"
      
  - platform: template
    id: zone4_flow_rate_input
    name: "$dev1_zone4 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone4_flow_rate);"
    set_action:
      - lambda: "id(zone4_flow_rate) = x;"
      
  - platform: template
    id: zone5_flow_rate_input
    name: "$dev1_zone5 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone5_flow_rate);"
    set_action:
      - lambda: "id(zone5_flow_rate) = x;"
      
  - platform: template
    id: zone6_flow_rate_input
    name: "$dev1_zone6 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone6_flow_rate);"
    set_action:
      - lambda: "id(zone6_flow_rate) = x;"
      
  - platform: template
    id: zone7_flow_rate_input
    name: "$dev1_zone7 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone7_flow_rate);"
    set_action:
      - lambda: "id(zone7_flow_rate) = x;"
      
  - platform: template
    id: zone8_flow_rate_input
    name: "$dev1_zone8 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone8_flow_rate);"
    set_action:
      - lambda: "id(zone8_flow_rate) = x;"

# Schedule start hour (12-hour format)
  - platform: template
    id: schedule_start_hour
    name: "Schedule Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    initial_value: 6
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    optimistic: true
    restore_value: true

# Schedule start minute
  - platform: template
    id: schedule_start_minute
    name: "Schedule Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true

# Cycle duration
  - platform: template
    id: cycle_duration_input
    name: "Cycle Duration"
    min_value: 3
    max_value: 20
    step: 1
    icon: "mdi:timer-play"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(cycle_duration_minutes);"
    set_action:
      - lambda: "id(cycle_duration_minutes) = x;"

  # Soak duration
  - platform: template
    id: soak_duration_input
    name: "Soak Duration"
    min_value: 3         # Match cycle minimum
    max_value: 20        # Match cycle maximum
    step: 1
    icon: "mdi:timer-pause"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(soak_duration_minutes);"
    set_action:
      - lambda: "id(soak_duration_minutes) = x;"

# Station delay between zones
  - platform: template
    id: station_delay_input
    name: "Station Delay Between Zones"
    min_value: 0
    max_value: 60
    step: 5
    icon: "mdi:timer-cog"
    mode: slider
    unit_of_measurement: "sec"
    lambda: "return id(station_delay_seconds);"
    set_action:
      - lambda: "id(station_delay_seconds) = x;"


  # Time Restriction Window (12-hour format)
  - platform: template
    id: restrict_start_hour_input
    name: "Time Restriction Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(restrict_start_hour);"
    set_action:
      - lambda: "id(restrict_start_hour) = (int)x;"

  - platform: template
    id: restrict_start_minute_input
    name: "Time Restriction Start Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(restrict_start_minute);"
    set_action:
      - lambda: "id(restrict_start_minute) = (int)x;"

  - platform: template
    id: restrict_end_hour_input
    name: "Time Restriction End Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(restrict_end_hour);"
    set_action:
      - lambda: "id(restrict_end_hour) = (int)x;"

  - platform: template
    id: restrict_end_minute_input
    name: "Time Restriction End Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(restrict_end_minute);"
    set_action:
      - lambda: "id(restrict_end_minute) = (int)x;"

# Zone 1 Schedule Time
  - platform: template
    id: zone1_schedule_hour
    name: "Zone 1 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone1_start_hour);"
    set_action:
      - lambda: "id(zone1_start_hour) = x;"

  - platform: template
    id: zone1_schedule_minute
    name: "Zone 1 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone1_start_minute);"
    set_action:
      - lambda: "id(zone1_start_minute) = x;"

# Zone 2 Schedule Time
  - platform: template
    id: zone2_schedule_hour
    name: "Zone 2 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone2_start_hour);"
    set_action:
      - lambda: "id(zone2_start_hour) = x;"

  - platform: template
    id: zone2_schedule_minute
    name: "Zone 2 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone2_start_minute);"
    set_action:
      - lambda: "id(zone2_start_minute) = x;"

  # Zone 3 Schedule Time
  - platform: template
    id: zone3_schedule_hour
    name: "Zone 3 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone3_start_hour);"
    set_action:
      - lambda: "id(zone3_start_hour) = x;"

  - platform: template
    id: zone3_schedule_minute
    name: "Zone 3 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone3_start_minute);"
    set_action:
      - lambda: "id(zone3_start_minute) = x;"

  # Zone 4 Schedule Time
  - platform: template
    id: zone4_schedule_hour
    name: "Zone 4 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone4_start_hour);"
    set_action:
      - lambda: "id(zone4_start_hour) = x;"

  - platform: template
    id: zone4_schedule_minute
    name: "Zone 4 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone4_start_minute);"
    set_action:
      - lambda: "id(zone4_start_minute) = x;"

  # Zone 5 Schedule Time
  - platform: template
    id: zone5_schedule_hour
    name: "Zone 5 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone5_start_hour);"
    set_action:
      - lambda: "id(zone5_start_hour) = x;"

  - platform: template
    id: zone5_schedule_minute
    name: "Zone 5 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone5_start_minute);"
    set_action:
      - lambda: "id(zone5_start_minute) = x;"

  # Zone 6 Schedule Time
  - platform: template
    id: zone6_schedule_hour
    name: "Zone 6 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone6_start_hour);"
    set_action:
      - lambda: "id(zone6_start_hour) = x;"

  - platform: template
    id: zone6_schedule_minute
    name: "Zone 6 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone6_start_minute);"
    set_action:
      - lambda: "id(zone6_start_minute) = x;"

  # Zone 7 Schedule Time
  - platform: template
    id: zone7_schedule_hour
    name: "Zone 7 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone7_start_hour);"
    set_action:
      - lambda: "id(zone7_start_hour) = x;"

  - platform: template
    id: zone7_schedule_minute
    name: "Zone 7 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone7_start_minute);"
    set_action:
      - lambda: "id(zone7_start_minute) = x;"

  # Zone 8 Schedule Time
  - platform: template
    id: zone8_schedule_hour
    name: "Zone 8 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone8_start_hour);"
    set_action:
      - lambda: "id(zone8_start_hour) = x;"

  - platform: template
    id: zone8_schedule_minute
    name: "Zone 8 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone8_start_minute);"
    set_action:
      - lambda: "id(zone8_start_minute) = x;"

# Program A start time
  - platform: template
    id: program_a_start_hour_input
    name: "Program A Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_a_start_hour);"
    set_action:
      - lambda: "id(program_a_start_hour) = x;"

  - platform: template
    id: program_a_start_minute_input
    name: "Program A Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_a_start_minute);"
    set_action:
      - lambda: "id(program_a_start_minute) = x;"

  - platform: template
    id: program_a_interval_input
    name: "Program A Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_a_interval_days);"
    set_action:
      - lambda: "id(program_a_interval_days) = x;"

  # Program B start time
  - platform: template
    id: program_b_start_hour_input
    name: "Program B Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_b_start_hour);"
    set_action:
      - lambda: "id(program_b_start_hour) = x;"

  - platform: template
    id: program_b_start_minute_input
    name: "Program B Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_b_start_minute);"
    set_action:
      - lambda: "id(program_b_start_minute) = x;"

  - platform: template
    id: program_b_interval_input
    name: "Program B Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_b_interval_days);"
    set_action:
      - lambda: "id(program_b_interval_days) = x;"

  # Program C start time
  - platform: template
    id: program_c_start_hour_input
    name: "Program C Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_c_start_hour);"
    set_action:
      - lambda: "id(program_c_start_hour) = x;"

  - platform: template
    id: program_c_start_minute_input
    name: "Program C Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_c_start_minute);"
    set_action:
      - lambda: "id(program_c_start_minute) = x;"

  - platform: template
    id: program_c_interval_input
    name: "Program C Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_c_interval_days);"
    set_action:
      - lambda: "id(program_c_interval_days) = x;"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SEASONAL ADJUSTMENT MULTIPLIERS (Whanganui - Southern Hemisphere)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    id: seasonal_jan_input
    name: "$dev1_what Seasonal Jan"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_jan);"
    set_action:
      - lambda: "id(seasonal_jan) = x;"

  - platform: template
    id: seasonal_feb_input
    name: "$dev1_what Seasonal Feb"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_feb);"
    set_action:
      - lambda: "id(seasonal_feb) = x;"

  - platform: template
    id: seasonal_mar_input
    name: "$dev1_what Seasonal Mar"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_mar);"
    set_action:
      - lambda: "id(seasonal_mar) = x;"

  - platform: template
    id: seasonal_apr_input
    name: "$dev1_what Seasonal Apr"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_apr);"
    set_action:
      - lambda: "id(seasonal_apr) = x;"

  - platform: template
    id: seasonal_may_input
    name: "$dev1_what Seasonal May"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_may);"
    set_action:
      - lambda: "id(seasonal_may) = x;"

  - platform: template
    id: seasonal_jun_input
    name: "$dev1_what Seasonal Jun"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_jun);"
    set_action:
      - lambda: "id(seasonal_jun) = x;"

  - platform: template
    id: seasonal_jul_input
    name: "$dev1_what Seasonal Jul"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_jul);"
    set_action:
      - lambda: "id(seasonal_jul) = x;"

  - platform: template
    id: seasonal_aug_input
    name: "$dev1_what Seasonal Aug"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_aug);"
    set_action:
      - lambda: "id(seasonal_aug) = x;"

  - platform: template
    id: seasonal_sep_input
    name: "$dev1_what Seasonal Sep"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_sep);"
    set_action:
      - lambda: "id(seasonal_sep) = x;"

  - platform: template
    id: seasonal_oct_input
    name: "$dev1_what Seasonal Oct"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_oct);"
    set_action:
      - lambda: "id(seasonal_oct) = x;"

  - platform: template
    id: seasonal_nov_input
    name: "$dev1_what Seasonal Nov"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_nov);"
    set_action:
      - lambda: "id(seasonal_nov) = x;"

  - platform: template
    id: seasonal_dec_input
    name: "$dev1_what Seasonal Dec"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_dec);"
    set_action:
      - lambda: "id(seasonal_dec) = x;"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PRODUCTION FEATURES - UI CONTROLS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Freeze Protection Threshold
  - platform: template
    id: freeze_threshold_input
    name: "$dev1_what Freeze Threshold"
    min_value: -5
    max_value: 10
    step: 0.5
    icon: "mdi:snowflake-thermometer"
    mode: box
    unit_of_measurement: "Â°C"
    lambda: "return id(freeze_threshold);"
    set_action:
      - lambda: |-
          id(freeze_threshold) = x;
          ESP_LOGI("irrigation", "â„ï¸ Freeze threshold set to %.1fÂ°C", x);
  
  # Monthly Water Budget
  - platform: template
    id: monthly_budget_input
    name: "$dev1_what Monthly Water Budget"
    min_value: 1000
    max_value: 50000
    step: 100
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L"
    lambda: "return id(monthly_water_budget);"
    set_action:
      - lambda: |-
          id(monthly_water_budget) = x;
          ESP_LOGI("irrigation", "ğŸ’° Monthly water budget set to %.0f L", x);
  
  # Zone Daily Runtime Limit
  - platform: template
    id: zone_runtime_limit_input
    name: "$dev1_what Zone Runtime Limit"
    min_value: 15
    max_value: 180
    step: 5
    icon: "mdi:timer-sand"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(max_zone_runtime_daily);"
    set_action:
      - lambda: |-
          id(max_zone_runtime_daily) = x;
          ESP_LOGI("irrigation", "â±ï¸ Zone daily runtime limit set to %.0f minutes", x);
  
  # Watering Window 1 - Start Hour
  - platform: template
    id: window1_start_input
    name: "$dev1_what Window 1 Start"
    min_value: 0
    max_value: 23
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(window1_start_hour);"
    set_action:
      - lambda: |-
          id(window1_start_hour) = x;
          ESP_LOGI("irrigation", "ğŸ• Window 1 start set to %d:00", (int)x);
  
  # Watering Window 1 - End Hour
  - platform: template
    id: window1_end_input
    name: "$dev1_what Window 1 End"
    min_value: 0
    max_value: 23
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(window1_end_hour);"
    set_action:
      - lambda: |-
          id(window1_end_hour) = x;
          ESP_LOGI("irrigation", "ğŸ• Window 1 end set to %d:00", (int)x);
  
  # Watering Window 2 - Start Hour
  - platform: template
    id: window2_start_input
    name: "$dev1_what Window 2 Start"
    min_value: 0
    max_value: 23
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(window2_start_hour);"
    set_action:
      - lambda: |-
          id(window2_start_hour) = x;
          ESP_LOGI("irrigation", "ğŸ• Window 2 start set to %d:00", (int)x);
  
  # Watering Window 2 - End Hour
  - platform: template
    id: window2_end_input
    name: "$dev1_what Window 2 End"
    min_value: 0
    max_value: 23
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(window2_end_hour);"
    set_action:
      - lambda: |-
          id(window2_end_hour) = x;
          ESP_LOGI("irrigation", "ğŸ• Window 2 end set to %d:00", (int)x);

script:
  # ============================================================
  # PREDICTIVE WATERINGâ„¢ SCRIPT
  # ============================================================
  - id: calculate_predictive_watering
    mode: single
    then:
      - lambda: |-
          if (!id(predictive_watering_enabled)) {
            ESP_LOGI("irrigation", "ğŸ’§ Predictive Wateringâ„¢ is DISABLED - skipping calculation");
            return;
          }
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ’§ PREDICTIVE WATERINGâ„¢ - Daily Calculation");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          // Get current weather data
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          float rain_mm = id(rain_probability).state;  // Now in mm, not %
          
          // Validate data
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "âš ï¸ Temperature unavailable, using 20Â°C");
            temp = 20.0;
          }
          if (isnan(humidity)) {
            ESP_LOGW("irrigation", "âš ï¸ Humidity unavailable, using 50%%");
            humidity = 50.0;
          }
          if (isnan(wind)) {
            ESP_LOGW("irrigation", "âš ï¸ Wind speed unavailable, using 10 km/h");
            wind = 10.0;
          }
          if (isnan(rain_mm) || rain_mm < 0) {
            ESP_LOGI("irrigation", "â„¹ï¸ Rain forecast not available - assuming 0mm (no rain forecast)");
            rain_mm = 0.0;
          }
          
          ESP_LOGI("irrigation", "ğŸ“Š Weather Conditions:");
          ESP_LOGI("irrigation", "   Temperature: %.1fÂ°C", temp);
          ESP_LOGI("irrigation", "   Humidity: %.0f%%", humidity);
          ESP_LOGI("irrigation", "   Wind Speed: %.1f km/h", wind);
          ESP_LOGI("irrigation", "   Rain Forecast: %.1f mm", rain_mm);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // TEMPERATURE FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float temp_factor = 1.0;
          if (temp < 10) {
            temp_factor = 0.3;  // Very cold - minimal watering
          } else if (temp < 15) {
            temp_factor = 0.5;  // Cool
          } else if (temp < 20) {
            temp_factor = 0.8;  // Mild
          } else if (temp < 25) {
            temp_factor = 1.0;  // Normal
          } else if (temp < 28) {
            temp_factor = 1.3;  // Warm
          } else if (temp < 32) {
            temp_factor = 1.6;  // Hot
          } else {
            temp_factor = 1.9;  // Very hot
          }
          id(pw_temperature_factor) = temp_factor;
          ESP_LOGI("irrigation", "ğŸŒ¡ï¸ Temperature Factor: %.2f", temp_factor);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // HUMIDITY FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float humidity_factor = 1.0;
          if (humidity < 30) {
            humidity_factor = 1.3;  // Very dry - more water needed
          } else if (humidity < 50) {
            humidity_factor = 1.15;  // Dry
          } else if (humidity < 70) {
            humidity_factor = 1.0;  // Normal
          } else if (humidity < 85) {
            humidity_factor = 0.85;  // Humid - less evaporation
          } else {
            humidity_factor = 0.7;  // Very humid
          }
          id(pw_humidity_factor) = humidity_factor;
          ESP_LOGI("irrigation", "ğŸ’¨ Humidity Factor: %.2f", humidity_factor);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // WIND FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float wind_factor = 1.0;
          if (wind < 10) {
            wind_factor = 1.0;  // Calm
          } else if (wind < 20) {
            wind_factor = 1.1;  // Light wind - slight increase in evaporation
          } else if (wind < 30) {
            wind_factor = 1.2;  // Moderate wind
          } else {
            wind_factor = 1.3;  // Strong wind - high evaporation
          }
          id(pw_wind_factor) = wind_factor;
          ESP_LOGI("irrigation", "ğŸŒ¬ï¸ Wind Factor: %.2f", wind_factor);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // RAIN FORECAST FACTOR (using actual precipitation mm)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // This is MORE ACCURATE than probability because we know actual amounts!
          // 0mm = 1.0 (no rain, normal watering)
          // 0.1-0.5mm = 0.9 (trace/light drizzle expected)
          // 0.5-1mm = 0.7 (light rain expected)
          // 1-2mm = 0.5 (light-moderate rain)
          // 2-5mm = 0.3 (moderate rain)
          // 5-10mm = 0.15 (heavy rain)
          // >10mm = 0.1 (very heavy rain)
          
          float rain_factor = 1.0;
          if (rain_mm > 10.0) {
            rain_factor = 0.1;  // Very heavy rain forecast - minimal watering
          } else if (rain_mm > 5.0) {
            rain_factor = 0.15;  // Heavy rain forecast
          } else if (rain_mm > 2.0) {
            rain_factor = 0.3;  // Moderate rain forecast
          } else if (rain_mm > 1.0) {
            rain_factor = 0.5;  // Light-moderate rain
          } else if (rain_mm > 0.5) {
            rain_factor = 0.7;  // Light rain forecast
          } else if (rain_mm > 0.1) {
            rain_factor = 0.9;  // Trace amounts/drizzle
          } else {
            rain_factor = 1.0;  // No rain forecast
          }
          id(pw_rain_factor) = rain_factor;
          ESP_LOGI("irrigation", "ğŸŒ§ï¸ Rain Factor: %.2f (%.1fmm forecast)", rain_factor, rain_mm);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SEASONAL ADJUSTMENT FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          auto time = id(homeassistant_time).now();
          float seasonal_factor = 1.0;
          if (time.is_valid()) {
            int month = time.month;
            switch (month) {
              case 1:  seasonal_factor = id(seasonal_jan); break;
              case 2:  seasonal_factor = id(seasonal_feb); break;
              case 3:  seasonal_factor = id(seasonal_mar); break;
              case 4:  seasonal_factor = id(seasonal_apr); break;
              case 5:  seasonal_factor = id(seasonal_may); break;
              case 6:  seasonal_factor = id(seasonal_jun); break;
              case 7:  seasonal_factor = id(seasonal_jul); break;
              case 8:  seasonal_factor = id(seasonal_aug); break;
              case 9:  seasonal_factor = id(seasonal_sep); break;
              case 10: seasonal_factor = id(seasonal_oct); break;
              case 11: seasonal_factor = id(seasonal_nov); break;
              case 12: seasonal_factor = id(seasonal_dec); break;
            }
          }
          ESP_LOGI("irrigation", "ğŸ“… Seasonal Factor: %.2f (month %d)", seasonal_factor, time.month);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SOIL TYPE ADJUSTMENT FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float soil_factor = 1.0;
          const char* soil_name = "Unknown";
          if (id(soil_type) == 0) {
            soil_factor = 1.15;  // Sand: drains fast
            soil_name = "Sand";
          } else if (id(soil_type) == 1) {
            soil_factor = 1.0;   // Loam: balanced
            soil_name = "Loam";
          } else if (id(soil_type) == 2) {
            soil_factor = 0.85;  // Clay: holds moisture
            soil_name = "Clay";
          }
          ESP_LOGI("irrigation", "ğŸŒ± Soil Factor: %.2f (%s)", soil_factor, soil_name);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CALCULATE FINAL MULTIPLIER
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float combined_multiplier = temp_factor * humidity_factor * wind_factor * rain_factor * seasonal_factor * soil_factor;
          
          // FIX: Log when multiplier is capped (production safety)
          float uncapped_multiplier = combined_multiplier;
          
          // Apply reasonable limits (0.1 to 2.0)
          if (combined_multiplier < 0.1) {
            ESP_LOGW("irrigation", "âš ï¸ MULTIPLIER CAPPED: %.4f â†’ 0.10 (below minimum)", combined_multiplier);
            ESP_LOGW("irrigation", "   Extreme conditions detected - verify weather sensors");
            combined_multiplier = 0.1;
          }
          if (combined_multiplier > 2.0) {
            ESP_LOGW("irrigation", "âš ï¸ MULTIPLIER CAPPED: %.2f â†’ 2.00 (above maximum)", combined_multiplier);
            ESP_LOGW("irrigation", "   Very hot/dry conditions - safety limit applied");
            combined_multiplier = 2.0;
          }
          
          id(pw_current_multiplier) = combined_multiplier;
          id(pw_last_calculation_time) = id(homeassistant_time).now().timestamp;
          
          // Save as fallback for network offline mode
          id(fallback_multiplier) = combined_multiplier;
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âœ… FINAL MULTIPLIER: %.2f%s", combined_multiplier,
                   (uncapped_multiplier != combined_multiplier) ? " (CAPPED)" : "");
          ESP_LOGI("irrigation", "   Weather: Temp:%.2f Hum:%.2f Wind:%.2f Rain:%.2f", 
                   temp_factor, humidity_factor, wind_factor, rain_factor);
          ESP_LOGI("irrigation", "   Season: %.2f | Soil: %.2f", seasonal_factor, soil_factor);
          if (uncapped_multiplier != combined_multiplier) {
            ESP_LOGI("irrigation", "   Uncapped: %.4f â†’ Capped: %.2f", uncapped_multiplier, combined_multiplier);
          }
          
          // Apply to sprinkler controller
          id($devicename1).set_multiplier(combined_multiplier);
          
          ESP_LOGI("irrigation", "ğŸ’§ Predictive Wateringâ„¢ multiplier applied to system");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  # ============================================================
  # RESTORE PREDICTIVE WATERING MULTIPLIER (after Smart ET)
  # ============================================================
  - id: restore_pw_multiplier
    mode: single
    then:
      - lambda: |-
          if (!id(smart_et_enabled)) {
            return;  // Only restore if Smart ET is enabled
          }
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”„ Restoring Predictive Watering multiplier...");
          
          // Reset ET multiplier
          id(et_duration_multiplier) = 1.0;
          
          // Restore Predictive Watering's weather-based multiplier
          float pw_mult = id(pw_current_multiplier);
          id($devicename1).set_multiplier(pw_mult);
          
          ESP_LOGI("irrigation", "   âœ… Multiplier restored to %.2fx (Predictive Watering)", pw_mult);
          ESP_LOGI("irrigation", "   â„¹ï¸ Smart ET watering complete");

  # ============================================================
  # SMART ET WATERING SCRIPT
  # ============================================================
  - id: calculate_smart_et
    mode: single
    then:
      - lambda: |-
          if (!id(smart_et_enabled)) {
            return;
          }
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸŒ± SMART ET WATERING - Daily Calculation");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          // Get weather data
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          
          // Validate
          if (isnan(temp)) temp = 20.0;
          if (isnan(humidity)) humidity = 50.0;
          if (isnan(wind)) wind = 10.0;
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CALCULATE REFERENCE ET (ET0) - Simplified Penman-Monteith
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // Temperature factor (base ET increases with temperature)
          float temp_et = 0.0;
          if (temp < 10) {
            temp_et = 1.0;
          } else if (temp < 15) {
            temp_et = 2.0;
          } else if (temp < 20) {
            temp_et = 3.5;
          } else if (temp < 25) {
            temp_et = 5.0;
          } else if (temp < 30) {
            temp_et = 6.5;
          } else {
            temp_et = 8.0;
          }
          
          // Humidity adjustment (dry air increases ET)
          float humidity_adj = 1.0;
          if (humidity < 30) {
            humidity_adj = 1.4;
          } else if (humidity < 50) {
            humidity_adj = 1.2;
          } else if (humidity < 70) {
            humidity_adj = 1.0;
          } else if (humidity < 85) {
            humidity_adj = 0.8;
          } else {
            humidity_adj = 0.6;
          }
          
          // Wind adjustment (wind increases ET)
          float wind_adj = 1.0;
          if (wind < 10) {
            wind_adj = 1.0;
          } else if (wind < 20) {
            wind_adj = 1.15;
          } else if (wind < 30) {
            wind_adj = 1.3;
          } else {
            wind_adj = 1.5;
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SOIL TYPE ADJUSTMENT
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float soil_adj = 1.0;
          if (id(soil_type) == 0) {
            soil_adj = 1.15;  // Sand: drains fast, needs more frequent watering
          } else if (id(soil_type) == 1) {
            soil_adj = 1.0;   // Loam: balanced
          } else if (id(soil_type) == 2) {
            soil_adj = 0.85;  // Clay: holds moisture longer
          }
          
          // Calculate daily ET in mm (with soil adjustment)
          float daily_et = temp_et * humidity_adj * wind_adj * soil_adj;
          id(et_daily_et) = daily_et;
          
          ESP_LOGI("irrigation", "ğŸ“Š ET Calculation:");
          ESP_LOGI("irrigation", "   Temperature ET: %.1f mm", temp_et);
          ESP_LOGI("irrigation", "   Humidity Adj: %.2fx", humidity_adj);
          ESP_LOGI("irrigation", "   Wind Adj: %.2fx", wind_adj);
          ESP_LOGI("irrigation", "   Soil Adj: %.2fx (Sand=1.15, Loam=1.0, Clay=0.85)", soil_adj);
          ESP_LOGI("irrigation", "   Daily ET: %.1f mm/day", daily_et);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CHECK FOR RAINFALL
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float rainfall = 0.0;
          
          // PRIORITY 1: Use actual precipitation forecast if available (most accurate!)
          float rain_forecast_mm = id(rain_probability).state;
          if (!isnan(rain_forecast_mm) && rain_forecast_mm >= 0) {
            rainfall = rain_forecast_mm;
            ESP_LOGI("irrigation", "ğŸŒ§ï¸ Using precipitation forecast: %.1f mm", rainfall);
          } else {
            // FALLBACK: Estimate from weather condition if forecast unavailable
            std::string weather = id(weather_forecast_home).state;
            
            if (weather == "pouring") {
              rainfall = 15.0;  // Heavy rain: 15mm
            } else if (weather == "rainy") {
              rainfall = 8.0;   // Rain: 8mm
            } else if (weather == "snowy-rainy") {
              rainfall = 5.0;   // Light rain: 5mm
            }
            
            if (rainfall > 0) {
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ Estimated rainfall from weather condition (%s): %.1f mm", weather.c_str(), rainfall);
            } else {
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ No rainfall expected (forecast unavailable, weather: %s)", weather.c_str());
            }
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // UPDATE SOIL MOISTURE DEFICIT
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float old_deficit = id(et_soil_moisture_deficit);
          
          // Add ET (water lost)
          id(et_soil_moisture_deficit) += daily_et;
          
          // Subtract rainfall (water gained)
          id(et_soil_moisture_deficit) -= rainfall;
          
          // Don't let deficit go negative (soil can't be oversaturated for our purposes)
          if (id(et_soil_moisture_deficit) < 0) {
            id(et_soil_moisture_deficit) = 0;
          }
          
          float new_deficit = id(et_soil_moisture_deficit);
          
          ESP_LOGI("irrigation", "ğŸ’§ Moisture Balance:");
          ESP_LOGI("irrigation", "   Previous Deficit: %.1f mm", old_deficit);
          ESP_LOGI("irrigation", "   + ET Lost: %.1f mm", daily_et);
          ESP_LOGI("irrigation", "   - Rainfall: %.1f mm", rainfall);
          ESP_LOGI("irrigation", "   = New Deficit: %.1f mm", new_deficit);
          ESP_LOGI("irrigation", "   Threshold: %.1f mm", id(et_water_threshold));
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CHECK IF IRRIGATION NEEDED
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (new_deficit >= id(et_water_threshold)) {
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸš¨ DEFICIT THRESHOLD REACHED!");
            ESP_LOGI("irrigation", "   Irrigation is NEEDED");
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CALCULATE SMART ET DURATION MULTIPLIER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Adjust watering duration based on deficit severity
            float threshold = id(et_water_threshold);
            float deficit_ratio = new_deficit / threshold;
            
            // Duration multiplier scales with how far over threshold we are
            // At threshold (1.0x): multiply by 1.0
            // 20% over (1.2x): multiply by 1.2
            // 50% over (1.5x): multiply by 1.5
            // Cap at 2.0x for safety
            float et_multiplier = deficit_ratio;
            if (et_multiplier > 2.0) et_multiplier = 2.0;
            if (et_multiplier < 1.0) et_multiplier = 1.0;
            
            id(et_duration_multiplier) = et_multiplier;
            
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ’§ Smart ET Duration Adjustment:");
            ESP_LOGI("irrigation", "   Deficit: %.1f mm (%.0f%% over threshold)", new_deficit, (deficit_ratio - 1.0) * 100);
            ESP_LOGI("irrigation", "   ET Multiplier: %.2fx", et_multiplier);
            
            // Calculate combined multiplier with Predictive Watering
            float pw_mult = id($devicename1).multiplier();
            float combined = pw_mult * et_multiplier;
            if (combined > 2.0) combined = 2.0;  // Safety cap
            
            ESP_LOGI("irrigation", "   Predictive Watering: %.2fx", pw_mult);
            ESP_LOGI("irrigation", "   Combined Multiplier: %.2fx", combined);
            ESP_LOGI("irrigation", "   (Example: 15min zone â†’ %.1f min)", 15.0 * combined);
            
            // Apply ET multiplier temporarily
            id($devicename1).set_multiplier(combined);
            
            // Check if system is enabled and not in rain delay
            if (!id(irrigation_system_enable).state) {
              ESP_LOGW("irrigation", "   âŒ System is DISABLED - cannot water");
              id(et_duration_multiplier) = 1.0;  // Reset multiplier
            } else if (id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
              ESP_LOGW("irrigation", "   âŒ Rain delay is ACTIVE - cannot water");
              id(et_duration_multiplier) = 1.0;  // Reset multiplier
            } else if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "   â° Time restricted - will water when allowed");
              id(et_pending_irrigation) = true;
            } else {
              // Check if current time matches Smart ET schedule
              auto time = id(homeassistant_time).now();
              int current_hour = time.hour;
              int current_minute = time.minute;
              
              // Convert schedule to 24-hour format
              int schedule_hour = id(et_schedule_hour);
              if (id(et_schedule_am_pm) == 1 && schedule_hour != 12) {
                schedule_hour += 12;  // PM conversion
              } else if (id(et_schedule_am_pm) == 0 && schedule_hour == 12) {
                schedule_hour = 0;  // Midnight conversion
              }
              
              // Check if we're within 5 minutes of scheduled time
              bool time_match = (current_hour == schedule_hour && abs(current_minute - id(et_schedule_minute)) < 5);
              
              if (time_match) {
                ESP_LOGI("irrigation", "");
                ESP_LOGI("irrigation", "   âœ… Starting irrigation cycle NOW (scheduled time)");
                id(et_pending_irrigation) = false;
                
                // Start all enabled zones (will use the combined multiplier)
                id(start_all_zones_cycle_soak).press();
                
                // Reset deficit after watering
                // Calculate actual water applied (assuming we filled the deficit)
                float water_applied = new_deficit * et_multiplier;
                ESP_LOGI("irrigation", "   Estimated water applied: %.1f mm", water_applied);
                
                id(et_soil_moisture_deficit) = 0;
                id(et_last_water_time) = id(homeassistant_time).now().timestamp;
              } else {
                ESP_LOGI("irrigation", "");
                ESP_LOGI("irrigation", "   â° Watering PENDING - waiting for scheduled time");
                ESP_LOGI("irrigation", "   Scheduled: %d:%02d %s", 
                         id(et_schedule_hour), 
                         id(et_schedule_minute),
                         id(et_schedule_am_pm) == 0 ? "AM" : "PM");
                ESP_LOGI("irrigation", "   Current: %d:%02d %s", 
                         current_hour > 12 ? current_hour - 12 : (current_hour == 0 ? 12 : current_hour),
                         current_minute,
                         current_hour >= 12 ? "PM" : "AM");
                id(et_pending_irrigation) = true;
              }
              
              // Note: Multiplier will be restored after watering completes
            }
          } else {
            ESP_LOGI("irrigation", "   âœ… Deficit below threshold - no watering needed");
            id(et_pending_irrigation) = false;
            id(et_duration_multiplier) = 1.0;  // Reset when not watering
          }
          
          id(et_last_calculation_time) = id(homeassistant_time).now().timestamp;
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  # Request NORMAL mode start: start now if idle, otherwise queue it (queued_type = 3)
  - id: request_normal_start
    mode: restart
    then:
      - lambda: |-
          bool valve_active = id($devicename1).active_valve().has_value();
          bool script_running =
              id(run_zone_with_cycles).is_running() ||
              id(run_program).is_running() ||
              id(run_all_zones_cycle_soak_script).is_running();
          bool soaking = id(cycle_soak_is_soaking);

          if (id(irrigation_busy) || valve_active || script_running || soaking) {
            // one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
            id(queued_type) = 3;  // queue/overwrite a pending normal run
            ESP_LOGI("irrigation", "Queued NORMAL start (will run when system is idle)");
            return;
          }

          ESP_LOGI("irrigation", "Starting NORMAL immediately");
      - sprinkler.start_full_cycle: $devicename1

  # Wait until system is truly idle, then drain queue
  - id: wait_until_idle_then_drain
    mode: restart
    then:
      - while:
          condition:
            lambda: |-
              bool valve_active = id($devicename1).active_valve().has_value();
              bool script_running =
                  id(run_zone_with_cycles).is_running() ||
                  id(run_program).is_running() ||
                  id(run_all_zones_cycle_soak_script).is_running();
              bool soaking = id(cycle_soak_is_soaking);

              // Keep waiting while anything is still active or stopping
              return valve_active || script_running || soaking || id(irrigation_busy);
          then:
            - delay: 250ms
      - script.execute: drain_queue

  # Drain queued items from 3-item queue (Hunter Pro-C style)
  - id: drain_queue
    mode: restart
    then:
      - lambda: |-
          // === 3-ITEM QUEUE DRAINING SYSTEM ===
          
          // Check if queue is empty
          if (id(queue_count) == 0) {
            ESP_LOGD("irrigation", "âœ… Queue empty (0/3 items)");
            return;
          }

          // Hold queue if system is paused
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ PAUSED - Holding queue (%d/%d items waiting)",
                     id(queue_count), 3);
            return;
          }

          // Check if system is truly idle
          const bool valve_active = id($devicename1).active_valve().has_value();
          const bool scripts_running =
              id(run_zone_with_cycles).is_running() ||
              id(run_program).is_running() ||
              id(run_all_zones_cycle_soak_script).is_running();
          const bool soaking = id(cycle_soak_is_soaking);

          if (valve_active || scripts_running || soaking || id(irrigation_busy)) {
            ESP_LOGI("irrigation", "â³ NOT IDLE - Queue waiting (%d/%d) | valve=%d script=%d soak=%d busy=%d",
                     id(queue_count), 3, valve_active, scripts_running, soaking, id(irrigation_busy));
            id(wait_until_idle_then_drain).execute();
            return;
          }

          // === DRAIN FIRST ITEM FROM QUEUE ===
          int type = id(queue_types)[0];
          int program = id(queue_programs)[0];
          int zone = id(queue_zones)[0];
          int duration = id(queue_durations)[0];
          bool add_delay = id(queue_add_delays)[0];
          
          // Build queue contents for logging
          std::string queue_contents = "";
          for (int i = 0; i < id(queue_count) && i < 3; i++) {
            if (i > 0) queue_contents += ", ";
            if (id(queue_types)[i] == 1) {
              queue_contents += "Prg";
              queue_contents += (char)('A' + id(queue_programs)[i] - 1);
            } else if (id(queue_types)[i] == 2) {
              queue_contents += "Z";
              queue_contents += std::to_string(id(queue_zones)[i] + 1);
            } else if (id(queue_types)[i] == 3) {
              queue_contents += "Weekly";
            }
          }
          
          ESP_LOGI("irrigation", "ğŸ“¤ DRAINING queue [%s] â†’ Starting item 1/%d",
                   queue_contents.c_str(), id(queue_count));
          
          // Shift queue forward (remove first item)
          for (int i = 0; i < 2; i++) {
            id(queue_types)[i] = id(queue_types)[i + 1];
            id(queue_programs)[i] = id(queue_programs)[i + 1];
            id(queue_zones)[i] = id(queue_zones)[i + 1];
            id(queue_durations)[i] = id(queue_durations)[i + 1];
            id(queue_add_delays)[i] = id(queue_add_delays)[i + 1];
          }
          
          // Clear last slot
          id(queue_types)[2] = 0;
          id(queue_programs)[2] = 0;
          id(queue_zones)[2] = 0;
          id(queue_durations)[2] = 0;
          id(queue_add_delays)[2] = false;
          
          id(queue_count)--;
          
          // Start the appropriate item type
          if (type == 1) {
            // PROGRAM
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Program %c | Queue now: %d/3 items",
                     'A' + program - 1, id(queue_count));
            id(irrigation_busy) = true;
            id(in_program_run) = true;
            id(run_program).execute(program);
            
          } else if (type == 2) {
            // ZONE
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Zone %d (%ds) | Queue now: %d/3 items",
                     zone + 1, duration, id(queue_count));
            id(irrigation_busy) = true;
            id(in_program_run) = false;
            id(run_zone_with_cycles).execute(zone, duration, add_delay, false);
            
          } else if (type == 3) {
            // FULL CYCLE (Weekly Schedule)
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Weekly Schedule (Full Cycle) | Queue now: %d/3 items",
                     id(queue_count));
            id(pending_normal_start) = true;
            id(normal_start_attempts) = 0;
            id(normal_last_attempt_ms) = 0;
          }

  # Run all zones in normal mode â€“ production safe
  - id: run_all_zones_normal_script
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              return id(stop_cooldown);
          then:
            - logger.log: "â³ Stop cooldown active â€” queueing Normal start"
            - lambda: |-
                // one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
                if (id(queued_type) == 0) {
                  id(queued_type) = 3;
                }
          else:
            - logger.log: "â•â•â• STARTING NORMAL MODE â•â•â•"

            - lambda: |-
                id(irrigation_busy) = true;
                id(in_program_run) = false;

            - sprinkler.start_full_cycle: $devicename1

            - logger.log: "âœ“ Normal mode started - sprinkler managing sequence"

# Request to start a program: manual blocked while busy; scheduled can queue.
  - id: request_program_start
    mode: queued
    parameters:
      program: int
      allow_queue: bool
    then:
      - lambda: |-
          // Check if paused
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ Program %c BLOCKED - system paused", 'A' + program - 1);
            return;
          }

          bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
          
          if (busy) {
            if (allow_queue) {
              // === 3-ITEM QUEUE SYSTEM ===
              if (id(queue_count) < 3) {
                int pos = id(queue_count);
                id(queue_types)[pos] = 1;  // 1 = Program
                id(queue_programs)[pos] = program;
                id(queue_zones)[pos] = 0;
                id(queue_durations)[pos] = 0;
                id(queue_add_delays)[pos] = false;
                id(queue_count)++;
                
                // Build queue status for logging
                std::string q_status = "";
                for (int i = 0; i < id(queue_count); i++) {
                  if (i > 0) q_status += ", ";
                  if (id(queue_types)[i] == 1) q_status += "Prg" + std::string(1, 'A' + id(queue_programs)[i] - 1);
                  else if (id(queue_types)[i] == 2) q_status += "Z" + std::to_string(id(queue_zones)[i] + 1);
                  else if (id(queue_types)[i] == 3) q_status += "Weekly";
                }
                
                ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Program %c â†’ Slot %d/3 | Queue: [%s]",
                         'A' + program - 1, pos + 1, q_status.c_str());
              } else {
                ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Program %c will NOT run!", 'A' + program - 1);
              }
            } else {
              ESP_LOGW("irrigation", "ğŸš« BUSY - Manual Program %c blocked", 'A' + program - 1);
            }
            return;
          }
          
          // System is idle - start immediately
          ESP_LOGI("irrigation", "â–¶ï¸ STARTING Program %c immediately (system idle)", 'A' + program - 1);
          id(irrigation_busy) = true;
          id(in_program_run) = true;
          id(run_program).execute(program);

  # Request to start a zone: manual blocked while busy; scheduled can queue.
  - id: request_zone_start
    mode: queued
    parameters:
      zone: int
      duration: int
      add_delay: bool
      allow_queue: bool
    then:
      - lambda: |-
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // PRODUCTION FEATURE CHECKS
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // 1. FREEZE PROTECTION CHECK
          if (id(freeze_protection_active)) {
            ESP_LOGW("irrigation", "â„ï¸ Zone %d BLOCKED - Freeze protection active (temp: %.1fÂ°C)", 
                     zone + 1, id(outside_temperature).state);
            return;
          }
          
          // 2. WATER BUDGET CHECK
          if (id(budget_exceeded) && !id(budget_override_active)) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d BLOCKED - Monthly water budget exceeded (%.1fL / %.1fL)",
                     zone + 1, id(current_month_usage), id(monthly_water_budget));
            ESP_LOGW("irrigation", "   Activate budget override to force watering");
            return;
          }
          
          // 3. ZONE DAILY RUNTIME LIMIT CHECK
          int zone_runtime = 0;
          switch(zone) {
            case 0: zone_runtime = id(zone1_runtime_today); break;
            case 1: zone_runtime = id(zone2_runtime_today); break;
            case 2: zone_runtime = id(zone3_runtime_today); break;
            case 3: zone_runtime = id(zone4_runtime_today); break;
            case 4: zone_runtime = id(zone5_runtime_today); break;
            case 5: zone_runtime = id(zone6_runtime_today); break;
            case 6: zone_runtime = id(zone7_runtime_today); break;
            case 7: zone_runtime = id(zone8_runtime_today); break;
          }
          
          int max_runtime_seconds = id(max_zone_runtime_daily) * 60;
          int proposed_runtime = duration;
          
          if ((zone_runtime + proposed_runtime) > max_runtime_seconds) {
            int remaining = max_runtime_seconds - zone_runtime;
            ESP_LOGW("irrigation", "â±ï¸ Zone %d BLOCKED - Daily runtime limit (%.1f min used, %.1f min limit)",
                     zone + 1, zone_runtime / 60.0, id(max_zone_runtime_daily));
            if (remaining > 0) {
              ESP_LOGW("irrigation", "   Only %.1f minutes remaining today", remaining / 60.0);
            } else {
              ESP_LOGW("irrigation", "   Limit already exceeded today");
            }
            return;
          }
          
          // 4. WATERING WINDOW ENFORCEMENT (for scheduled runs)
          if (allow_queue) {  // Scheduled/program runs only
            auto time = id(homeassistant_time).now();
            if (time.is_valid()) {
              int hour = time.hour;
              bool in_window = false;
              
              // Check window 1
              if (id(window1_enabled)) {
                int start = id(window1_start_hour);
                int end = id(window1_end_hour);
                if (start <= hour && hour < end) {
                  in_window = true;
                }
              }
              
              // Check window 2
              if (id(window2_enabled)) {
                int start = id(window2_start_hour);
                int end = id(window2_end_hour);
                if (start <= hour && hour < end) {
                  in_window = true;
                }
              }
              
              // If both windows disabled, allow anytime
              if (!id(window1_enabled) && !id(window2_enabled)) {
                in_window = true;
              }
              
              if (!in_window) {
                ESP_LOGW("irrigation", "ğŸ• Zone %d BLOCKED - Outside watering windows (current: %d:00)", zone + 1, hour);
                ESP_LOGW("irrigation", "   Window 1: %s (%d:00-%d:00)", 
                         id(window1_enabled) ? "ENABLED" : "disabled",
                         id(window1_start_hour), id(window1_end_hour));
                ESP_LOGW("irrigation", "   Window 2: %s (%d:00-%d:00)",
                         id(window2_enabled) ? "ENABLED" : "disabled", 
                         id(window2_start_hour), id(window2_end_hour));
                return;
              }
            }
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // STANDARD CHECKS
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // CRITICAL: Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d BLOCKED - Irrigation system is DISABLED", zone + 1);
            return;
          }
          
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ Paused - cannot start Zone %d", zone + 1);
            return;
          }

          // CRITICAL: Check if zone is enabled
          bool zone_enabled = false;
          switch(zone) {
            case 0: zone_enabled = id(zone1_enable).state; break;
            case 1: zone_enabled = id(zone2_enable).state; break;
            case 2: zone_enabled = id(zone3_enable).state; break;
            case 3: zone_enabled = id(zone4_enable).state; break;
            case 4: zone_enabled = id(zone5_enable).state; break;
            case 5: zone_enabled = id(zone6_enable).state; break;
            case 6: zone_enabled = id(zone7_enable).state; break;
            case 7: zone_enabled = id(zone8_enable).state; break;
          }
          if (!zone_enabled) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d is DISABLED - will not run", zone + 1);
            return;
          }
          ESP_LOGI("irrigation", "âœ“ Zone %d is ENABLED - proceeding", zone + 1);

          // CRITICAL: Check weather for ALL zone requests (unless override active)
          if (!id(manual_weather_override)) {
            std::string weather = id(weather_forecast_home).state;
            if (!weather.empty() && weather != "unknown" && weather != "unavailable") {
              if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone %d BLOCKED - Bad weather: %s (Enable Weather Override to force)", 
                         zone + 1, weather.c_str());
                return;
              }
            }
            ESP_LOGI("irrigation", "â˜€ï¸ Weather check PASSED for Zone %d", zone + 1);
          } else {
            ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Skipping weather check for Zone %d", zone + 1);
          }

          // CRITICAL: Check time restriction (for manual runs only)
          if (!allow_queue) {
            if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "â° Zone %d blocked - time restriction active", zone + 1);
              return;
            }
            ESP_LOGI("irrigation", "âœ“ Time restriction check PASSED for Zone %d", zone + 1);
          }

          if (id(irrigation_busy) || id($devicename1).active_valve().has_value()) {
            if (allow_queue) {
              // 3-item queue
              if (id(queue_count) < 3) {
                int pos = id(queue_count);
                id(queue_types)[pos] = 2;  // 2 = Zone
                id(queue_programs)[pos] = 0;
                id(queue_zones)[pos] = zone;
                id(queue_durations)[pos] = duration;
                id(queue_add_delays)[pos] = add_delay;
                id(queue_count)++;
                ESP_LOGI("irrigation", "ğŸ“‹ Queued Zone %d in slot %d/3 (%d items queued)",
                         zone + 1, pos + 1, id(queue_count));
              } else {
                // QUEUE OVERFLOW HANDLING (FIXED)
                ESP_LOGE("irrigation", "ğŸš« â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGE("irrigation", "ğŸš« QUEUE OVERFLOW - Zone %d DROPPED!", zone + 1);
                ESP_LOGE("irrigation", "ğŸš« â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGE("irrigation", "ğŸš« Queue is full (3/3 slots occupied)");
                ESP_LOGE("irrigation", "ğŸš« Current queue:");
                for (int i = 0; i < 3; i++) {
                  if (id(queue_types)[i] == 1) {
                    ESP_LOGE("irrigation", "ğŸš«   Slot %d: Program %c", i + 1, 'A' + id(queue_programs)[i] - 1);
                  } else if (id(queue_types)[i] == 2) {
                    ESP_LOGE("irrigation", "ğŸš«   Slot %d: Zone %d", i + 1, id(queue_zones)[i] + 1);
                  }
                }
                ESP_LOGE("irrigation", "ğŸš« â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              }
            } else {
              ESP_LOGW("irrigation", "ğŸš« Busy - manual Zone %d start blocked", zone + 1);
            }
            return;
          }

          ESP_LOGI("irrigation", "â–¶ï¸ Starting Zone %d immediately (system idle)", zone + 1);
          ESP_LOGI("irrigation", "   âœ… All safety checks passed");
          id(irrigation_busy) = true;
          id(in_program_run) = false;
          id(run_zone_with_cycles).execute(zone, duration, add_delay, false);

  # Handle cycle & soak for a zone with station delay
  - id: run_zone_with_cycles
    mode: single  # CRITICAL: Must be 'single' not 'restart' to prevent soak interruption
    parameters:
      zone: int
      duration: int
      add_delay: bool
      force_normal: bool
    then:
      - lambda: |-
          ESP_LOGI("irrigation", "ğŸš€ run_zone_with_cycles STARTED - mode should be SINGLE (not restart)");
          id(irrigation_busy) = true;
          
          // Get custom zone name
          std::string zone_name = "Zone " + std::to_string(zone + 1);
          switch(zone) {
            case 0: zone_name = id(zone1_name).state; break;
            case 1: zone_name = id(zone2_name).state; break;
            case 2: zone_name = id(zone3_name).state; break;
            case 3: zone_name = id(zone4_name).state; break;
            case 4: zone_name = id(zone5_name).state; break;
            case 5: zone_name = id(zone6_name).state; break;
            case 6: zone_name = id(zone7_name).state; break;
            case 7: zone_name = id(zone8_name).state; break;
          }
          
          // Get multiplier first
          float multiplier = id($devicename1).multiplier();
          
          ESP_LOGI("irrigation", "ğŸŒŠ %s (Zone %d) START | Mode: %s | Duration: %ds | Multiplier: %.2f",
                   zone_name.c_str(), zone + 1,
                   (force_normal || !id(cycle_soak_switch).state) ? "NORMAL" : "CYCLE&SOAK",
                   duration, multiplier);
          
          if (force_normal || !id(cycle_soak_switch).state) {
            // NORMAL MODE
            int adjusted_duration = (int)(duration * multiplier);
            
            ESP_LOGI("irrigation", "==> NORMAL MODE - running %d seconds (base=%d, multiplier=%.2f)",
                     adjusted_duration, duration, multiplier);
            
            id(cycle_soak_total_duration) = 0;
            id(cycle_soak_elapsed_time) = 0;
            id(active_zone_number) = -1;
            id(total_cycles) = 0;
            id(current_cycle) = 0;
            
            // CRITICAL: Final zone enable check before relay activation
            bool zone_enabled_now = false;
            switch(zone) {
              case 0: zone_enabled_now = id(zone1_enable).state; break;
              case 1: zone_enabled_now = id(zone2_enable).state; break;
              case 2: zone_enabled_now = id(zone3_enable).state; break;
              case 3: zone_enabled_now = id(zone4_enable).state; break;
              case 4: zone_enabled_now = id(zone5_enable).state; break;
              case 5: zone_enabled_now = id(zone6_enable).state; break;
              case 6: zone_enabled_now = id(zone7_enable).state; break;
              case 7: zone_enabled_now = id(zone8_enable).state; break;
            }
            
            if (!zone_enabled_now) {
              ESP_LOGW("irrigation", "ğŸš« RELAY BLOCKED: Zone %d disabled at activation", zone + 1);
              id(irrigation_busy) = false;
              return;
            }
            
            ESP_LOGI("irrigation", "âœ… Zone %d relay activation allowed", zone + 1);
            
            // Start valve
            id($devicename1).start_single_valve(zone, adjusted_duration);
            
          } else {
            // CYCLE & SOAK MODE (no multiplier applied)
            int cycle_seconds = id(cycle_duration_minutes) * 60;
            int soak_seconds = id(soak_duration_minutes) * 60;
            int total_duration = duration;  // Use base duration without multiplier
            int cycles = (total_duration + cycle_seconds - 1) / cycle_seconds;
            int total_time = (cycles * cycle_seconds) + ((cycles - 1) * soak_seconds);
            
            ESP_LOGI("irrigation", "==> CYCLE & SOAK MODE - %d cycles of %d sec (NO multiplier) + %d sec soak",
                     cycles, cycle_seconds, soak_seconds);
            
            id(cycle_soak_total_duration) = total_time;
            id(cycle_soak_elapsed_time) = 0;
            id(active_zone_number) = zone;
            id(total_cycles) = cycles;
            id(current_cycle) = 1;
          }
      
      # NORMAL MODE EXECUTION
      - if:
          condition:
            lambda: 'return force_normal || !id(cycle_soak_switch).state;'
          then:
            - lambda: |-
                int wait_time = (int)(duration * id($devicename1).multiplier());
                ESP_LOGI("irrigation", "Waiting %d seconds for normal mode to complete...", wait_time);
            - delay: !lambda 'return (int)(duration * id($devicename1).multiplier() + 3) * 1000;'
            - lambda: |-
                ESP_LOGI("irrigation", "Zone %d COMPLETE (normal mode)", zone);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // TRACK WATER USAGE
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                float actual_duration_min = (duration * id($devicename1).multiplier()) / 60.0;
                float flow_rate = 0.0;
                float water_used = 0.0;
                
                // Get flow rate for this zone
                switch(zone) {
                  case 0: flow_rate = id(zone1_flow_rate); break;
                  case 1: flow_rate = id(zone2_flow_rate); break;
                  case 2: flow_rate = id(zone3_flow_rate); break;
                  case 3: flow_rate = id(zone4_flow_rate); break;
                  case 4: flow_rate = id(zone5_flow_rate); break;
                  case 5: flow_rate = id(zone6_flow_rate); break;
                  case 6: flow_rate = id(zone7_flow_rate); break;
                  case 7: flow_rate = id(zone8_flow_rate); break;
                }
                
                // Calculate water used (flow_rate L/min Ã— duration min)
                water_used = flow_rate * actual_duration_min;
                
                // Update zone water usage
                switch(zone) {
                  case 0: id(zone1_water_used) += water_used; break;
                  case 1: id(zone2_water_used) += water_used; break;
                  case 2: id(zone3_water_used) += water_used; break;
                  case 3: id(zone4_water_used) += water_used; break;
                  case 4: id(zone5_water_used) += water_used; break;
                  case 5: id(zone6_water_used) += water_used; break;
                  case 6: id(zone7_water_used) += water_used; break;
                  case 7: id(zone8_water_used) += water_used; break;
                }
                
                // Update total system water usage
                id(total_water_used) += water_used;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PRODUCTION FEATURES: Track runtime and budget
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Calculate actual runtime in seconds (duration already includes multiplier)
                int runtime_seconds = (int)(actual_duration_min * 60);
                
                // Update zone runtime today (for daily limits)
                switch(zone) {
                  case 0: id(zone1_runtime_today) += runtime_seconds; break;
                  case 1: id(zone2_runtime_today) += runtime_seconds; break;
                  case 2: id(zone3_runtime_today) += runtime_seconds; break;
                  case 3: id(zone4_runtime_today) += runtime_seconds; break;
                  case 4: id(zone5_runtime_today) += runtime_seconds; break;
                  case 5: id(zone6_runtime_today) += runtime_seconds; break;
                  case 6: id(zone7_runtime_today) += runtime_seconds; break;
                  case 7: id(zone8_runtime_today) += runtime_seconds; break;
                }
                
                // Update monthly water budget
                id(current_month_usage) += water_used;
                
                // Update last watering timestamp (for idle detection)
                id(last_watering_timestamp) = id(homeassistant_time).now().timestamp;
                
                // Get custom zone name
                std::string zone_name = "Zone " + std::to_string(zone + 1);
                switch(zone) {
                  case 0: zone_name = id(zone1_name).state; break;
                  case 1: zone_name = id(zone2_name).state; break;
                  case 2: zone_name = id(zone3_name).state; break;
                  case 3: zone_name = id(zone4_name).state; break;
                  case 4: zone_name = id(zone5_name).state; break;
                  case 5: zone_name = id(zone6_name).state; break;
                  case 6: zone_name = id(zone7_name).state; break;
                  case 7: zone_name = id(zone8_name).state; break;
                }
                
                ESP_LOGI("irrigation", "ğŸ’§ WATER USED - %s (Zone %d): %.1f L (%.1f min Ã— %.1f L/min) | System Total: %.1f L",
                         zone_name.c_str(), zone + 1, water_used, actual_duration_min, flow_rate, id(total_water_used));
                ESP_LOGI("irrigation", "ğŸ“Š Runtime today: %.1f min | Budget used: %.1f / %.1f L (%.1f%%)",
                         (zone == 0 ? id(zone1_runtime_today) :
                          zone == 1 ? id(zone2_runtime_today) :
                          zone == 2 ? id(zone3_runtime_today) :
                          zone == 3 ? id(zone4_runtime_today) :
                          zone == 4 ? id(zone5_runtime_today) :
                          zone == 5 ? id(zone6_runtime_today) :
                          zone == 6 ? id(zone7_runtime_today) :
                          id(zone8_runtime_today)) / 60.0,
                         id(current_month_usage), id(monthly_water_budget),
                         (id(current_month_usage) / id(monthly_water_budget)) * 100.0);
                
                if (!id(in_program_run)) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
      
      # CYCLE & SOAK MODE EXECUTION
      - if:
          condition:
            lambda: 'return !force_normal && id(cycle_soak_switch).state;'
          then:
            # Run first cycle (no multiplier in soak mode)
            - sprinkler.start_single_valve:
                id: $devicename1
                valve_number: !lambda "return zone;"
                run_duration: !lambda "return id(cycle_duration_minutes) * 60;"
            - delay: !lambda "return (id(cycle_duration_minutes) * 60 + 2) * 1000;"
            
            # Repeat remaining cycles
            - repeat:
                count: !lambda "return id(total_cycles) - 1;"
                then:
                  # Soak period
                  - lambda: |-
                      id(cycle_soak_is_soaking) = true;
                      int soak_min = id(soak_duration_minutes);
                      int soak_sec = soak_min * 60;
                      int soak_ms = soak_sec * 1000;
                      id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_sec;
                      ESP_LOGI("irrigation", "ğŸŒ§ï¸ SOAK START: soak_duration_minutes=%d, seconds=%d, milliseconds=%d",
                               soak_min, soak_sec, soak_ms);
                      ESP_LOGI("irrigation", "    Delay will be: %d ms (should be 600000 for 10 min)", soak_ms);
                  - delay: !lambda "return id(soak_duration_minutes) * 60 * 1000;"
                  - lambda: |-
                      ESP_LOGI("irrigation", "âœ… SOAK DELAY COMPLETED!");
                      id(cycle_soak_is_soaking) = false;
                      id(cycle_soak_soak_end_time) = 0;
                      id(current_cycle)++;
                      ESP_LOGI("irrigation", "âœ… SOAK COMPLETE! Starting cycle %d of %d",
                               id(current_cycle), id(total_cycles));
                  
                  # Next cycle (no multiplier in soak mode)
                  - sprinkler.start_single_valve:
                      id: $devicename1
                      valve_number: !lambda "return zone;"
                      run_duration: !lambda "return id(cycle_duration_minutes) * 60;"
                  - delay: !lambda "return (id(cycle_duration_minutes) * 60 + 2) * 1000;"
            
            # Cleanup
            - lambda: |-
                ESP_LOGI("irrigation", "Zone %d COMPLETE (cycle & soak)", zone);
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // TRACK WATER USAGE
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // In cycle & soak mode, total time = cycles Ã— cycle_duration (no multiplier)
                float actual_duration_min = (id(total_cycles) * id(cycle_duration_minutes));
                float flow_rate = 0.0;
                float water_used = 0.0;
                
                // Get flow rate for this zone
                switch(zone) {
                  case 0: flow_rate = id(zone1_flow_rate); break;
                  case 1: flow_rate = id(zone2_flow_rate); break;
                  case 2: flow_rate = id(zone3_flow_rate); break;
                  case 3: flow_rate = id(zone4_flow_rate); break;
                  case 4: flow_rate = id(zone5_flow_rate); break;
                  case 5: flow_rate = id(zone6_flow_rate); break;
                  case 6: flow_rate = id(zone7_flow_rate); break;
                  case 7: flow_rate = id(zone8_flow_rate); break;
                }
                
                // Calculate water used (flow_rate L/min Ã— duration min)
                water_used = flow_rate * actual_duration_min;
                
                // Update zone water usage
                switch(zone) {
                  case 0: id(zone1_water_used) += water_used; break;
                  case 1: id(zone2_water_used) += water_used; break;
                  case 2: id(zone3_water_used) += water_used; break;
                  case 3: id(zone4_water_used) += water_used; break;
                  case 4: id(zone5_water_used) += water_used; break;
                  case 5: id(zone6_water_used) += water_used; break;
                  case 6: id(zone7_water_used) += water_used; break;
                  case 7: id(zone8_water_used) += water_used; break;
                }
                
                // Update total system water usage
                id(total_water_used) += water_used;
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // PRODUCTION FEATURES: Track runtime and budget
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                // Calculate actual runtime (cycles * cycle_duration, excluding soak time)
                int actual_runtime_sec = id(total_cycles) * id(cycle_duration_minutes) * 60;
                
                // Update zone runtime today (for daily limits)
                switch(zone) {
                  case 0: id(zone1_runtime_today) += actual_runtime_sec; break;
                  case 1: id(zone2_runtime_today) += actual_runtime_sec; break;
                  case 2: id(zone3_runtime_today) += actual_runtime_sec; break;
                  case 3: id(zone4_runtime_today) += actual_runtime_sec; break;
                  case 4: id(zone5_runtime_today) += actual_runtime_sec; break;
                  case 5: id(zone6_runtime_today) += actual_runtime_sec; break;
                  case 6: id(zone7_runtime_today) += actual_runtime_sec; break;
                  case 7: id(zone8_runtime_today) += actual_runtime_sec; break;
                }
                
                // Update monthly water budget
                id(current_month_usage) += water_used;
                
                // Update last watering timestamp (for idle detection)
                id(last_watering_timestamp) = id(homeassistant_time).now().timestamp;
                
                // Get custom zone name
                std::string zone_name = "Zone " + std::to_string(zone + 1);
                switch(zone) {
                  case 0: zone_name = id(zone1_name).state; break;
                  case 1: zone_name = id(zone2_name).state; break;
                  case 2: zone_name = id(zone3_name).state; break;
                  case 3: zone_name = id(zone4_name).state; break;
                  case 4: zone_name = id(zone5_name).state; break;
                  case 5: zone_name = id(zone6_name).state; break;
                  case 6: zone_name = id(zone7_name).state; break;
                  case 7: zone_name = id(zone8_name).state; break;
                }
                
                ESP_LOGI("irrigation", "ğŸ’§ WATER USED - %s (Zone %d): %.1f L (%d cycles Ã— %d min Ã— %.1f L/min) | System Total: %.1f L",
                         zone_name.c_str(), zone + 1, water_used, id(total_cycles), id(cycle_duration_minutes), flow_rate, id(total_water_used));
                ESP_LOGI("irrigation", "ğŸ“Š Runtime today: %.1f min | Budget used: %.1f / %.1f L (%.1f%%)",
                         (zone == 0 ? id(zone1_runtime_today) :
                          zone == 1 ? id(zone2_runtime_today) :
                          zone == 2 ? id(zone3_runtime_today) :
                          zone == 3 ? id(zone4_runtime_today) :
                          zone == 4 ? id(zone5_runtime_today) :
                          zone == 5 ? id(zone6_runtime_today) :
                          zone == 6 ? id(zone7_runtime_today) :
                          id(zone8_runtime_today)) / 60.0,
                         id(current_month_usage), id(monthly_water_budget),
                         (id(current_month_usage) / id(monthly_water_budget)) * 100.0);
                
                if (!id(in_program_run)) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
                id(active_zone_number) = -1;
                id(current_cycle) = 0;
                id(total_cycles) = 0;
                id(cycle_soak_total_duration) = 0;
                id(cycle_soak_elapsed_time) = 0;
      
      # Station delay
      - if:
          condition:
            lambda: "return add_delay;"
          then:
            - lambda: |-
                ESP_LOGI("irrigation", "Station delay: %d seconds", id(station_delay_seconds));
            - delay: !lambda "return id(station_delay_seconds) * 1000;"
            
            # Reset after all cycles
            - lambda: |-
                ESP_LOGI("irrigation", "Zone %d complete (cycle & soak)", zone);
                if (!id(in_program_run)) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
                id(active_zone_number) = -1;
                id(current_cycle) = 0;
                id(total_cycles) = 0;
                id(cycle_soak_total_duration) = 0;
                id(cycle_soak_elapsed_time) = 0;
      
      # Add station delay if requested
      - if:
          condition:
            lambda: "return add_delay;"
          then:
            - lambda: |-
                ESP_LOGI("irrigation", "Station delay: %d seconds", id(station_delay_seconds));
            - delay: !lambda "return id(station_delay_seconds) * 1000;"

  # Continue cycle & soak after a Pause/Resume
  - id: continue_cycle_soak_after_resume
    mode: restart
    parameters:
      zone: int
      start_cycle: int
      total: int
      was_soaking: bool
      soak_remaining: int
      water_remaining: int
    then:
      # If we paused while watering, wait for the resumed watering to finish
      - if:
          condition:
            lambda: 'return !was_soaking && water_remaining > 0;'
          then:
            - delay: !lambda 'return (water_remaining + 2) * 1000;'

      # If we paused while soaking, finish the remaining soak first
      - if:
          condition:
            lambda: 'return was_soaking && soak_remaining > 0;'
          then:
            - lambda: |-
                id(cycle_soak_is_soaking) = true;
                id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_remaining;
                ESP_LOGI("irrigation", "Resuming soak for %d seconds", soak_remaining);
            - delay: !lambda 'return soak_remaining * 1000;'
            - lambda: |-
                id(cycle_soak_is_soaking) = false;
                id(cycle_soak_soak_end_time) = 0;
                // move to next cycle after soak
                id(current_cycle)++;

      # Run remaining cycles
      - while:
          condition:
            lambda: 'return id(current_cycle) < total;'
          then:
            - lambda: |-
                // soak between cycles
                id(cycle_soak_is_soaking) = true;
                int soak_s = id(soak_duration_minutes) * 60;
                id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_s;
                ESP_LOGI("irrigation", "Soaking for %d seconds", soak_s);
            - delay: !lambda 'return id(soak_duration_minutes) * 60 * 1000;'
            - lambda: |-
                id(cycle_soak_is_soaking) = false;
                id(cycle_soak_soak_end_time) = 0;
                id(current_cycle)++;
                ESP_LOGI("irrigation", "Starting cycle %d of %d after resume", id(current_cycle), total);
            - sprinkler.start_single_valve:
                id: $devicename1
                valve_number: !lambda 'return zone;'
                run_duration: !lambda 'return id(cycle_duration_minutes) * 60;'
            - delay: !lambda 'return (id(cycle_duration_minutes) * 60 + 2) * 1000;'

      - lambda: |-
          // Cleanup cycle/soak state
          id(active_zone_number) = -1;
          id(current_cycle) = 0;
          id(total_cycles) = 0;
          id(cycle_soak_total_duration) = 0;
          id(cycle_soak_elapsed_time) = 0;
          id(cycle_soak_is_soaking) = false;
          id(cycle_soak_soak_end_time) = 0;
          id(paused_zone) = -1;
          id(paused_cycle) = 0;
          id(time_remaining_when_paused) = 0;
          id(paused_was_soaking) = false;
          id(paused_soak_remaining_seconds) = 0;
          id(paused_total_cycles) = 0;
          id(paused_cycle_soak_total_duration) = 0;
          id(paused_cycle_soak_elapsed_time) = 0;
          // Restore Auto Advance
          id(dev1_auto_advance).turn_on();
          ESP_LOGI("irrigation", "Auto Advance restored - Cycle & Soak resume complete");

  # Run all zones in cycle & soak mode
  - id: run_all_zones_cycle_soak_script
    mode: single
    then:
      - logger.log: "Starting all enabled zones - Cycle & Soak mode"
      
      # Turn off Auto Advance for cycle & soak
      - switch.turn_off: dev1_auto_advance
      - logger.log: "Auto Advance OFF for Cycle & Soak"
      
      # Set busy flags
      - lambda: |-
          id(irrigation_busy) = true;
          id(in_program_run) = false;
      
      # Zone 1
      - if:
          condition:
            switch.is_on: zone1_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 0
                duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 2
      - if:
          condition:
            switch.is_on: zone2_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 1
                duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 3
      - if:
          condition:
            switch.is_on: zone3_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 2
                duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 4
      - if:
          condition:
            switch.is_on: zone4_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 3
                duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 5
      - if:
          condition:
            switch.is_on: zone5_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 4
                duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 6
      - if:
          condition:
            switch.is_on: zone6_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 5
                duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 7
      - if:
          condition:
            switch.is_on: zone7_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 6
                duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 8
      - if:
          condition:
            switch.is_on: zone8_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 7
                duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                add_delay: false
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - logger.log: "All enabled zones complete"
      
      # Clear busy flag
      - lambda: |-
          id(irrigation_busy) = false;
          id(in_program_run) = false;
      
      # Reset valve status to Idle
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - logger.log: "Valve status reset to Idle"
      
      # Restore Auto Advance after completion
      - delay: 500ms
      - switch.turn_on: dev1_auto_advance
      - logger.log: "Auto Advance restored to ON"
      
      # Drain queue
      - delay: 100ms
      - script.execute: drain_queue

  # Run a specific program
  - id: run_program
    mode: single
    parameters:
      program: int  # 1=A, 2=B, 3=C
    then:
      - lambda: |-
          id(irrigation_busy) = true;
          id(in_program_run) = true;

      - lambda: |-
          // CRITICAL: Check weather before starting program
          std::string weather = id(weather_forecast_home).state;
          if (!weather.empty() && weather != "unknown" && weather != "unavailable") {
            if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
              ESP_LOGW("irrigation", "â›ˆï¸ Program %c BLOCKED - bad weather: %s", 'A' + program - 1, weather.c_str());
              id(irrigation_busy) = false;
              id(in_program_run) = false;
              return;
            }
          }
          ESP_LOGI("irrigation", "â˜€ï¸ Weather check PASSED - Program %c starting", 'A' + program - 1);
          
          ESP_LOGI("irrigation", "ğŸ¯ PROGRAM %c STARTING | Checking zone assignments...", 'A' + program - 1);
      
      # Build list of zones for this program
      - lambda: |-
          std::vector<int> zones_to_run;
          
          // Check which zones belong to this program
          if (id(zone1_program) == program && id(zone1_enable).state) zones_to_run.push_back(0);
          if (id(zone2_program) == program && id(zone2_enable).state) zones_to_run.push_back(1);
          if (id(zone3_program) == program && id(zone3_enable).state) zones_to_run.push_back(2);
          if (id(zone4_program) == program && id(zone4_enable).state) zones_to_run.push_back(3);
          if (id(zone5_program) == program && id(zone5_enable).state) zones_to_run.push_back(4);
          if (id(zone6_program) == program && id(zone6_enable).state) zones_to_run.push_back(5);
          if (id(zone7_program) == program && id(zone7_enable).state) zones_to_run.push_back(6);
          if (id(zone8_program) == program && id(zone8_enable).state) zones_to_run.push_back(7);
          
          ESP_LOGI("irrigation", "Program %c has %d enabled zones", 'A' + program - 1, zones_to_run.size());
          
          // Store the zones to run
          id(active_program) = program;
      
      # Run each zone in the program
      - if:
          condition:
            lambda: 'return id(zone1_program) == program && id(zone1_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 0
                duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone2_program) == program && id(zone2_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 1
                duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone3_program) == program && id(zone3_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 2
                duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone4_program) == program && id(zone4_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 3
                duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone5_program) == program && id(zone5_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 4
                duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone6_program) == program && id(zone6_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 5
                duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone7_program) == program && id(zone7_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 6
                duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone8_program) == program && id(zone8_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 7
                duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                add_delay: false
                force_normal: false
            - script.wait: run_zone_with_cycles

      # Update last run time ONLY for interval-based schedules (type 3)
      - lambda: |-
          long now = id(homeassistant_time).now().timestamp;
          
          // Only update last_run for interval schedules (type 3)
          if (program == 1 && id(program_a_schedule_type) == 3) {
            id(program_a_last_run) = now;
            ESP_LOGI("irrigation", "Program A last run updated for interval scheduling");
          } else if (program == 2 && id(program_b_schedule_type) == 3) {
            id(program_b_last_run) = now;
            ESP_LOGI("irrigation", "Program B last run updated for interval scheduling");
          } else if (program == 3 && id(program_c_schedule_type) == 3) {
            id(program_c_last_run) = now;
            ESP_LOGI("irrigation", "Program C last run updated for interval scheduling");
          }
          
          ESP_LOGI("irrigation", "Program %c complete", 'A' + program - 1);
          id(in_program_run) = false;
          id(irrigation_busy) = false;
      
      # Reset valve status to Idle
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - logger.log: "Valve status reset to Idle"
      
      # Restore Auto Advance
      - delay: 500ms
      - switch.turn_on: dev1_auto_advance
      - logger.log: "Auto Advance ON"
      
      # Drain queue
      - delay: 100ms
      - script.execute: drain_queue

  # Check if current time is within the restriction window
  - id: check_time_restriction
    mode: single
    then:
      - lambda: |-
          // Check if time restriction is disabled
          if (!id(time_restriction_switch).state) {
            id(is_time_restricted) = false;
            if (id(last_time_restriction_state) != 3) {
              ESP_LOGD("irrigation", "â° Time restriction DISABLED");
              id(last_time_restriction_state) = 3;
            }
            return;
          }
          
          // Check if manual override is active
          if (id(manual_time_restriction_override).state) {
            id(is_time_restricted) = false;
            if (id(last_time_restriction_state) != 2) {
              ESP_LOGI("irrigation", "â° Time restriction OVERRIDDEN - watering allowed");
              id(last_time_restriction_state) = 2;
            }
            return;
          }
          
          auto time = id(homeassistant_time).now();
          if (!time.is_valid()) {
            id(is_time_restricted) = false;
            return;
          }
          
          // Convert 12-hour to 24-hour format
          int sh = id(restrict_start_hour);
          int eh = id(restrict_end_hour);
          int start_hour24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
          int end_hour24   = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
          
          // Calculate time in minutes since midnight
          int now_min = time.hour * 60 + time.minute;
          int start_min = start_hour24 * 60 + id(restrict_start_minute);
          int end_min   = end_hour24 * 60 + id(restrict_end_minute);
          
          // Check if current time is in restricted window
          bool blocked = (start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                                : (now_min >= start_min || now_min < end_min);
          
          id(is_time_restricted) = blocked;

###############################################
# Customizable Zone Names
###############################################
text:
  - platform: template
    name: "$dev1_zone1 Name"
    id: zone1_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Front Lawn"
    mode: text
    restore_value: true

  - platform: template
    name: "$dev1_zone2 Name"
    id: zone2_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Back Lawn"
    mode: text
    restore_value: true

  - platform: template
    name: "$dev1_zone3 Name"
    id: zone3_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Garden Beds"
    mode: text
    restore_value: true

  - platform: template
    name: "$dev1_zone4 Name"
    id: zone4_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Side Yard"
    mode: text
    restore_value: true

  - platform: template
    name: "$dev1_zone5 Name"
    id: zone5_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Zone 5"
    mode: text
    restore_value: true

  - platform: template
    name: "$dev1_zone6 Name"
    id: zone6_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Zone 6"
    mode: text
    restore_value: true

  - platform: template
    name: "$dev1_zone7 Name"
    id: zone7_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Zone 7"
    mode: text
    restore_value: true

  - platform: template
    name: "$dev1_zone8 Name"
    id: zone8_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 30
    initial_value: "Zone 8"
    mode: text
    restore_value: true

###############################################
# Select Components
###############################################
select:
  # AM-PM selector
  - platform: template
    id: schedule_am_pm
    name: "Schedule AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true

  # Time Restriction AM-PM
  - platform: template
    id: restrict_start_am_pm_select
    name: "Time Restriction Start AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: true
    set_action:
      - lambda: |-
          id(restrict_start_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: restrict_end_am_pm_select
    name: "Time Restriction End AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: true
    set_action:
      - lambda: |-
          id(restrict_end_am_pm) = (x == "AM") ? 0 : 1;

  # Smart ET Schedule AM-PM
  - platform: template
    id: et_schedule_am_pm_select
    name: "$dev1_what ET Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(et_schedule_am_pm) = (x == "AM") ? 0 : 1;
          ESP_LOGI("irrigation", "Smart ET schedule AM/PM updated to %s", x.c_str());

# Program A schedule type
  - platform: template
    id: program_a_schedule_type_select
    name: "Program A Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_a_schedule_type) = 0;
          else if (x == "Odd Days") id(program_a_schedule_type) = 1;
          else if (x == "Even Days") id(program_a_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_a_schedule_type) = 3;

  # Program A AM-PM
  - platform: template
    id: program_a_am_pm_select
    name: "Program A AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(program_a_am_pm) = (x == "AM") ? 0 : 1;

  # Program B schedule type
  - platform: template
    id: program_b_schedule_type_select
    name: "Program B Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_b_schedule_type) = 0;
          else if (x == "Odd Days") id(program_b_schedule_type) = 1;
          else if (x == "Even Days") id(program_b_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_b_schedule_type) = 3;

  # Program B AM-PM
  - platform: template
    id: program_b_am_pm_select
    name: "Program B AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(program_b_am_pm) = (x == "AM") ? 0 : 1;

  # Program C schedule type
  - platform: template
    id: program_c_schedule_type_select
    name: "Program C Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_c_schedule_type) = 0;
          else if (x == "Odd Days") id(program_c_schedule_type) = 1;
          else if (x == "Even Days") id(program_c_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_c_schedule_type) = 3;

  # Program C AM-PM
  - platform: template
    id: program_c_am_pm_select
    name: "Program C AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(program_c_am_pm) = (x == "AM") ? 0 : 1;

  # Zone Schedule AM-PM Selectors
  - platform: template
    id: zone1_schedule_am_pm
    name: "Zone 1 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone1_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone2_schedule_am_pm
    name: "Zone 2 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone2_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone3_schedule_am_pm
    name: "Zone 3 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone3_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone4_schedule_am_pm
    name: "Zone 4 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone4_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone5_schedule_am_pm
    name: "Zone 5 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone5_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone6_schedule_am_pm
    name: "Zone 6 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone6_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone7_schedule_am_pm
    name: "Zone 7 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone7_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone8_schedule_am_pm
    name: "Zone 8 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone8_am_pm) = (x == "AM") ? 0 : 1;

  # Zone program assignment selects
  - platform: template
    id: zone1_program_select
    name: "Zone 1 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone1_program) = 0;
          else if (x == "Program A") id(zone1_program) = 1;
          else if (x == "Program B") id(zone1_program) = 2;
          else if (x == "Program C") id(zone1_program) = 3;

  - platform: template
    id: zone2_program_select
    name: "Zone 2 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone2_program) = 0;
          else if (x == "Program A") id(zone2_program) = 1;
          else if (x == "Program B") id(zone2_program) = 2;
          else if (x == "Program C") id(zone2_program) = 3;

  - platform: template
    id: zone3_program_select
    name: "Zone 3 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone3_program) = 0;
          else if (x == "Program A") id(zone3_program) = 1;
          else if (x == "Program B") id(zone3_program) = 2;
          else if (x == "Program C") id(zone3_program) = 3;

  - platform: template
    id: zone4_program_select
    name: "Zone 4 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone4_program) = 0;
          else if (x == "Program A") id(zone4_program) = 1;
          else if (x == "Program B") id(zone4_program) = 2;
          else if (x == "Program C") id(zone4_program) = 3;

  - platform: template
    id: zone5_program_select
    name: "Zone 5 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone5_program) = 0;
          else if (x == "Program A") id(zone5_program) = 1;
          else if (x == "Program B") id(zone5_program) = 2;
          else if (x == "Program C") id(zone5_program) = 3;

  - platform: template
    id: zone6_program_select
    name: "Zone 6 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone6_program) = 0;
          else if (x == "Program A") id(zone6_program) = 1;
          else if (x == "Program B") id(zone6_program) = 2;
          else if (x == "Program C") id(zone6_program) = 3;

  - platform: template
    id: zone7_program_select
    name: "Zone 7 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone7_program) = 0;
          else if (x == "Program A") id(zone7_program) = 1;
          else if (x == "Program B") id(zone7_program) = 2;
          else if (x == "Program C") id(zone7_program) = 3;

  - platform: template
    id: zone8_program_select
    name: "Zone 8 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone8_program) = 0;
          else if (x == "Program A") id(zone8_program) = 1;
          else if (x == "Program B") id(zone8_program) = 2;
          else if (x == "Program C") id(zone8_program) = 3;

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SOIL TYPE SELECTOR (Whanganui - Sandy Soil)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    id: soil_type_select
    name: "$dev1_what Soil Type"
    icon: "mdi:sprout"
    optimistic: true
    options:
      - "Sand"
      - "Loam"
      - "Clay"
    initial_option: "Sand"  # Whanganui default
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "Sand") {
            id(soil_type) = 0;
            // Auto-adjust cycle & soak for sand (fast drainage)
            id(cycle_duration_minutes) = 10;
            id(soak_duration_minutes) = 5;
            ESP_LOGI("irrigation", "ğŸŒ± Soil Type: SAND");
            ESP_LOGI("irrigation", "   ET Factor: 1.15x (drains fast, needs more frequent)");
            ESP_LOGI("irrigation", "   Cycle/Soak: 10min/5min (light, frequent applications)");
          } else if (x == "Loam") {
            id(soil_type) = 1;
            // Standard cycle & soak for loam (balanced)
            id(cycle_duration_minutes) = 15;
            id(soak_duration_minutes) = 10;
            ESP_LOGI("irrigation", "ğŸŒ± Soil Type: LOAM");
            ESP_LOGI("irrigation", "   ET Factor: 1.00x (balanced moisture retention)");
            ESP_LOGI("irrigation", "   Cycle/Soak: 15min/10min (standard applications)");
          } else if (x == "Clay") {
            id(soil_type) = 2;
            // Long soak for clay (slow drainage, prevent runoff)
            id(cycle_duration_minutes) = 10;
            id(soak_duration_minutes) = 15;
            ESP_LOGI("irrigation", "ğŸŒ± Soil Type: CLAY");
            ESP_LOGI("irrigation", "   ET Factor: 0.85x (holds moisture longer)");
            ESP_LOGI("irrigation", "   Cycle/Soak: 10min/15min (prevent runoff)");
          }

###############################################
# Main Sprinkler Controller
###############################################

switch:
   # Restart button
  - platform: restart
    name: "Restart $esphome_comment"
    icon: "mdi:restart"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PREDICTIVE WATERINGâ„¢ MASTER SWITCH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "$dev1_what Predictive Wateringâ„¢"
    id: predictive_watering_switch
    icon: "mdi:weather-partly-rainy"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - lambda: |-
          id(predictive_watering_enabled) = true;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ’§ PREDICTIVE WATERINGâ„¢ ENABLED");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
      - script.execute: calculate_predictive_watering
    on_turn_off:
      - lambda: |-
          id(predictive_watering_enabled) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ PREDICTIVE WATERINGâ„¢ DISABLED");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ Reverting to standard seasonal multiplier");
          
          // Revert to basic seasonal multiplier
          auto time = id(homeassistant_time).now();
          if (!time.is_valid()) {
            id($devicename1).set_multiplier(1.0);
            return;
          }
          
          int month = time.month;
          float temp = id(outside_temperature).state;
          if (isnan(temp)) temp = 20.0;
          
          float multiplier = 1.0;
          if (month >= 12 || month <= 2) {
            multiplier = 1.3;
            if (temp > 25) multiplier = 1.6;
            if (temp > 30) multiplier = 1.8;
          } else if (month >= 6 && month <= 8) {
            multiplier = 0.5;
            if (temp < 10) multiplier = 0.3;
          } else {
            multiplier = 0.8;
            if (temp > 20) multiplier = 1.0;
          }
          
          id($devicename1).set_multiplier(multiplier);
          ESP_LOGI("irrigation", "âœ“ Multiplier set to %.2f (basic seasonal)", multiplier);

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MASTER VALVE ENABLE (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Optional feature - system works fine without master valve
  # When ENABLED: Master valve opens automatically with any zone
  # When DISABLED: Zones work independently (normal operation)
  
  - platform: template
    name: "$dev1_what Enable Master Valve"
    id: master_valve_enable_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF  # Off by default - optional feature
    on_turn_on:
      - lambda: |-
          id(master_valve_enabled) = true;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ MASTER VALVE ENABLED");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ Master valve will open automatically when zones run");
          ESP_LOGI("irrigation", "ğŸ”§ Manual controls are now active");
          ESP_LOGI("irrigation", "");
    on_turn_off:
      - lambda: |-
          id(master_valve_enabled) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ MASTER VALVE DISABLED");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ Zones will operate independently (normal mode)");
          ESP_LOGI("irrigation", "âŒ Master valve manual controls disabled for safety");
          ESP_LOGI("irrigation", "");
          
          // Safety: Turn off master valve if it's currently on
          if (id(master_valve_relay).state) {
            ESP_LOGW("irrigation", "âš ï¸ Master valve was ON - closing for safety");
            id(master_valve_relay).turn_off();
          }

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PER-ZONE MASTER VALVE CONTROL
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Control which zones use the master valve (when globally enabled)
  # Allows zones to bypass master valve for well water, drip systems, etc.
  
  - platform: template
    name: "$dev1_zone1 Use Master Valve"
    id: zone1_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Default ON
    lambda: "return id(zone1_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone1_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone1_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone2 Use Master Valve"
    id: zone2_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone2_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone2_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone2_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone3 Use Master Valve"
    id: zone3_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone3_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone3_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone3_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone4 Use Master Valve"
    id: zone4_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone4_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone4_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone4_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone5 Use Master Valve"
    id: zone5_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone5_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone5_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone5_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone6 Use Master Valve"
    id: zone6_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone6_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone6_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone6_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone7 Use Master Valve"
    id: zone7_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone7_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone7_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone7_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone8 Use Master Valve"
    id: zone8_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone8_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone8_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone8_master_valve_enabled) = false;"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SMART ET WATERING MASTER SWITCH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "$dev1_what Smart ET Watering"
    id: smart_et_switch
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - lambda: |-
          id(smart_et_enabled) = true;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸŒ± SMART ET WATERING ENABLED");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸŒ± System will automatically water based on ET");
          ESP_LOGI("irrigation", "ğŸŒ± Scheduled watering is OVERRIDDEN");
      - script.execute: calculate_smart_et
    on_turn_off:
      - lambda: |-
          id(smart_et_enabled) = false;
          id(et_pending_irrigation) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ SMART ET WATERING DISABLED");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ Reverting to scheduled watering");

  # Manual Master Valve Test Button
  - platform: template
    name: "Schedule 1 - Monday"
    id: schedule_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 2 - Tuesday"
    id: schedule_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 3 - Wednesday"
    id: schedule_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 4 - Thursday"
    id: schedule_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 5 - Friday"
    id: schedule_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 6 - Saturday"
    id: schedule_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 7 - Sunday"
    id: schedule_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Cycle and Soak Enable/Disable
  - platform: template
    name: "Cycle and Soak Mode"
    id: cycle_soak_switch
    icon: "mdi:water-sync"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(cycle_soak_enabled);"
    turn_on_action:
      - lambda: "id(cycle_soak_enabled) = true;"
    turn_off_action:
      - lambda: "id(cycle_soak_enabled) = false;"

  # Master Valve Enable (Optional - Hunter Pro-C Style)
  # Global enable/disable for entire master valve system
  - platform: template
    name: "Time Restriction Override"
    id: manual_time_restriction_override
    icon: "mdi:shield-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - script.execute: check_time_restriction
      - logger.log: "âš ï¸ Time restriction override ON - immediate check triggered"
    turn_off_action:
      - script.execute: check_time_restriction
      - logger.log: "âœ“ Time restriction override OFF - immediate check triggered"

  # Time of Day Restriction (10am-3pm block)
  - platform: template
    name: "Time Restriction Enable"
    id: time_restriction_switch
    icon: "mdi:clock-alert"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

  # Weekly schedule enable
  - platform: template
    name: "Enable Weekly Schedule"
    id: weekly_schedule_switch
    icon: "mdi:calendar-clock"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Manual Rain Delay Override
  - platform: template
    name: "Disable Auto Rain Delay"
    id: manual_rain_delay_override_switch
    icon: "mdi:cloud-off-outline"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(manual_rain_delay_override);"
    turn_on_action:
      - lambda: |-
          id(manual_rain_delay_override) = true;
          // Clear any active rain delay immediately so it stops blocking runs
          id(rain_delay_end_time) = 0;
          id(rain_delay_days) = 0;
          id(rain_delay_days_input).publish_state(0);
          ESP_LOGI("irrigation", "Manual rain delay override enabled - active rain delay CLEARED");
    turn_off_action:
      - lambda: |-
          id(manual_rain_delay_override) = false;
          ESP_LOGI("irrigation", "Manual rain delay override disabled - checking weather immediately");
          
          // Immediately check current weather and apply rain delay if needed
          std::string weather = id(weather_forecast_home).state;
          if (weather.empty() || weather == "unknown" || weather == "unavailable") {
            ESP_LOGW("irrigation", "Weather state unavailable - rain delay will be set on next weather update");
            return;
          }
          
          if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
            id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (86400 * 2);
            id(rain_delay_days) = 2;
            id(rain_delay_days_input).publish_state(2);
            ESP_LOGI("irrigation", "Auto rain delay IMMEDIATELY activated - weather is %s", weather.c_str());
          } else {
            ESP_LOGI("irrigation", "Weather is %s - no rain delay needed", weather.c_str());
          }

  # Manual Weather Override - Force watering in bad weather
  - platform: template
    name: "Weather Override (Force Watering)"
    id: manual_weather_override_switch
    icon: "mdi:weather-lightning-rainy"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(manual_weather_override);"
    turn_on_action:
      - lambda: |-
          id(manual_weather_override) = true;
      - logger.log:
          format: "âš ï¸ WEATHER OVERRIDE ENABLED - Will water in any weather!"
          level: WARN
    turn_off_action:
      - lambda: |-
          id(manual_weather_override) = false;
      - logger.log:
          format: "âœ“ Weather override disabled - Normal weather checks active"
          level: INFO

# Vacation Mode
  - platform: template
    name: "Vacation Mode"
    id: vacation_mode_switch
    icon: "mdi:airplane"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(vacation_mode_active);"
    turn_on_action:
      - lambda: |-
          id(vacation_mode_active) = true;
          // Save current multiplier
          id(normal_multiplier) = id($devicename1).multiplier();
          // Reduce watering by 50%
          id($devicename1).set_multiplier(id(normal_multiplier) * 0.5);
          // Disable all individual zone schedules
          id(zone1_schedule_enabled) = false;
          id(zone2_schedule_enabled) = false;
          id(zone3_schedule_enabled) = false;
          id(zone4_schedule_enabled) = false;
          id(zone5_schedule_enabled) = false;
          id(zone6_schedule_enabled) = false;
          id(zone7_schedule_enabled) = false;
          id(zone8_schedule_enabled) = false;
          ESP_LOGI("irrigation", "Vacation mode activated - watering reduced to 50%%, individual zone schedules disabled");
    turn_off_action:
      - lambda: |-
          id(vacation_mode_active) = false;
          // Restore normal multiplier
          id($devicename1).set_multiplier(id(normal_multiplier));
          ESP_LOGI("irrigation", "Vacation mode deactivated - normal watering restored");

# System Enable/Disable - Master control
  - platform: template
    name: "Irrigation System Enable"
    id: irrigation_system_enable
    icon: "mdi:water"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Defaults to ON (enabled)
    turn_off_action:
      # Stop everything when disabled
      - sprinkler.shutdown: $devicename1
      - script.stop: run_zone_with_cycles
      - lambda: |-
          id(active_zone_number) = -1;
          id(current_cycle) = 0;
          id(total_cycles) = 0;
          id(cycle_soak_total_duration) = 0;
          id(cycle_soak_elapsed_time) = 0;
          id(is_paused) = false;
          ESP_LOGI("irrigation", "Irrigation system DISABLED");
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "System Disabled"

 # Zone Schedule Enable Switches
  - platform: template
    name: "Zone 1 Schedule Enable"
    id: zone1_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone1_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone1_schedule_enabled) = false;"

  - platform: template
    name: "Zone 2 Schedule Enable"
    id: zone2_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone2_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone2_schedule_enabled) = false;"

  - platform: template
    name: "Zone 3 Schedule Enable"
    id: zone3_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone3_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone3_schedule_enabled) = false;"

  - platform: template
    name: "Zone 4 Schedule Enable"
    id: zone4_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone4_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone4_schedule_enabled) = false;"

  - platform: template
    name: "Zone 5 Schedule Enable"
    id: zone5_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone5_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone5_schedule_enabled) = false;"

  - platform: template
    name: "Zone 6 Schedule Enable"
    id: zone6_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone6_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone6_schedule_enabled) = false;"

  - platform: template
    name: "Zone 7 Schedule Enable"
    id: zone7_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone7_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone7_schedule_enabled) = false;"

  - platform: template
    name: "Zone 8 Schedule Enable"
    id: zone8_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone8_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone8_schedule_enabled) = false;"

# Program enable switches
  - platform: template
    name: "Enable Program A"
    id: program_a_enable_switch
    icon: "mdi:alpha-a-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(program_a_enabled);"
    turn_on_action:
      - lambda: "id(program_a_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_a_enabled) = false;"

  - platform: template
    name: "Enable Program B"
    id: program_b_enable_switch
    icon: "mdi:alpha-b-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(program_b_enabled);"
    turn_on_action:
      - lambda: "id(program_b_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_b_enabled) = false;"

  - platform: template
    name: "Enable Program C"
    id: program_c_enable_switch
    icon: "mdi:alpha-c-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(program_c_enabled);"
    turn_on_action:
      - lambda: "id(program_c_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_c_enabled) = false;"

# Program A day selection (only used when schedule type is "Specific Days")
  - platform: template
    name: "Program A - 1 Monday"
    id: program_a_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 2 Tuesday"
    id: program_a_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 3 Wednesday"
    id: program_a_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 4 Thursday"
    id: program_a_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 5 Friday"
    id: program_a_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 6 Saturday"
    id: program_a_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 7 Sunday"
    id: program_a_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Program B day selection
  - platform: template
    name: "Program B - 1 Monday"
    id: program_b_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 2 Tuesday"
    id: program_b_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 3 Wednesday"
    id: program_b_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 4 Thursday"
    id: program_b_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 5 Friday"
    id: program_b_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 6 Saturday"
    id: program_b_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 7 Sunday"
    id: program_b_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Program C day selection
  - platform: template
    name: "Program C - 1 Monday"
    id: program_c_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 2 Tuesday"
    id: program_c_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 3 Wednesday"
    id: program_c_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 4 Thursday"
    id: program_c_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 5 Friday"
    id: program_c_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 6 Saturday"
    id: program_c_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 7 Sunday"
    id: program_c_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF  # USER-FACING ZONE SWITCHES (enforce all checks)
  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_1
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 1 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_1).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 1 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_1).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone1_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone1 Active"); 
    on_turn_off:
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone1_start_time);
          if (duration > 120) {
            id(zone1_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 1 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO13
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_2
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 2 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_2).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 2 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_2).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone2_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone2 Active"); 
    on_turn_off:
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone2_start_time);
          if (duration > 120) {
            id(zone2_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 2 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO33
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_3
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 3 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_3).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 3 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_3).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time
          id(zone3_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone3 Active");
    on_turn_off:
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone3_start_time);
          if (duration > 120) {
            id(zone3_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 3 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO04
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_4
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 4 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_4).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 4 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_4).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone4_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone4 Active");
          id(dev1_valve_status).publish_state("$dev1_zone4 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone4_start_time);
          if (duration > 120) {
            id(zone4_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 4 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO14
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_5
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 5 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_5).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 5 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_5).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone5_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone5 Active");
          id(dev1_valve_status).publish_state("$dev1_zone5 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone5_start_time);
          if (duration > 120) {
            id(zone5_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 5 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO16
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_6
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 6 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_6).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 6 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_6).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone6_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone6 Active");
          id(dev1_valve_status).publish_state("$dev1_zone6 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone6_start_time);
          if (duration > 120) {
            id(zone6_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 6 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO32
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_7
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 7 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_7).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 7 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_7).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone7_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone7 Active");
          id(dev1_valve_status).publish_state("$dev1_zone7 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone7_start_time);
          if (duration > 120) {
            id(zone7_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 7 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO25
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_8
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 8 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_8).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 8 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_8).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone8_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone8 Active");
          id(dev1_valve_status).publish_state("$dev1_zone8 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone8_start_time);
          if (duration > 120) {
            id(zone8_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 8 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO26
    inverted: true

# Master Valve (Optional - like Hunter Pro-C)
# Can be enabled/disabled via "Enable Master Valve" switch
# Automatically opens when any zone is active (if enabled)
  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: master_valve_relay
    name: "Master Valve Relay"
    pin: $master_valve_pin
    inverted: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PRODUCTION FEATURES - WATERING WINDOWS & OVERRIDES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "$dev1_what Enable Watering Window 1"
    id: window1_enable_switch
    icon: "mdi:clock-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - lambda: |-
          id(window1_enabled) = true;
          ESP_LOGI("irrigation", "ğŸ• Watering Window 1 ENABLED (%d:00 - %d:00)", 
                   id(window1_start_hour), id(window1_end_hour));
    on_turn_off:
      - lambda: |-
          id(window1_enabled) = false;
          ESP_LOGI("irrigation", "ğŸ• Watering Window 1 DISABLED");
  
  - platform: template
    name: "$dev1_what Enable Watering Window 2"
    id: window2_enable_switch
    icon: "mdi:clock-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - lambda: |-
          id(window2_enabled) = true;
          ESP_LOGI("irrigation", "ğŸ• Watering Window 2 ENABLED (%d:00 - %d:00)", 
                   id(window2_start_hour), id(window2_end_hour));
    on_turn_off:
      - lambda: |-
          id(window2_enabled) = false;
          ESP_LOGI("irrigation", "ğŸ• Watering Window 2 DISABLED");
  
  - platform: template
    name: "$dev1_what Budget Override"
    id: budget_override_switch
    icon: "mdi:water-pump-off"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - lambda: |-
          id(budget_override_active) = true;
          ESP_LOGW("irrigation", "");
          ESP_LOGW("irrigation", "âš ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("irrigation", "âš ï¸ WATER BUDGET OVERRIDE ACTIVE");
          ESP_LOGW("irrigation", "âš ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("irrigation", "âš ï¸ Watering will continue even if budget exceeded");
          ESP_LOGW("irrigation", "âš ï¸ Current usage: %.1fL / %.1fL (%.1f%%)", 
                   id(current_month_usage), id(monthly_water_budget),
                   (id(current_month_usage) / id(monthly_water_budget)) * 100.0);
          ESP_LOGW("irrigation", "âš ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("irrigation", "");
    on_turn_off:
      - lambda: |-
          id(budget_override_active) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âœ… Water budget enforcement RE-ENABLED");
          ESP_LOGI("irrigation", "");

sprinkler:
  - id: $devicename1
    main_switch:
      name: "$dev1_what Start-Stop-Resume"
      id: dev1_main_switch
      internal: true
      on_turn_off:
        - lambda: |-
            // Don't stop run_zone_with_cycles during cycle/soak mode with multiple cycles
            // Only stop if we're in normal mode or if it's a manual stop
            bool in_cycle_soak = (id(total_cycles) > 0 && id(current_cycle) > 0);
            
            if (!in_cycle_soak) {
              ESP_LOGI("irrigation", "Main switch OFF - stopping run_zone_with_cycles (normal mode)");
              id(run_zone_with_cycles).stop();
              
              // Reset soak countdown when stopping
              id(cycle_soak_is_soaking) = false;
              id(cycle_soak_soak_end_time) = 0;
              id(soak_countdown_seconds) = 0;
            } else {
              ESP_LOGI("irrigation", "Main switch OFF - NOT stopping script (in cycle/soak, cycle %d/%d)",
                       id(current_cycle), id(total_cycles));
            }
            
            if (id(is_paused)) return;

            // Only clear state if not in active cycle/soak
            if (!in_cycle_soak) {
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;
            }

            if (id(irrigation_busy) && !id(in_program_run)) {
              id(irrigation_busy) = false;
              id(drain_queue).execute();
            }
            
            // Reset valve status to Idle when main switch turns off
            id(dev1_valve_status).publish_state("Idle");

      on_turn_on:
        - lambda: |-
            // CRITICAL: Check if irrigation system is enabled
            if (!id(irrigation_system_enable).state) {
              ESP_LOGW("irrigation", "ğŸš« BLOCKED - Irrigation system is DISABLED");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            // Check rain delay
            if (id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
              ESP_LOGW("irrigation", "â›ˆï¸ BLOCKED - Rain delay is active");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            // Weather check (unless override is active)
            if (!id(manual_weather_override)) {
              std::string w = id(weather_forecast_home).state;
              if (!w.empty() && w != "unknown" && w != "unavailable") {
                if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                  ESP_LOGW("irrigation", "â›ˆï¸ BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                  id(dev1_main_switch).turn_off();
                  return;
                }
              }
            }
            
            // Time restriction check
            if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "â° BLOCKED - Time restriction active");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            ESP_LOGI("irrigation", "âœ… Main switch turned ON - all checks passed");

    auto_advance_switch:
      name: "$dev1_what Auto Advance"
      id: dev1_auto_advance
      restore_mode: ALWAYS_ON

    valve_open_delay: 2s
    valves:
      - valve_switch: $dev1_zone1
        enable_switch:
          name: Enable $dev1_zone1
          id: zone1_enable
        run_duration_number:
          id: "${devicename1}_1_duration"
          name: "${dev1_zone1} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_1
        
      - valve_switch: $dev1_zone2
        enable_switch:
          name: Enable $dev1_zone2
          id: zone2_enable
        run_duration_number:
          id: "${devicename1}_2_duration"
          name: "${dev1_zone2} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_2
        
      - valve_switch: $dev1_zone3
        enable_switch:
          name: Enable $dev1_zone3
          id: zone3_enable
        run_duration_number:
          id: "${devicename1}_3_duration"
          name: "${dev1_zone3} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_3
        
      - valve_switch: $dev1_zone4
        enable_switch:
          name: Enable $dev1_zone4
          id: zone4_enable
        run_duration_number:
          id: "${devicename1}_4_duration"
          name: "${dev1_zone4} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_4
        
      - valve_switch: $dev1_zone5
        enable_switch:
          name: Enable $dev1_zone5
          id: zone5_enable
        run_duration_number:
          id: "${devicename1}_5_duration"
          name: "${dev1_zone5} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_5
        
      - valve_switch: $dev1_zone6
        enable_switch:
          name: Enable $dev1_zone6
          id: zone6_enable
        run_duration_number:
          id: "${devicename1}_6_duration"
          name: "${dev1_zone6} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_6
        
      - valve_switch: $dev1_zone7
        enable_switch:
          name: Enable $dev1_zone7
          id: zone7_enable
        run_duration_number:
          id: "${devicename1}_7_duration"
          name: "${dev1_zone7} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_7
        
      - valve_switch: $dev1_zone8
        enable_switch:
          name: Enable $dev1_zone8
          id: zone8_enable
        run_duration_number:
          id: "${devicename1}_8_duration"
          name: "${dev1_zone8} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_8


button:
  # Manual Predictive Watering calculation trigger
  - platform: template
    name: "$dev1_what Recalculate Predictive Watering"
    icon: "mdi:refresh"
    on_press:
      - script.execute: calculate_predictive_watering

  # Smart ET buttons
  - platform: template
    name: "$dev1_what Recalculate Smart ET"
    icon: "mdi:calculator"
    on_press:
      - script.execute: calculate_smart_et

  - platform: template
    name: "$dev1_what Reset ET Deficit"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          id(et_soil_moisture_deficit) = 0;
          id(et_pending_irrigation) = false;
          ESP_LOGI("irrigation", "ğŸŒ± Smart ET: Deficit manually reset to 0mm");

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MASTER VALVE TEST (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "$dev1_what Test Master Valve"
    icon: "mdi:test-tube"
    on_press:
      - lambda: |-
          if (!id(master_valve_enabled)) {
            ESP_LOGW("irrigation", "âš ï¸ Master Valve is DISABLED in settings - enable it first!");
            return;
          }
          // Enter test mode to prevent watchdog interference
          id(test_mode_active) = true;
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ§ª â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ§ª MASTER VALVE TEST");
          ESP_LOGI("irrigation", "ğŸ§ª â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "Opening master valve for 10 seconds...");
          ESP_LOGI("irrigation", "(Watchdog auto-control disabled during test)");
      
      - lambda: "id(master_valve_relay).turn_on();"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (1s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (2s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (3s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (4s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (5s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (6s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (7s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (8s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (9s)\");"
      - delay: 1s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (10s)\");"
      
      - lambda: "id(master_valve_relay).turn_off();"
      - lambda: |-
          // Exit test mode - re-enable watchdog
          id(test_mode_active) = false;
          
          ESP_LOGI("irrigation", "ğŸ”’ Master Valve CLOSED");
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âœ… Master Valve test complete!");
          ESP_LOGI("irrigation", "   If you heard/saw water flow, master valve is working!");
          ESP_LOGI("irrigation", "");

  - platform: template
    id: start_all_zones_normal
    name: "$dev1_what Start All Zones (Normal)"
    icon: "mdi:play-circle-outline"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Start All Zones (NORMAL)");
            
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: |-
                      // Check rain delay (unless manual override is active)
                      if (!id(manual_rain_delay_override)) {
                        return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;
                      }
                      return false;  // Override active, don't block
                  then:
                    - logger.log:
                        format: "â›ˆï¸ BLOCKED: Rain delay is active (Disable Auto Rain Delay to override)"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: |-
                            // Time restriction check
                            return id(is_time_restricted);
                        then:
                          - logger.log:
                              format: "â° BLOCKED: Time restriction active (outside allowed hours)"
                              level: WARN
                        else:
                          - if:
                              condition:
                                lambda: |-
                                  // Weather check (unless override is active)
                                  if (!id(manual_weather_override)) {
                                    std::string w = id(weather_forecast_home).state;
                                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                                        return true;  // Bad weather - block
                                      }
                                    }
                                  }
                                  return false;  // Weather OK or override active
                              then:
                                - logger.log:
                                    format: "â›ˆï¸ BLOCKED: Bad weather (Enable Weather Override to force)"
                                    level: WARN
                              else:
                                - lambda: |-
                                    std::string w = id(weather_forecast_home).state;
                                    if (id(manual_weather_override)) {
                                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                                    } else {
                                      ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                                    }
                                    id(pending_normal_start) = true;
                                    id(normal_start_attempts) = 0;
                                    id(normal_last_attempt_ms) = 0;
                                    ESP_LOGI("irrigation", "âœ… Queued NORMAL start (will begin when system ready)");

# Manual program run buttons
  - platform: template
    name: "Run Program A Now"
    icon: "mdi:alpha-a-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run Program A");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log: "Rain delay active"
                  else:
                    - script.execute:
                        id: request_program_start
                        program: 1
                        allow_queue: true
                        
  - platform: template
    name: "Run Program B Now"
    icon: "mdi:alpha-b-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run Program A");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log: "Rain delay active"
                  else:
                    - script.execute:
                        id: request_program_start
                        program: 2
                        allow_queue: true

  - platform: template
    name: "Run Program C Now"
    icon: "mdi:alpha-c-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run Program A");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log: "Rain delay active"
                  else:
                    - script.execute:
                        id: request_program_start
                        program: 3
                        allow_queue: true

# Pause button - Actually stops the valve
  - platform: template
    id: dev1_sprinkler_pause
    name: "$dev1_what Pause"
    icon: "mdi:pause"
    on_press:
      then:
        - lambda: |-
            // Save current state if a valve is active
            if (id($devicename1).active_valve().has_value()) {
              id(paused_zone) = id($devicename1).active_valve().value();
              id(paused_cycle) = id(current_cycle);
              id(time_remaining_when_paused) = id($devicename1).time_remaining_active_valve().value_or(0);
              id(is_paused) = true;

              // Snapshot cycle/soak state for resume
              id(paused_total_cycles) = id(total_cycles);
              id(paused_cycle_soak_total_duration) = id(cycle_soak_total_duration);
              id(paused_cycle_soak_elapsed_time) = id(cycle_soak_elapsed_time);
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              
              ESP_LOGI("irrigation", "Paused: Zone %d, Cycle %d/%d, Time remaining: %d sec, Elapsed: %d/%d sec",
                       id(paused_zone), id(paused_cycle), id(total_cycles),
                       id(time_remaining_when_paused),
                       id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
              
              // ADDED: Confirm progress tracking is paused
              ESP_LOGI("irrigation", "Progress tracking PAUSED - elapsed time frozen at %d seconds",
                       id(cycle_soak_elapsed_time));
              
            } else if (id(cycle_soak_is_soaking) && id(active_zone_number) >= 0 && id(total_cycles) > 0) {
              id(paused_zone) = id(active_zone_number);
              id(paused_cycle) = id(current_cycle);
              long now = id(homeassistant_time).now().timestamp;
              long rem = id(cycle_soak_soak_end_time) - now;
              if (rem < 0) rem = 0;
              id(paused_soak_remaining_seconds) = (int) rem;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = true;
              id(is_paused) = true;
              id(paused_total_cycles) = id(total_cycles);
              id(paused_cycle_soak_total_duration) = id(cycle_soak_total_duration);
              id(paused_cycle_soak_elapsed_time) = id(cycle_soak_elapsed_time);
              
              ESP_LOGI("irrigation", "Paused during soak: Zone %d, Cycle %d/%d, Soak remaining: %d sec, Elapsed: %d/%d sec",
                       id(paused_zone), id(paused_cycle), id(paused_total_cycles),
                       id(paused_soak_remaining_seconds),
                       id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
              
              // ADDED: Confirm progress tracking is paused
              ESP_LOGI("irrigation", "Progress tracking PAUSED during soak - elapsed time frozen at %d seconds",
                       id(cycle_soak_elapsed_time));
            } else {
              ESP_LOGI("irrigation", "Nothing active to pause");
            }
        - sprinkler.shutdown: $devicename1
        - script.stop: run_zone_with_cycles
        - script.stop: run_all_zones_cycle_soak_script
        - script.stop: run_program
        - text_sensor.template.publish:
            id: dev1_valve_status
            state: "Paused"

# Resume button - Restarts from saved position
  - platform: template
    id: dev1_sprinkler_resume
    name: "$dev1_what Resume"
    icon: "mdi:play"
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(is_paused) && id(paused_zone) >= 0;'
            then:
              - lambda: |-
                  // Restore cycle/soak snapshot BEFORE mode checks
                  id(total_cycles) = id(paused_total_cycles);
                  id(cycle_soak_total_duration) = id(paused_cycle_soak_total_duration);
                  id(cycle_soak_elapsed_time) = id(paused_cycle_soak_elapsed_time);

                  ESP_LOGI("irrigation", "Resuming: Zone %d, Cycle %d/%d, Elapsed restored to: %d/%d sec",
                           id(paused_zone), id(paused_cycle), id(total_cycles),
                           id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
                  
                  // ADDED: Confirm progress tracking will resume
                  ESP_LOGI("irrigation", "Progress tracking will RESUME from %d seconds",
                           id(cycle_soak_elapsed_time));

                  id(is_paused) = false;
                  id(active_zone_number) = id(paused_zone);
                  id(current_cycle) = id(paused_cycle);

              # If we paused while watering, restart valve for remaining time
              - if:
                  condition:
                    lambda: 'return !id(paused_was_soaking);'
                  then:
                    - sprinkler.start_single_valve:
                        id: $devicename1
                        valve_number: !lambda 'return id(paused_zone);'
                        run_duration: !lambda 'return id(time_remaining_when_paused);'

              # Force Auto Advance state based on mode
              - delay: 100ms
              - if:
                  condition:
                    lambda: 'return id(total_cycles) > 0;'
                  then:
                    - switch.turn_off: dev1_auto_advance
                    - logger.log: "Auto Advance forced OFF (Cycle & Soak mode)"
                    - script.execute:
                        id: continue_cycle_soak_after_resume
                        zone: !lambda 'return id(paused_zone);'
                        start_cycle: !lambda 'return id(current_cycle);'
                        total: !lambda 'return id(total_cycles);'
                        was_soaking: !lambda 'return id(paused_was_soaking);'
                        soak_remaining: !lambda 'return id(paused_soak_remaining_seconds);'
                        water_remaining: !lambda 'return id(time_remaining_when_paused);'
                  else:
                    - switch.turn_on: dev1_auto_advance
                    - logger.log: "Auto Advance ON (Normal mode)"

              - text_sensor.template.publish:
                  id: dev1_valve_status
                  state: "Resumed"

              # Clear pause flags for normal mode; cycle/soak cleanup happens in continuation script
              - if:
                  condition:
                    lambda: 'return id(total_cycles) <= 0;'
                  then:
                    - lambda: |-
                        id(paused_zone) = -1;
                        id(paused_cycle) = 0;
                        id(time_remaining_when_paused) = 0;
                        id(paused_was_soaking) = false;
                        id(paused_soak_remaining_seconds) = 0;
                        id(paused_total_cycles) = 0;
                        id(paused_cycle_soak_total_duration) = 0;
                        id(paused_cycle_soak_elapsed_time) = 0;

            else:
              - logger.log: "Nothing to resume - not paused or no saved state"

  - platform: template
    id: dev1_sprinkler_stop
    name: "$dev1_what Stop"
    icon: "mdi:stop"
    on_press:
      then:
        - logger.log: "â•â•â• STOP BUTTON PRESSED â•â•â•"

        # Cancel pending normal-mode retry worker (but preserve queued programs/zones)
        - lambda: |-
            id(pending_normal_start) = false;
            id(normal_start_attempts) = 0;
            id(normal_last_attempt_ms) = 0;

            // Clear ONLY queued NORMAL start (type 3). Preserve Program (1) and Zone (2).
            if (id(queued_type) == 3) {
              ESP_LOGI("irrigation", "Clearing queued NORMAL request (type 3) on STOP");
              id(queued_type) = 0;
            }

            ESP_LOGI(
              "irrigation",
              "â¹ STOPPING: Zone=%d, Cycle=%d/%d, queued_type=%d",
              id(active_zone_number),
              id(current_cycle),
              id(total_cycles),
              id(queued_type)
            );

            // Keep busy flag SET during shutdown/cleanup
            id(irrigation_busy) = true;

        # Stop sprinkler controller (shutdown respects internal stop delays)
        - sprinkler.shutdown: $devicename1

        # Stop helper scripts
        - script.stop: run_zone_with_cycles
        - script.stop: run_all_zones_cycle_soak_script
        - script.stop: run_program
        - script.stop: run_all_zones_normal_script
        - script.stop: wait_until_idle_then_drain

        # Clear run-state variables (do NOT clear queued_program/queued_zone)
        - lambda: |-
            ESP_LOGI("irrigation", "ğŸ§¹ Clearing run state variables");
            id(active_zone_number) = -1;
            id(current_cycle) = 0;
            id(total_cycles) = 0;
            id(cycle_soak_total_duration) = 0;
            id(cycle_soak_elapsed_time) = 0;
            id(is_paused) = false;
            id(paused_zone) = -1;
            id(paused_cycle) = 0;
            id(time_remaining_when_paused) = 0;
            id(in_program_run) = false;

        - text_sensor.template.publish:
            id: dev1_valve_status
            state: "Stopped"

        # Give the sprinkler component time to finish its internal shutdown window
        - delay: 8s

        # Now mark idle
        - lambda: |-
            ESP_LOGI("irrigation", "âœ“ Stop cleanup complete (idle)");
            id(irrigation_busy) = false;

        # If a Program (type 1) or Zone (type 2) is queued, run it now
        - if:
            condition:
              lambda: |-
                return id(queued_type) != 0;
            then:
              - logger.log: "â–¶ Starting queued request after STOP"
              - script.execute: drain_queue

# Start All Zones - CYCLE & SOAK MODE
  - platform: template
    id: start_all_zones_cycle_soak
    name: "$dev1_what Start All Zones (Cycle & Soak)"
    icon: "mdi:water-sync"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Start All Zones (CYCLE & SOAK)");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log:
                        format: "â›ˆï¸ BLOCKED: Rain delay is active"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: |-
                            // Time restriction check
                            return id(is_time_restricted);
                        then:
                          - logger.log:
                              format: "â° BLOCKED: Time restriction active (outside allowed hours)"
                              level: WARN
                        else:
                          - if:
                              condition:
                                lambda: |-
                                  // Weather check (unless override is active)
                                  if (!id(manual_weather_override)) {
                                    std::string w = id(weather_forecast_home).state;
                                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                                        return true;  // Bad weather - block
                                      }
                                    }
                                  }
                                  return false;  // Weather OK or override active
                              then:
                                - logger.log:
                                    format: "â›ˆï¸ BLOCKED: Bad weather (Enable Weather Override to force)"
                                    level: WARN
                              else:
                                - lambda: |-
                                    std::string w = id(weather_forecast_home).state;
                                    if (id(manual_weather_override)) {
                                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                                    } else {
                                      ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                                    }
                                # Turn ON cycle and soak mode
                                - switch.turn_on: cycle_soak_switch
                                - logger.log:
                                    format: "âœ… Cycle & Soak Mode ON - Starting all enabled zones"
                                    level: INFO
                                - script.execute: run_all_zones_cycle_soak_script

  - platform: template
    name: "$dev1_zone1 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 0
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true

  - platform: template
    name: "$dev1_zone2 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 1
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone3 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 2
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone4 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 3
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone5 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 4
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone6 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 5
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone7 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 6
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone8 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 7
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER USAGE RESET BUTTONS (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "$dev1_what Reset All Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ’§ RESETTING ALL WATER USAGE COUNTERS");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "Previous Total: %.1f L", id(total_water_used));
          
          // Reset all zone counters
          id(zone1_water_used) = 0;
          id(zone2_water_used) = 0;
          id(zone3_water_used) = 0;
          id(zone4_water_used) = 0;
          id(zone5_water_used) = 0;
          id(zone6_water_used) = 0;
          id(zone7_water_used) = 0;
          id(zone8_water_used) = 0;
          
          // Reset total
          id(total_water_used) = 0;
          
          // Set reset timestamp
          id(water_usage_reset_time) = id(homeassistant_time).now().timestamp;
          
          ESP_LOGI("irrigation", "âœ… All water usage counters reset to 0 L");
          ESP_LOGI("irrigation", "");

  - platform: template
    name: "$dev1_zone1 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone1_water_used);
          id(total_water_used) -= previous;
          id(zone1_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 1 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));

  - platform: template
    name: "$dev1_zone2 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone2_water_used);
          id(total_water_used) -= previous;
          id(zone2_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 2 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));

  - platform: template
    name: "$dev1_zone3 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone3_water_used);
          id(total_water_used) -= previous;
          id(zone3_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 3 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));

  - platform: template
    name: "$dev1_zone4 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone4_water_used);
          id(total_water_used) -= previous;
          id(zone4_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 4 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));

  - platform: template
    name: "$dev1_zone5 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone5_water_used);
          id(total_water_used) -= previous;
          id(zone5_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 5 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));

  - platform: template
    name: "$dev1_zone6 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone6_water_used);
          id(total_water_used) -= previous;
          id(zone6_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 6 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));

  - platform: template
    name: "$dev1_zone7 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone7_water_used);
          id(total_water_used) -= previous;
          id(zone7_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 7 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));

  - platform: template
    name: "$dev1_zone8 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone8_water_used);
          id(total_water_used) -= previous;
          id(zone8_water_used) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 8 water usage reset (was %.1f L) - System total now: %.1f L", previous, id(total_water_used));
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYSTEM DIAGNOSTICS (Production Feature)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "$dev1_what Run System Diagnostics"
    icon: "mdi:doctor"
    on_press:
      - lambda: |-
          // Enter test mode to prevent watchdog interference
          id(test_mode_active) = true;
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ SYSTEM DIAGNOSTICS STARTED");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "(Watchdog auto-control disabled during tests)");
          ESP_LOGI("irrigation", "");
          
          int tests_passed = 0;
          int tests_failed = 0;
          int warnings = 0;
          
          // TEST 1: Time Synchronization
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 1: Time Synchronization");
          auto time = id(homeassistant_time).now();
          if (time.is_valid()) {
            ESP_LOGI("irrigation", "   âœ… PASS - Time synced: %d/%d/%d %d:%02d", 
                     time.day_of_month, time.month, time.year, time.hour, time.minute);
            tests_passed++;
          } else {
            ESP_LOGE("irrigation", "   âŒ FAIL - Time not synchronized");
            tests_failed++;
          }
          
          // TEST 2: Weather Sensors
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 2: Weather Sensors");
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          
          int sensor_failures = 0;
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "   âš ï¸ Temperature sensor unavailable");
            sensor_failures++;
          } else {
            ESP_LOGI("irrigation", "   âœ… Temperature: %.1fÂ°C", temp);
          }
          
          if (isnan(humidity)) {
            ESP_LOGW("irrigation", "   âš ï¸ Humidity sensor unavailable");
            sensor_failures++;
          } else {
            ESP_LOGI("irrigation", "   âœ… Humidity: %.1f%%", humidity);
          }
          
          if (isnan(wind)) {
            ESP_LOGW("irrigation", "   âš ï¸ Wind sensor unavailable");
            sensor_failures++;
          } else {
            ESP_LOGI("irrigation", "   âœ… Wind: %.1f km/h", wind);
          }
          
          if (sensor_failures == 0) {
            ESP_LOGI("irrigation", "   âœ… PASS - All weather sensors operational");
            tests_passed++;
          } else if (sensor_failures < 3) {
            ESP_LOGW("irrigation", "   âš ï¸ PARTIAL - %d/3 sensors unavailable", sensor_failures);
            tests_passed++;
            warnings++;
          } else {
            ESP_LOGE("irrigation", "   âŒ FAIL - All weather sensors offline");
            tests_failed++;
          }
          
          // TEST 3: Master Valve (if enabled)
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 3: Master Valve");
          if (!id(master_valve_enabled)) {
            ESP_LOGI("irrigation", "   â„¹ï¸ SKIP - Master valve not enabled");
          } else {
            ESP_LOGI("irrigation", "   Testing master valve (3 second test)...");
            
            // Open valve
            id(master_valve_relay).turn_on();
            ESP_LOGI("irrigation", "   â†’ Valve opened");
            
            // Wait 3 seconds
            delay(3000);
            
            // Close valve
            id(master_valve_relay).turn_off();
            ESP_LOGI("irrigation", "   â†’ Valve closed");
            
            ESP_LOGI("irrigation", "   âœ… PASS - Master valve test complete");
            tests_passed++;
          }
          
          // TEST 4: Zone Configuration
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 4: Zone Configuration");
          
          int zones_enabled = 0;
          for (int zone = 0; zone < 8; zone++) {
            bool enabled = false;
            switch(zone) {
              case 0: enabled = id(zone1_enable).state; break;
              case 1: enabled = id(zone2_enable).state; break;
              case 2: enabled = id(zone3_enable).state; break;
              case 3: enabled = id(zone4_enable).state; break;
              case 4: enabled = id(zone5_enable).state; break;
              case 5: enabled = id(zone6_enable).state; break;
              case 6: enabled = id(zone7_enable).state; break;
              case 7: enabled = id(zone8_enable).state; break;
            }
            
            if (enabled) {
              zones_enabled++;
              
              // Get zone name
              std::string zone_name = "Zone " + std::to_string(zone + 1);
              switch(zone) {
                case 0: zone_name = id(zone1_name).state; break;
                case 1: zone_name = id(zone2_name).state; break;
                case 2: zone_name = id(zone3_name).state; break;
                case 3: zone_name = id(zone4_name).state; break;
                case 4: zone_name = id(zone5_name).state; break;
                case 5: zone_name = id(zone6_name).state; break;
                case 6: zone_name = id(zone7_name).state; break;
                case 7: zone_name = id(zone8_name).state; break;
              }
              
              ESP_LOGI("irrigation", "   âœ… Zone %d: %s (ENABLED)", zone + 1, zone_name.c_str());
            }
          }
          
          if (zones_enabled == 0) {
            ESP_LOGW("irrigation", "   âš ï¸ WARNING: No zones enabled!");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "   âœ… PASS - %d zones enabled", zones_enabled);
            tests_passed++;
          }
          
          ESP_LOGI("irrigation", "   â„¹ï¸ NOTE: Use individual zone buttons to test valves manually");
          
          // TEST 5: System Configuration
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 5: System Configuration");
          ESP_LOGI("irrigation", "   Predictive Watering: %s", id(predictive_watering_enabled) ? "ENABLED" : "Disabled");
          ESP_LOGI("irrigation", "   Smart ET: %s", id(smart_et_enabled) ? "ENABLED" : "Disabled");
          ESP_LOGI("irrigation", "   Freeze Protection: %s (threshold: %.1fÂ°C)", 
                   id(freeze_protection_active) ? "ACTIVE" : "Inactive", id(freeze_threshold));
          ESP_LOGI("irrigation", "   Water Budget: %.1f / %.1f L (%.1f%%)",
                   id(current_month_usage), id(monthly_water_budget),
                   (id(current_month_usage) / id(monthly_water_budget)) * 100.0);
          ESP_LOGI("irrigation", "   âœ… PASS - Configuration valid");
          tests_passed++;
          
          // TEST 6: Memory & Performance
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 6: System Resources");
          ESP_LOGI("irrigation", "   Queue: %d/3 slots used", id(queue_count));
          ESP_LOGI("irrigation", "   Network: %s", id(network_offline_mode) ? "OFFLINE MODE" : "Online");
          ESP_LOGI("irrigation", "   âœ… PASS - Resources normal");
          tests_passed++;
          
          // FINAL REPORT
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ DIAGNOSTICS COMPLETE");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ“Š Results:");
          ESP_LOGI("irrigation", "   Tests Passed: %d", tests_passed);
          ESP_LOGI("irrigation", "   Tests Failed: %d", tests_failed);
          ESP_LOGI("irrigation", "   Warnings: %d", warnings);
          
          if (tests_failed == 0 && warnings == 0) {
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "   âœ…âœ…âœ… ALL SYSTEMS OPERATIONAL âœ…âœ…âœ…");
          } else if (tests_failed == 0) {
            ESP_LOGW("irrigation", "");
            ESP_LOGW("irrigation", "   âš ï¸ OPERATIONAL WITH WARNINGS");
          } else {
            ESP_LOGE("irrigation", "");
            ESP_LOGE("irrigation", "   âŒ CRITICAL ISSUES DETECTED");
          }
          
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "");
          
          // Exit test mode - re-enable watchdog
          id(test_mode_active) = false;
