substitutions:
  # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  # â•‘          DEVICE CONFIGURATION â€” EDIT THESE FIRST         â•‘
  # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ESPHome device name (lowercase, hyphens only â€” used in URL/MQTT)
  esphome_name:          "irrigation"
  # Friendly name shown in Home Assistant UI
  esphome_friendly_name: "Irrigation Controller"
  # Board type â€” esp32dev for standard ESP32, esp32-s3-devkitc-1 for S3
  esphome_board:         "esp32dev"
  # Short description shown in ESPHome dashboard
  esphome_comment:       "Irrigation Control System"
  # Project metadata
  esphome_project_name:  "RP.Irrigation Control System"
  # Logging level: none, error, warn, info, debug, verbose, very_verbose
  log_level:             "info"
  # Unit of measure for zone run durations shown in HA (Min or sec)
  uom:                   "Min"
  # Software version (bumped when NVS-affecting globals change)
  software_revision:     "V3.40-ALL-SETTINGS-PERSIST"
  # Integer version for NVS validation â€” increment when adding/removing restore_value globals
  software_version_int:  "340"
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  dev1_what: Lawn
  devicename1: ${dev1_what}_irrigation_controller
  upper_devicename1: "${dev1_what} Irrigation Controller"
  dev1_zone1: Lawn Zone1
  dev1_zone2: Lawn Zone2
  dev1_zone3: Lawn Zone3
  dev1_zone4: Lawn Zone4
  dev1_zone5: Lawn Zone5
  dev1_zone6: Lawn Zone6
  dev1_zone7: Lawn Zone7
  dev1_zone8: Lawn Zone8
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PROGRAM NAMES (Change these to customize throughout the UI!)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # These names appear EVERYWHERE in Home Assistant
  # Examples: "Front Lawn", "Back Garden", "Vegetable Beds"
  # Following Hunter Pro-C display format: Program 1, Program 2, Program 3
  program_a_name: "Program 1"
  program_b_name: "Program 2"  
  program_c_name: "Program 3"
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # GPIO PIN ASSIGNMENTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Change these to match your wiring - all in one place!
  master_valve_pin: GPIO27  # Master valve control (like Hunter Pro-C)
  zone1_pin: GPIO13         # Zone 1 valve control
  zone2_pin: GPIO33         # Zone 2 valve control
  zone3_pin: GPIO04         # Zone 3 valve control
  zone4_pin: GPIO14         # Zone 4 valve control
  zone5_pin: GPIO16         # Zone 5 valve control
  zone6_pin: GPIO32         # Zone 6 valve control
  zone7_pin: GPIO25         # Zone 7 valve control
  zone8_pin: GPIO26         # Zone 8 valve control
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FLOW SENSOR â€” USER CONFIGURATION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Sensor:  YF-B5  (Copper G3/4 DN20, Hall effect, 1-30 L/min)
  # Wiring:  VCC=5V  GND=GND  Signal=flow_sensor_pin
  # Counter: use_pcnt=true (hardware PCNT â€” counts in silicon,
  #          immune to CPU load). internal_filter=13us is the
  #          maximum PCNT allows; blocks EMI spikes which are
  #          <1us. Real YF-B5 pulses are >5ms at any flow rate.
  #
  # HOW TO CALIBRATE (bucket test):
  #   1. Run a zone into a container of known volume
  #   2. Compare ESPHome "Flow Session Volume" to actual litres
  #   3. new_PPL = old_PPL x (sensor_reading / actual_litres)
  #   Example: old=396, sensor=3.57L, actual=5.1L -> 396x(3.57/5.1)=277
  #
  # COMMON SENSORS          Datasheet PPL   Notes
  # YF-S201 (plastic G1/2)     450         1-30 L/min
  # YF-B5   (copper G3/4)      396         1-30 L/min  <- this system
  # FS300A  (plastic G1)        330         1-60 L/min
  # Reed meter 1L/pulse           1         Most accurate, no calibration
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  flow_sensor_pin:                "GPIO18" # Signal pin (has internal pull-up, no resistor needed)
  flow_sensor_pulses_per_litre:   "277"    # Calibrated PPL. Recalibrate with bucket test after install
  flow_sensor_update_interval:    "1s"     # Sensor tick rate â€” do not change (math depends on this)
  flow_sensor_leak_threshold_lpm: "0.5"    # L/min to consider a leak when no zone is active
  flow_sensor_leak_grace_ticks:   "3"      # Ticks above threshold before alert fires (3 ticks = ~3s)
  flow_sensor_post_stop_cooldown: "15"     # Seconds after zone stops before leak detection re-enables
  flow_sensor_post_start_settle:  "5"      # Seconds after zone starts before leak detection enables
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # HOME ASSISTANT ENTITY REFERENCES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Change these to match your Home Assistant entity names
  #
  # ALERTS: Create this helper in HA before deploying:
  #   Settings â†’ Helpers â†’ Create Helper â†’ Text â†’ Name: "Irrigation Latest Alert"
  #   This creates input_text.irrigation_latest_alert
  #   HA automations can trigger on state_changed for this entity.
  ha_alert_entity: input_text.irrigation_latest_alert  # Persistent HA alert target

  ha_weather_entity: weather.home             # Weather state entity (sunny/rainy etc.)
  ha_weather_forecast_entity: weather.home    # Forecast entity (humidity)
  ha_rain_probability_entity: sensor.home_rain_forecast_0d
  ha_rain_forecast_1h_entity: sensor.home_rain_forecast_1h

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NZ PUBLIC HOLIDAY ENTITY IDs (from Home Assistant)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Date strings (YYYY-MM-DD format)
  ha_good_friday_date:      sensor.nz_good_friday_date
  ha_easter_monday_date:    sensor.nz_easter_monday_date
  ha_kings_birthday_date:   sensor.nz_kings_birthday_date
  ha_labour_day_date:       sensor.nz_labour_day_date
  ha_matariki_date:         sensor.nz_matariki_date
  # Timestamp strings (ISO 8601 format)
  ha_good_friday_ts:        sensor.nz_good_friday_timestamp
  ha_easter_monday_ts:      sensor.nz_easter_monday_timestamp
  ha_kings_birthday_ts:     sensor.nz_kings_birthday_timestamp
  ha_matariki_ts:           sensor.nz_matariki_timestamp
  ha_labour_day_ts:         sensor.nz_labour_day_timestamp

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # TIME CONSTANTS (Seconds) - Used Throughout Code
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  seconds_per_day: 86400      # 24 hours Ã— 60 min Ã— 60 sec
  seconds_per_hour: 3600      # 60 minutes Ã— 60 seconds
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SEASONAL WATERING MULTIPLIERS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Adjust these values to tune seasonal watering for your climate
  # Southern Hemisphere seasons: Summer (Dec-Feb), Winter (Jun-Aug)
  
  # SUMMER SETTINGS (December - February)
  summer_base_multiplier: "1.3"      # Base watering level for summer
  summer_hot_temp_c: "25"            # Temperature threshold for hot days
  summer_hot_multiplier: "1.6"       # Increased watering on hot days
  summer_very_hot_temp_c: "30"       # Temperature threshold for very hot days  
  summer_very_hot_multiplier: "1.8"  # Maximum watering on very hot days
  
  # WINTER SETTINGS (June - August)
  winter_base_multiplier: "0.5"      # Base watering level for winter
  winter_cold_temp_c: "10"           # Temperature threshold for cold days
  winter_cold_multiplier: "0.3"      # Reduced watering on cold days
  
  # SPRING/AUTUMN SETTINGS (March-May, September-November)
  spring_autumn_base_multiplier: "0.8"       # Base watering for transitional seasons
  spring_autumn_warm_temp_c: "20"            # Temperature threshold for warm days
  spring_autumn_warm_multiplier: "1.0"       # Normal watering on warm days
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # RAIN FORECAST THRESHOLDS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # When to automatically clear rain delays (weather has improved)
  rain_clear_threshold_1h_mm: "0.5"   # Clear delay if < 0.5mm rain in next hour
  rain_clear_threshold_day_mm: "1.0"  # Clear delay if < 1.0mm rain today
  
  # When to automatically SET rain delays (heavy rain forecast)
  # Note: auto-delay threshold is set via default_forecast_high_mm
  
  # Threshold to flag forecast_rain_detected (display/HA indicator only)
  rain_detect_threshold_1h_mm:  "1.0"  # Flag rain if >= this much forecast in 1h
  rain_detect_threshold_day_mm: "3.0"  # Flag rain if >= this much forecast today
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DEFAULT ZONE SETTINGS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  default_zone_flow_rate_lpm: "15.0"  # Default flow rate (Liters Per Minute)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CYCLE & SOAK DEFAULTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Cycle: Run time, Soak: Wait time (prevents runoff on slopes/clay soil)
  default_cycle_duration_min: "10"    # Minutes to run per cycle
  default_soak_duration_min: "10"     # Minutes to soak between cycles
  default_station_delay_sec: "5"      # Seconds delay between zone switches

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYSTEM PROTECTION THRESHOLDS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  freeze_recovery_offset_c:   "3.0"   # Resume watering when temp rises this many Â°C above freeze threshold
  budget_warning_pct:         "80.0"  # Warn when monthly water usage exceeds this % of budget
  auto_rain_delay_days:       "2"     # Days to delay watering when rain detected
  max_nvs_total_water_l:      "10000000.0"  # NVS sanity limit: 10 million litres total
  max_nvs_zone_water_l:       "2000000.0"   # NVS sanity limit: 2 million litres per zone

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYSTEM DEFAULTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  default_freeze_threshold_c:       "2.0"    # Initial freeze protection temperature
  default_monthly_budget_l:         "10000.0" # Monthly water budget (litres)
  default_max_zone_runtime_min:     "60"     # Maximum minutes per zone per day
  default_stop_restart_delay_sec:   "8"      # Seconds between zone stop and next start
  default_valve_open_delay_sec:     "2"      # ESPHome sprinkler inter-zone delay (seconds)
  default_forecast_significant_mm:  "3.0"    # Rain forecast (mm) that triggers watering skip
  default_forecast_high_mm:         "10.0"   # Rain forecast (mm) that triggers auto rain delay

  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATERING WINDOW DEFAULTS (24-hour format)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Window 1: Early Morning (BEST - minimal evaporation, wind, heat)
  default_window1_start_hour: "5"     # 5:00 AM
  default_window1_end_hour: "9"       # 9:00 AM
  
  # Window 2: Evening (GOOD - cooler than midday, allows overnight drying)
  default_window2_start_hour: "18"    # 6:00 PM
  default_window2_end_hour: "21"      # 9:00 PM
  
  # Window 3: Optional (disabled by default)
  default_window3_start_hour: "14"    # 2:00 PM
  default_window3_end_hour: "17"      # 5:00 PM
  
  # Time Restriction (blocks midday watering to prevent evaporation loss)
  # Both values in 12-hour format (AM/PM set separately in globals)
  default_time_restriction_start_hour: "10"  # 10 AM start (restrict midday)
  default_time_restriction_end_hour: "6"     # 6 PM end (allow evening watering)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SMART ET (Evapotranspiration) DEFAULTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  default_et_threshold_mm: "25.0"     # Soil water deficit trigger (millimeters)
  max_et_multiplier: "2.0"            # Maximum watering multiplier (200%)
  min_et_multiplier: "1.0"            # Minimum watering multiplier (100%)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # LIVE SENSOR UPDATE RATES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  sensor_update_frequency: 1s       # How often Time Remaining and Progress % update in HA
  sensor_hourly_update: 3600s       # Slow sensors (board type, seasonal multiplier)

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # TESTING & DIAGNOSTICS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  test_master_valve_sec: "10"         # Master valve test duration (seconds)
  test_zone_sec: "3"                  # Individual zone test duration (seconds)
  default_quick_run_min: "5"          # Default quick-run duration shown in HA (minutes)
  # Note: pause watchdog timeout is ${seconds_per_day} (24h) â€” see 30s watchdog interval
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PROGRAM START TIME DEFAULTS (24-hour format)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Program default start hours â€” 12-hour format (AM/PM set by program_X_am_pm global)
  default_program_a_start_hour: "6"   # Program 1: 6 AM
  default_program_b_start_hour: "6"   # Program 2: 6 AM (set PM via am_pm global)
  default_program_c_start_hour: "6"   # Program 3: 6 AM
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ZONE DURATION OVERRIDES (0 = use zone's default duration)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # These allow different programs to water zones for different durations

  # Set to 0 to use the zone's configured default duration
  # Set to any value 1-90 to override for that specific program
  
  # Program 1 Zone Overrides (minutes)
  default_zone1_program_a_duration: "0"  # 0 = use Zone 1 default
  default_zone2_program_a_duration: "0"
  default_zone3_program_a_duration: "0"
  default_zone4_program_a_duration: "0"
  default_zone5_program_a_duration: "0"
  default_zone6_program_a_duration: "0"
  default_zone7_program_a_duration: "0"
  default_zone8_program_a_duration: "0"
  
  # Program 2 Zone Overrides (minutes)
  default_zone1_program_b_duration: "0"  # 0 = use Zone 1 default
  default_zone2_program_b_duration: "0"
  default_zone3_program_b_duration: "0"
  default_zone4_program_b_duration: "0"
  default_zone5_program_b_duration: "0"
  default_zone6_program_b_duration: "0"
  default_zone7_program_b_duration: "0"
  default_zone8_program_b_duration: "0"
  
  # Program 3 Zone Overrides (minutes)
  default_zone1_program_c_duration: "0"  # 0 = use Zone 1 default
  default_zone2_program_c_duration: "0"
  default_zone3_program_c_duration: "0"
  default_zone4_program_c_duration: "0"
  default_zone5_program_c_duration: "0"
  default_zone6_program_c_duration: "0"
  default_zone7_program_c_duration: "0"
  default_zone8_program_c_duration: "0"

  
  

esphome:
  name: ${esphome_name}
  comment: ${esphome_comment}
  friendly_name: ${esphome_friendly_name}
  project:
    name: ${esphome_project_name}
    version: "ICS, ${software_revision}"
  on_boot:
    # â”€â”€ NORMAL PRIORITY: System initialisation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Note: relay click on first zone activation is prevented by the zone template
    # switches' turn_on_action guard (only fires GPIO when irrigation_busy=true).
    # No early sprinkler.shutdown needed â€” output pins never toggle without the guard.
    - priority: -100
      then:
      # Set default state for Valve Status
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      # reset multiplier at reboot
      - lambda: |-
          // === 3-ITEM QUEUE SYSTEM INITIALIZATION ===
            auto now = id(homeassistant_time).now();
            id(irrigation_busy) = false;
            id(in_program_run) = false;
            
            // Initialize queue arrays
            id(queue_count) = 0;
            for (int i = 0; i < 3; i++) {
              id(queue_types)[i] = 0;
              id(queue_programs)[i] = 0;
              id(queue_zones)[i] = 0;
              id(queue_durations)[i] = 0;
              id(queue_add_delays)[i] = false;
              id(queue_trigger_sources)[i] = "";
            }
            ESP_LOGI("irrigation", "ğŸ”„ BOOT: 3-slot queue initialized (Hunter Pro-C style)");
            
            // Initialize Predictive Watering variables
            id(pw_last_calculation_time) = 0;
            id(pw_current_multiplier) = 1.0;
            ESP_LOGI("irrigation", "ğŸ’§ Predictive Wateringâ„¢ system initialized");

            // â”€â”€ Flow sensor: explicit zero on boot to prevent stale display â”€â”€
            id(flow_sensor_session_litres) = 0.0f;
            id(flow_sensor_current_lpm)    = 0.0f;
            id(flow_sensor_leak_detected)  = false;
            id(zone_flow_active)           = false;
            id(flow_zone_start_pulses)     = 0.0f;
            id(flow_pulse_total)           = 0.0f;
            ESP_LOGI("flow", "Flow sensor state cleared on boot");
            
            // Initialize Smart ET variables
            id(et_last_calculation_time) = 0;
            id(et_pending_irrigation) = false;
            ESP_LOGI("irrigation", "ğŸŒ± Smart ET Watering system initialized");
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NVS CORRUPTION DETECTION & VERSION VALIDATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Prevents corrupted flash values from causing issues
            // Resets data on version changes to ensure clean state
            
            const int CURRENT_VERSION = ${software_version_int};  // Bump software_version_int substitution when changing NVS globals
            
            // â”€â”€ THREE INDEPENDENT FLAGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // needs_version_update  : firmware changed â†’ update stamp only, data untouched
            // needs_monthly_reset   : new calendar month â†’ reset THIS month's budget only
            //                         total_water_litres and zone totals are LIFETIME counters
            //                         and are NEVER cleared by a month rollover
            // needs_corruption_wipe : NVS garbage detected â†’ wipe everything as last resort
            //
            // NOTHING wipes water history on a normal reboot or firmware flash.
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            bool needs_version_update  = false;
            bool needs_monthly_reset   = false;
            bool needs_corruption_wipe = false;
            std::string reset_reason   = "";

            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ” NVS Validation Check...");

            // CHECK 1: Firmware version change â†’ stamp update only, no data wipe
            if (id(stored_software_version) != CURRENT_VERSION) {
              if (id(stored_software_version) == 0) {
                ESP_LOGI("irrigation", "ğŸ†• First boot / NVS empty â€” initialising version stamp");
              } else {
                ESP_LOGI("irrigation", "â¬†ï¸  Firmware v%d â†’ v%d â€” water history fully preserved",
                         id(stored_software_version), CURRENT_VERSION);
              }
              needs_version_update = true;
            }

            // CHECK 2: Corruption â€” current_month_usage
            if (!needs_corruption_wipe) {
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage))) {
                reset_reason = "NaN/Inf in current_month_usage";
                needs_corruption_wipe = true;
              } else if (id(current_month_usage) < 0.0f || id(current_month_usage) > 1000000.0f) {
                reset_reason = "Out-of-range current_month_usage: " + std::to_string(id(current_month_usage));
                needs_corruption_wipe = true;
              }
              if (needs_corruption_wipe) {
                id(nvs_corruption_detected) = true;
                ESP_LOGE("irrigation", "âŒ CORRUPTION: %s", reset_reason.c_str());
              }
            }

            // CHECK 2b: Corruption â€” total and per-zone lifetime water used
            if (!needs_corruption_wipe) {
              const float MAX_TOTAL_WATER = ${max_nvs_total_water_l}f;
              const float MAX_ZONE_WATER  = ${max_nvs_zone_water_l}f;
              std::string corrupt_field = "";

              auto check_water = [](float v, float max_v) -> bool {
                return isnan(v) || std::isinf(v) || v < 0.0f || v > max_v;
              };

              if      (check_water(id(total_water_litres), MAX_TOTAL_WATER)) { corrupt_field = "total_water_litres="  + std::to_string(id(total_water_litres)); }
              else if (check_water(id(zone1_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone1_water_litres="  + std::to_string(id(zone1_water_litres)); }
              else if (check_water(id(zone2_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone2_water_litres="  + std::to_string(id(zone2_water_litres)); }
              else if (check_water(id(zone3_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone3_water_litres="  + std::to_string(id(zone3_water_litres)); }
              else if (check_water(id(zone4_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone4_water_litres="  + std::to_string(id(zone4_water_litres)); }
              else if (check_water(id(zone5_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone5_water_litres="  + std::to_string(id(zone5_water_litres)); }
              else if (check_water(id(zone6_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone6_water_litres="  + std::to_string(id(zone6_water_litres)); }
              else if (check_water(id(zone7_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone7_water_litres="  + std::to_string(id(zone7_water_litres)); }
              else if (check_water(id(zone8_water_litres), MAX_ZONE_WATER))  { corrupt_field = "zone8_water_litres="  + std::to_string(id(zone8_water_litres)); }

              if (!corrupt_field.empty()) {
                reset_reason = "Corrupted NVS value: " + corrupt_field;
                needs_corruption_wipe = true;
                id(nvs_corruption_detected) = true;
                ESP_LOGE("irrigation", "âŒ CORRUPTION: %s", reset_reason.c_str());
              }
            }

            // CHECK 2c: max_zone_runtime_daily â€” fix silently, no reset needed
            if (id(max_zone_runtime_daily) <= 0 || id(max_zone_runtime_daily) > 1440) {
              ESP_LOGW("irrigation", "âš ï¸ max_zone_runtime_daily invalid (%d) â€” resetting to %d min",
                       id(max_zone_runtime_daily), ${default_max_zone_runtime_min});
              id(max_zone_runtime_daily) = ${default_max_zone_runtime_min};
            }

            // CHECK 3: New calendar month â†’ reset THIS month's budget counter only
            // last_reset_month == 0 means NVS was never written (first boot) â€” skip reset,
            // just record the current month so we don't falsely trigger next boot.
            if (!needs_corruption_wipe && !needs_monthly_reset) {
              if (now.is_valid()) {
                int current_month = now.month;
                if (id(last_reset_month) == 0) {
                  // First valid time sync â€” record month without wiping anything
                  id(last_reset_month) = current_month;
                  ESP_LOGI("irrigation", "ğŸ“… Month initialised to %d (no reset)", current_month);
                } else if (id(last_reset_month) != current_month) {
                  needs_monthly_reset = true;
                  reset_reason = "New month (was " + std::to_string(id(last_reset_month)) + ", now " + std::to_string(current_month) + ")";
                  ESP_LOGI("irrigation", "ğŸ“… %s", reset_reason.c_str());
                }
              }
            }

            // â”€â”€ ACTION 1: Version stamp update (never touches data) â”€â”€â”€â”€â”€â”€â”€
            if (needs_version_update) {
              id(stored_software_version) = CURRENT_VERSION;
              ESP_LOGI("irrigation", "âœ… Version stamp updated to %d", CURRENT_VERSION);
            }

            // Record outcome in global so HA sensor shows it after boot
            char _nvs_buf[120];

            // â”€â”€ ACTION 2: Monthly budget reset (THIS month only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // total_water_litres and zone totals are LIFETIME â€” never reset here.
            if (needs_monthly_reset) {
              float old_usage = id(current_month_usage);
              id(current_month_usage) = 0.0f;
              id(budget_warning_sent) = false;
              id(budget_exceeded)     = false;
              // Reuse time if already valid from CHECK 3 above, else re-read (rare path)
              if (now.is_valid()) id(last_reset_month) = now.month;
              ESP_LOGI("irrigation", "ğŸ“… Monthly budget reset (was %.1fL) â€” lifetime totals kept", old_usage);
            }

            // â”€â”€ ACTION 3: Full corruption wipe (last resort only) â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (needs_corruption_wipe) {
              float old_usage = id(current_month_usage);
              ESP_LOGE("irrigation", "ğŸ”„ CORRUPTION WIPE â€” reason: %s", reset_reason.c_str());
              id(current_month_usage) = 0.0f;
              id(total_water_litres)    = 0.0f;
              id(zone1_water_litres)    = 0.0f;
              id(zone2_water_litres)    = 0.0f;
              id(zone3_water_litres)    = 0.0f;
              id(zone4_water_litres)    = 0.0f;
              id(zone5_water_litres)    = 0.0f;
              id(zone6_water_litres)    = 0.0f;
              id(zone7_water_litres)    = 0.0f;
              id(zone8_water_litres)    = 0.0f;
              id(budget_warning_sent) = false;
              id(budget_exceeded)     = false;
              // Reuse time from earlier in this lambda
              if (now.is_valid()) id(last_reset_month) = now.month;
              // Force immediate NVS flush â€” without this the corrected zeros
              // are never written back and the garbage value survives the next reboot.
              global_preferences->sync();
              ESP_LOGE("irrigation", "âŒ All water counters wiped and flushed to NVS (was %.1fL)", old_usage);
            }

            if (!needs_version_update && !needs_monthly_reset && !needs_corruption_wipe) {
              ESP_LOGI("irrigation", "âœ… NVS OK â€” no changes (usage: %.1fL / %.1fL)",
                       id(current_month_usage), id(monthly_water_budget));
              snprintf(_nvs_buf, sizeof(_nvs_buf), "OK â€” v%d, usage: %.2fL",
                       CURRENT_VERSION, id(current_month_usage));
            } else {
              if (needs_corruption_wipe) {
                snprintf(_nvs_buf, sizeof(_nvs_buf), "CORRUPTION WIPE: %s", reset_reason.c_str());
              } else if (needs_monthly_reset) {
                snprintf(_nvs_buf, sizeof(_nvs_buf), "Monthly reset%s",
                         needs_version_update ? " + version updated" : "");
              } else {
                snprintf(_nvs_buf, sizeof(_nvs_buf), "Version updated v%d", CURRENT_VERSION);
              }
            }
            id(last_boot_nvs_action) = std::string(_nvs_buf);
            ESP_LOGI("irrigation", "");

      - sprinkler.set_multiplier:
          id: $devicename1
          multiplier: 1
# Set smart multiplier on boot based on temperature and season

      - lambda: |-
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // HELPER: Seasonal Multiplier Calculation (DRY Principle)
          // Calculates watering multiplier based on month and temperature
          // Uses substitutions for easy tuning - see top of file
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          auto calculate_seasonal_multiplier = [](int month, float temp) -> float {
            float multiplier = 1.0;
            
            // Summer (Dec-Feb in Southern Hemisphere)
            if (month >= 12 || month <= 2) {
              multiplier = ${summer_base_multiplier};
              if (temp > ${summer_hot_temp_c}) multiplier = ${summer_hot_multiplier};
              if (temp > ${summer_very_hot_temp_c}) multiplier = ${summer_very_hot_multiplier};
            } 
            // Winter (Jun-Aug in Southern Hemisphere)
            else if (month >= 6 && month <= 8) {
              multiplier = ${winter_base_multiplier};
              if (temp < ${winter_cold_temp_c}) multiplier = ${winter_cold_multiplier};
            } 
            // Spring/Autumn (Mar-May, Sep-Nov)
            else {
              multiplier = ${spring_autumn_base_multiplier};
              if (temp > ${spring_autumn_warm_temp_c}) multiplier = ${spring_autumn_warm_multiplier};
            }
            
            return multiplier;
          };
          
          // Get current time and temperature
          auto now = id(homeassistant_time).now();
          if (!now.is_valid()) {
            ESP_LOGW("irrigation", "Time not synchronized yet - will retry in 30s");
            return;
          }
          
          float temp = id(outside_temperature).state;
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
            temp = 20.0;
          }
          
          // Calculate and apply multiplier using helper function
          // Honour vacation mode 50% reduction if active on boot
          float multiplier = calculate_seasonal_multiplier(now.month, temp);
          float boot_final = id(vacation_mode_active) ? multiplier * 0.5f : multiplier;
          id($devicename1).set_multiplier(boot_final);
          if (id(vacation_mode_active)) {
            id(normal_multiplier) = multiplier;  // Save undiscounted for vacation exit
            ESP_LOGI("irrigation", "Boot multiplier %.1f Ã— 0.5 (vacation) = %.1f", multiplier, boot_final);
          } else {
            ESP_LOGI("irrigation", "Boot multiplier set to %.1f (temp: %.1fÂ°C)", boot_final, temp);
          }
      
      # Retry multiplier setup if time wasn't synced on first attempt
      - delay: 30s
      - lambda: |-
          // Retry multiplier setup if first attempt skipped due to time not synced.
          // Guard: static flag ensures we only ever apply the boot multiplier ONCE.
          // The previous check (multiplier != 1.0) was a flawed proxy â€” 1.0 is a
          // legitimate computed value (spring/autumn + warm), causing a false retry.
          static bool boot_multiplier_applied = false;
          if (boot_multiplier_applied) {
            ESP_LOGI("irrigation", "Boot multiplier already applied - skipping retry");
            return;
          }
          // Also skip if first attempt already set a non-default value
          if (fabsf(id($devicename1).multiplier() - 1.0f) > 0.001f) {
            ESP_LOGI("irrigation", "Multiplier already set to %.1f - skipping retry",
                     id($devicename1).multiplier());
            boot_multiplier_applied = true;
            return;
          }
          
          // Re-define helper (lambda scope limitation - can't persist between blocks)
          auto calculate_seasonal_multiplier = [](int month, float temp) -> float {
            float multiplier = 1.0;
            if (month >= 12 || month <= 2) {
              multiplier = ${summer_base_multiplier};
              if (temp > ${summer_hot_temp_c}) multiplier = ${summer_hot_multiplier};
              if (temp > ${summer_very_hot_temp_c}) multiplier = ${summer_very_hot_multiplier};
            } else if (month >= 6 && month <= 8) {
              multiplier = ${winter_base_multiplier};
              if (temp < ${winter_cold_temp_c}) multiplier = ${winter_cold_multiplier};
            } else {
              multiplier = ${spring_autumn_base_multiplier};
              if (temp > ${spring_autumn_warm_temp_c}) multiplier = ${spring_autumn_warm_multiplier};
            }
            return multiplier;
          };
          
          auto now = id(homeassistant_time).now();
          if (!now.is_valid()) {
            ESP_LOGW("irrigation", "Time still not synchronized after 30s - will retry at midnight");
            return;
          }
          
          float temp = id(outside_temperature).state;
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
            temp = 20.0;
          }
          
          // Calculate and apply using same helper logic
          // Honour vacation mode 50% reduction if active
          float multiplier = calculate_seasonal_multiplier(now.month, temp);
          float retry_final = id(vacation_mode_active) ? multiplier * 0.5f : multiplier;
          id($devicename1).set_multiplier(retry_final);
          if (id(vacation_mode_active)) id(normal_multiplier) = multiplier;
          ESP_LOGI("irrigation", "RETRY: Boot multiplier set to %.1f%s (temp: %.1fÂ°C)",
                   retry_final, id(vacation_mode_active) ? " (Ã—0.5 vacation)" : "", temp);
      
      # Update forecast text sensors on boot (after HA connection established)
      # Wait 15s after multiplier setup to ensure:
      # - Home Assistant API is fully connected
      # - Sensor data has been received from HA
      # - First forecast values are available
      # Total boot time: ~45s (30s multiplier delay + 15s sensor delay)
      - delay: 15s
      - lambda: |-
          ESP_LOGI("forecast", "ğŸ”„ BOOT: Updating forecast text sensors (first update)...");
      - component.update: lawn_rain_forecast_summary
      - component.update: lawn_forecast_watering_recommendation
      - lambda: |-
          ESP_LOGI("forecast", "âœ… BOOT: Forecast text sensors updated!");
          ESP_LOGI("forecast", "   Text sensors will now update every 10 minutes automatically");
      
      # Initialize time restriction check
      - delay: 2s
      - script.execute: check_time_restriction
      
      # Initialize Predictive Watering calculation
      - delay: 5s
      - script.execute: calculate_predictive_watering
      
      # Initialize Smart ET calculation
      - delay: 2s
      - script.execute: calculate_smart_et
      
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STARTUP VALIDATION (Production Feature)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - delay: 10s
      - lambda: |-
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ” SYSTEM STARTUP VALIDATION");
          ESP_LOGI("irrigation", "ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          int errors = 0;
          int warnings = 0;
          
          // Check 1: Time Synchronization
          auto now = id(homeassistant_time).now();
          if (!now.is_valid()) {
            ESP_LOGE("irrigation", "âŒ CRITICAL: Time not synchronized!");
            errors++;
          } else {
            ESP_LOGI("irrigation", "âœ… Time synchronized: %d/%d/%d %d:%02d", 
                     now.day_of_month, now.month, now.year, now.hour, now.minute);
          }
          
          // Check 2: Weather Sensors
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "âš ï¸ WARNING: Temperature sensor unavailable");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "âœ… Temperature: %.1fÂ°C", temp);
            
            // Check freeze condition
            if (temp < id(freeze_threshold)) {
              ESP_LOGW("irrigation", "âš ï¸ FREEZE RISK: Temperature below %.1fÂ°C - protection will activate", id(freeze_threshold));
              warnings++;
            }
          }
          
          if (isnan(humidity)) {
            ESP_LOGW("irrigation", "âš ï¸ WARNING: Humidity sensor unavailable");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "âœ… Humidity: %.1f%%", humidity);
          }
          
          if (isnan(wind)) {
            ESP_LOGW("irrigation", "âš ï¸ WARNING: Wind sensor unavailable");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "âœ… Wind: %.1f km/h", wind);
          }
          
          // Check 3: Predictive Watering Status
          if (id(predictive_watering_enabled)) {
            ESP_LOGI("irrigation", "âœ… Predictive Watering: ENABLED (multiplier: %.2f)", id(pw_current_multiplier));
          } else {
            ESP_LOGI("irrigation", "â„¹ï¸ Predictive Watering: Disabled");
          }
          
          // Check 4: Smart ET Status
          if (id(smart_et_enabled)) {
            ESP_LOGI("irrigation", "âœ… Smart ET: ENABLED (deficit: %.1fmm)", id(et_soil_moisture_deficit));
          } else {
            ESP_LOGI("irrigation", "â„¹ï¸ Smart ET: Disabled");
          }
          
          // Check 5: Master Valve Configuration
          if (id(master_valve_enabled)) {
            ESP_LOGI("irrigation", "âœ… Master Valve: ENABLED");
          } else {
            ESP_LOGI("irrigation", "â„¹ï¸ Master Valve: Disabled (zones operate independently)");
          }
          
          // Check 6: Rain Delay Status
          // Guard: only meaningful if time is valid â€” timestamp=0 would falsely show delay active
          if (now.is_valid() && id(rain_delay_end_time) > now.timestamp) {
            int64_t remaining = id(rain_delay_end_time) - now.timestamp;
            ESP_LOGI("irrigation", "âš ï¸ Rain Delay ACTIVE: %.1f days remaining", remaining / (float)${seconds_per_day});
            warnings++;
          }
          
          // Check 7: Water Budget Status
          if (id(current_month_usage) > 0) {
            float percent = id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0 : 0.0;
            ESP_LOGI("irrigation", "ğŸ“Š Water Budget: %.1fL / %.1fL (%.1f%%)", 
                     id(current_month_usage), id(monthly_water_budget), percent);
            if (percent > 80) {
              ESP_LOGW("irrigation", "âš ï¸ WARNING: Water budget >${budget_warning_pct}%% used");
              warnings++;
            }
          }
          
          // Check 8: Network Mode
          if (id(network_offline_mode)) {
            ESP_LOGW("irrigation", "âš ï¸ Network: Offline mode active (using fallback multiplier)");
            warnings++;
          }
          
          // Summary
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ VALIDATION SUMMARY:");
          ESP_LOGI("irrigation", "   Errors: %d | Warnings: %d", errors, warnings);
          
          if (errors == 0 && warnings == 0) {
            ESP_LOGI("irrigation", "   âœ… ALL SYSTEMS OPERATIONAL");
          } else if (errors == 0) {
            ESP_LOGI("irrigation", "   âš ï¸ OPERATIONAL WITH WARNINGS");
          } else {
            ESP_LOGE("irrigation", "   âŒ CRITICAL ERRORS DETECTED");
          }
          
          ESP_LOGI("irrigation", "ğŸ” â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "");
      
      # Restore blackout descriptions from text fields on boot
      - lambda: |-
          ESP_LOGI("irrigation", "ğŸ”„ BOOT: Restoring blackout descriptions...");
          std::string texts[10] = {
            id(blackout_date_1_text).state, id(blackout_date_2_text).state,
            id(blackout_date_3_text).state, id(blackout_date_4_text).state,
            id(blackout_date_5_text).state, id(blackout_date_6_text).state,
            id(blackout_date_7_text).state, id(blackout_date_8_text).state,
            id(blackout_date_9_text).state, id(blackout_date_10_text).state
          };
          int restored = 0;
          for (int i = 0; i < 10; i++) {
            std::string text = texts[i];
            if (text.length() >= 10 && text[2] == '-' && text[5] == '-') {
              std::string desc = (text.length() > 11) ? text.substr(11) : "";
              switch(i) {
                case 0: id(blackout_desc_1) = desc; break;
                case 1: id(blackout_desc_2) = desc; break;
                case 2: id(blackout_desc_3) = desc; break;
                case 3: id(blackout_desc_4) = desc; break;
                case 4: id(blackout_desc_5) = desc; break;
                case 5: id(blackout_desc_6) = desc; break;
                case 6: id(blackout_desc_7) = desc; break;
                case 7: id(blackout_desc_8) = desc; break;
                case 8: id(blackout_desc_9) = desc; break;
                case 9: id(blackout_desc_10) = desc; break;
              }
              restored++;
            }
          }
          ESP_LOGI("irrigation", "   %d descriptions restored", restored);
          id(boot_restore_complete) = true;
          ESP_LOGI("irrigation", "âœ… Boot restore complete");
      
esp32:
  board: $esphome_board
  framework:
    type: esp-idf
    sdkconfig_options:
      # â”€â”€ TCP/IP tuning (prevents mobile browser timeouts) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      CONFIG_LWIP_TCP_SND_BUF_DEFAULT: "11440"      # Larger send buffer
      CONFIG_LWIP_TCP_WND_DEFAULT: "11440"           # Larger receive window
      CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: "4096"      # Bigger LwIP task stack
      # â”€â”€ Web server stability â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      CONFIG_HTTPD_MAX_REQ_HDR_LEN: "4096"           # Safari iOS sends 2-4KB headers
      CONFIG_HTTPD_MAX_URI_LEN: "1024"               # Longer URIs from mobile browsers
      CONFIG_HTTPD_MAX_OPEN_SOCKETS: "7"             # ESP32 max (S3 can do 8, ESP32 max is 7)
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "15"            # Prevent WDT during heavy pages
      # â”€â”€ CPU at full 240MHz â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      CONFIG_ESP32_DEFAULT_CPU_FREQ_240: "y"

api:
  encryption:
    key: !secret api_encryption_key
  reboot_timeout: 0s  # Disable reboot on API disconnect - blocking lambdas cause temporary disconnects

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none   # Disable power saving - critical for mobile connection stability
  output_power: 20.0      # Full TX power for reliable connections (plain float dBm â€” no unit suffix)
  fast_connect: true      # Skip full channel scan on boot
  ap:
    ssid: "Irrigation-Controller"
    password: !secret ap_password

captive_portal:

logger:
  level: ${log_level}
  logs:
    text_sensor: WARN

# Enable Web server
web_server:
  port: 80
  version: 2  # v2 retained - v3 has known async_tcp stability issues on mobile browsers

globals:
  - id: boot_restore_complete
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: rain_delay_days
    type: int
    restore_value: True
    initial_value: '0'
  - id: rain_delay_end_time
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'  # Optional feature, off by default
  - id: test_mode_active
    type: bool
    restore_value: False  # Transient state â€” always starts false on boot
    initial_value: 'false'  # True during diagnostics/tests to prevent watchdog interference
  - id: cycle_soak_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: cycle_duration_minutes
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_cycle_duration_min}'
  - id: soak_duration_minutes
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_soak_duration_min}'
  - id: current_cycle
    type: int
    restore_value: False  # Runtime state â€” reset when irrigation starts
    initial_value: '0'
  - id: total_cycles
    type: int
    restore_value: False  # Runtime state â€” reset when irrigation starts
    initial_value: '0'
  - id: active_zone_number
    type: int
    restore_value: False  # Runtime state â€” set during active watering
    initial_value: '-1'

  - id: station_delay_seconds
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_station_delay_sec}'  # Seconds between zone switches

  # ============================================================
  # WATERING TRIGGER TRACKING
  # ============================================================
  # Tracks what triggered the current/last watering session
  - id: irrigation_latest_alert
    type: std::string
    restore_value: False  # Runtime â€” republished from HA on reconnect if needed
    initial_value: '""'   # Empty on boot

  - id: watering_trigger_source
    type: std::string
    restore_value: False  # Transient state â€” set at run start
    initial_value: '"Idle"'
  
  # Per-zone last trigger tracking
  - id: zone1_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'
  - id: zone2_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'
  - id: zone3_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'
  - id: zone4_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'
  - id: zone5_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'
  - id: zone6_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'
  - id: zone7_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'
  - id: zone8_last_trigger
    type: std::string
    restore_value: False  # std::string restore unsafe + saves NVS space
    initial_value: '"Never"'

  # ============================================================
  # PREDICTIVE WATERINGâ„¢ GLOBALS
  # ============================================================
  - id: predictive_watering_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'  # Predictive Wateringâ„¢ ON by default
    
  - id: pw_last_calculation_time
    type: int64_t
    restore_value: False  # Recalculated on next weather sync
    initial_value: '0'  # Timestamp of last calculation
    
  - id: pw_current_multiplier
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.0'  # Current calculated multiplier
    
  - id: pw_temperature_factor
    type: float
    restore_value: False  # Recalculated from live weather data
    initial_value: '1.0'
    
  - id: pw_rain_factor
    type: float
    restore_value: False  # Recalculated from live weather data
    initial_value: '1.0'
    
  - id: pw_humidity_factor
    type: float
    restore_value: False  # Recalculated from live weather data
    initial_value: '1.0'
    
  - id: pw_wind_factor
    type: float
    restore_value: False  # Recalculated from live weather data
    initial_value: '1.0'

  - id: pw_seasonal_factor   # Bridge variable between split PW lambda blocks
    type: float
    restore_value: False  # Bridge variable â€” recalculated each cycle
    initial_value: '1.0'

  # ============================================================
  # SMART ET WATERING GLOBALS
  # ============================================================
  - id: smart_et_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'  # Smart ET OFF by default
    
  - id: et_soil_moisture_deficit
    type: float
    restore_value: True
    initial_value: '0.0'  # mm of water deficit
    
  - id: et_water_threshold
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_et_threshold_mm}'  # Water when deficit reaches threshold (mm)
    
  - id: et_last_calculation_time
    type: int64_t
    restore_value: False  # Recalculated on next weather sync
    initial_value: '0'
    
  - id: et_daily_et
    type: float
    restore_value: False  # Recalculated from live weather data
    initial_value: '0.0'  # Today's ET in mm
    
  - id: et_last_water_time
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
    
  - id: et_pending_irrigation
    type: bool
    restore_value: False  # Recalculated each ET cycle
    initial_value: 'false'
  
  - id: et_duration_multiplier
    type: float
    restore_value: False  # Recalculated each ET cycle
    initial_value: '1.0'  # Smart ET's additional multiplier based on deficit

  - id: et_rainfall_today    # Bridge variable between split ET lambda blocks
    type: float
    restore_value: False  # Bridge variable â€” recalculated from weather
    initial_value: '0.0'
  
  # NOTE: Smart ET automatically checks at Window 1 start time (no separate schedule time needed)

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER USAGE TRACKING (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Zone flow rates (liters per minute) - configurable per zone
  - id: zone1_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'  # L/min default
  - id: zone2_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'
  - id: zone3_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'
  - id: zone4_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'
  - id: zone5_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'
  - id: zone6_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'
  - id: zone7_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'
  - id: zone8_flow_rate
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone_flow_rate_lpm}'
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER USAGE TOTALS
  # Position matches the original working firmware (v3.37).
  # NVS slots are sequential â€” these must stay here to match
  # the slot indices already written to the physical flash chip.
  # DO NOT add globals above zone8_flow_rate without also
  # bumping CURRENT_VERSION to trigger a clean NVS reset.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: zone1_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone2_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone3_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone4_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone5_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone6_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone7_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: zone8_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: total_water_litres
    type: float
    restore_value: True
    initial_value: '0.0'
  - id: water_reset_timestamp
    type: int64_t
    restore_value: True
    initial_value: '0'

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # YF-B5 FLOW SENSOR GLOBALS
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  # Cumulative litres measured by flow sensor this irrigation session
  - id: flow_sensor_session_litres
    type: float
    restore_value: False  # Live sensor data â€” always starts at 0
    initial_value: '0.0'

  # Current flow rate in L/min (updated each sensor tick)
  - id: flow_sensor_current_lpm
    type: float
    restore_value: False  # Live sensor data â€” always starts at 0
    initial_value: '0.0'

  # Leak detection flag: flow when no zone is active
  - id: flow_sensor_leak_detected
    type: bool
    restore_value: False  # Derived from live sensor readings
    initial_value: 'false'

  # Set true in zone on_turn_on, false in zone on_turn_off AFTER snapshot.
  # More reliable than active_valve() or irrigation_busy for gating flow accumulation
  # because it stays true through the entire zone run including the shutdown moment.
  - id: zone_flow_active
    type: bool
    restore_value: False  # Runtime state â€” set during active watering
    initial_value: 'false'

  # Running pulse total â€” incremented in on_value by (x/60) each 1s tick.
  # Snapshot at zone start, subtract at zone end for exact litres.
  # Using our own counter avoids circular dependency with the total sub-sensor.
  - id: flow_zone_start_pulses
    type: float
    restore_value: False  # Runtime state â€” set at zone start
    initial_value: '0.0'

  # Accumulated pulse total (float, incremented each on_value tick)
  - id: flow_pulse_total
    type: float
    restore_value: False  # Runtime counter â€” reset each session
    initial_value: '0.0'

  # Stores what happened to water data on last boot â€” readable via HA sensor
  - id: last_boot_nvs_action
    type: std::string
    restore_value: False  # Diagnostic â€” set during boot NVS check
    initial_value: '"Not yet run"'


  # Zone-specific schedule times
  - id: zone1_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '6'
  - id: zone1_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone1_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # 0=AM, 1=PM
  
  - id: zone2_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '6'
  - id: zone2_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '15'
  - id: zone2_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  - id: zone3_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '6'
  - id: zone3_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '30'
  - id: zone3_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  - id: zone4_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '6'
  - id: zone4_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '45'
  - id: zone4_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  - id: zone5_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '7'
  - id: zone5_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone5_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  - id: zone6_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '7'
  - id: zone6_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '15'
  - id: zone6_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  - id: zone7_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '7'
  - id: zone7_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '30'
  - id: zone7_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  - id: zone8_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '7'
  - id: zone8_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '45'
  - id: zone8_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  # Zone schedule enable flags
  - id: zone1_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: zone2_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: zone3_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: zone4_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: zone5_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: zone6_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: zone7_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: zone8_schedule_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
    
  # Master Valve per-zone enable (Hunter Pro-C style)
  - id: zone1_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'  # Default ON for all zones
  - id: zone2_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: zone3_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: zone4_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: zone5_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: zone6_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: zone7_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: zone8_master_valve_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SOIL TYPE SETTINGS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: soil_type
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # 0=Sand, 1=Loam, 2=Clay (Default: Sand for Whanganui)
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SEASONAL ADJUSTMENT MULTIPLIERS (Southern Hemisphere - Whanganui)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: seasonal_jan
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.4'  # Peak summer
  - id: seasonal_feb
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.4'  # Peak summer
  - id: seasonal_mar
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.2'  # Early autumn
  - id: seasonal_apr
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.0'  # Autumn
  - id: seasonal_may
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0.9'  # Late autumn
  - id: seasonal_jun
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0.7'  # Winter
  - id: seasonal_jul
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0.6'  # Winter
  - id: seasonal_aug
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0.7'  # Late winter
  - id: seasonal_sep
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0.9'  # Early spring
  - id: seasonal_oct
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.1'  # Spring
  - id: seasonal_nov
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.3'  # Late spring
  - id: seasonal_dec
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.4'  # Early summer
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FREEZE PROTECTION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: freeze_threshold
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_freeze_threshold_c}'  # Celsius - disable watering below this
  - id: freeze_protection_active
    type: bool
    restore_value: False  # Derived from live temperature sensor
    initial_value: 'false'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER BUDGET LIMITS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: monthly_water_budget
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_monthly_budget_l}'  # Liters per month
  - id: current_month_usage
    type: float
    restore_value: True  # Restored with validation on boot to prevent corruption
    initial_value: '0.0'
  - id: last_reset_month
    type: int
    restore_value: True
    initial_value: '0'
  - id: budget_warning_sent
    type: bool
    restore_value: False  # Runtime flag â€” reset with daily counters
    initial_value: 'false'
  - id: budget_exceeded
    type: bool
    restore_value: False  # Runtime flag â€” reset with daily counters
    initial_value: 'false'
  - id: budget_override_active
    type: bool
    restore_value: False  # Runtime flag â€” reset with daily counters
    initial_value: 'false'
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SOFTWARE VERSION TRACKING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Tracks software version to detect upgrades and reset corrupted values
  - id: stored_software_version
    type: int
    restore_value: True
    initial_value: '0'  # Version number: 334 = V3.34
  - id: nvs_corruption_detected
    type: bool
    restore_value: False  # Boot diagnostic â€” always starts false
    initial_value: 'false'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ZONE RUNTIME LIMITS (Daily)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: max_zone_runtime_daily
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_max_zone_runtime_min}'  # Minutes per day per zone
  - id: zone1_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'  # Seconds
  - id: zone2_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'
  - id: zone3_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'
  - id: zone4_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'
  - id: zone5_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'
  - id: zone6_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'
  - id: zone7_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'
  - id: zone8_runtime_today
    type: int
    restore_value: False  # Daily counter â€” never restore from flash
    initial_value: '0'
  - id: last_runtime_reset_day
    type: int
    restore_value: False  # Paired with runtime_today â€” reset together
    initial_value: '0'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYSTEM IDLE DETECTION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: last_watering_timestamp
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NETWORK LOSS HANDLING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: fallback_multiplier
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.0'  # Last known good multiplier
  - id: network_offline_mode
    type: bool
    restore_value: False  # Derived from live network state
    initial_value: 'false'
    
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATERING WINDOW ENFORCEMENT (For Smart ET)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DEFAULT WINDOWS for Whanganui, NZ:
  #   Window 1: 5:00 AM - 9:00 AM (ENABLED) - Early morning (BEST for efficiency)
  #   Window 2: 6:00 PM - 9:00 PM (ENABLED) - Evening (Good alternative)
  #   Window 3: Disabled by default
  # 
  # These windows control WHEN Smart ET can water (weather-optimized irrigation)
  # Zone schedules and programs are NOT affected by these windows
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: window1_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: window1_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_window1_start_hour}'  # Early morning (24-hour)
  - id: window1_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # :00
  - id: window1_start_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # 0=AM, 1=PM
  - id: window1_end_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_window1_end_hour}'  # End hour (24-hour)
  - id: window1_end_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # :00
  - id: window1_end_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # 0=AM, 1=PM
  - id: window2_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: window2_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_window2_start_hour}'  # Start hour (24-hour)
  - id: window2_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # :00
  - id: window2_start_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # 0=AM, 1=PM
  - id: window2_end_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_window2_end_hour}'  # End hour (24-hour)
  - id: window2_end_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # :00
  - id: window2_end_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # 0=AM, 1=PM
    
  # WATERING WINDOW 3 (Optional - for additional ET run or special watering)
  - id: window3_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'  # Disabled by default
  - id: window3_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_window3_start_hour}'  # Start hour (24-hour)
  - id: window3_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # :00
  - id: window3_start_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # 0=AM, 1=PM
  - id: window3_end_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_window3_end_hour}'  # End hour (24-hour)
  - id: window3_end_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # :00
  - id: window3_end_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # 0=AM, 1=PM
  
  
  - id: manual_rain_delay_override
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: manual_weather_override
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: last_weather_log_time
    type: int64_t
    restore_value: False  # Log throttle timer â€” ok to reset on reboot
    initial_value: '0'
  - id: last_time_restriction_log
    type: int64_t
    restore_value: False  # Log throttle timer â€” ok to reset on reboot
    initial_value: '0'
  - id: last_blackout_log_time
    type: int64_t
    restore_value: False  # Log throttle timer â€” ok to reset on reboot
    initial_value: '0'
  - id: vacation_mode_active
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  # Saved zone schedule states: zone1..8 states are backed up here when vacation mode
  # activates and restored when vacation mode deactivates.
  - id: vacation_saved_zone1_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: vacation_saved_zone2_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: vacation_saved_zone3_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: vacation_saved_zone4_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: vacation_saved_zone5_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: vacation_saved_zone6_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: vacation_saved_zone7_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: vacation_saved_zone8_sched
    type: bool
    restore_value: False  # Temporary backup â€” ok to lose on reboot
    initial_value: 'false'
  - id: normal_multiplier
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1.0'
# Last watered timestamps for each zone
  - id: zone1_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone2_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone3_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone4_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone5_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone6_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone7_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: zone8_last_watered
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
# Zone start times (for duration tracking)
  - id: zone1_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: zone2_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: zone3_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: zone4_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: zone5_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: zone6_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: zone7_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: zone8_start_time
    type: int64_t
    restore_value: False  # Runtime timestamp: set when zone activates, used to compute run duration
    initial_value: '0'
  - id: cycle_soak_total_duration
    type: int
    restore_value: False  # Runtime state â€” set when cycle & soak starts
    initial_value: '0'
  - id: cycle_soak_elapsed_time
    type: int
    restore_value: False  # Runtime state â€” updated during cycle & soak
    initial_value: '0'
  - id: is_paused
    type: bool
    restore_value: False  # Runtime state â€” watering resumes after reboot
    initial_value: 'false'
  - id: paused_zone
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '-1'
  - id: paused_cycle
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'
  - id: time_remaining_when_paused
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'

  # --- Preserve cycle/soak state across Pause/Resume ---
  - id: paused_total_cycles
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'
  - id: paused_cycle_soak_total_duration
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'
  - id: paused_cycle_soak_elapsed_time
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'

  # --- Track soak phase for true pause/resume ---
  - id: cycle_soak_is_soaking
    type: bool
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: 'false'
  - id: cycle_soak_soak_end_time
    type: int64_t
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'
  - id: paused_was_soaking
    type: bool
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: 'false'
  - id: paused_soak_remaining_seconds
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'
  - id: soak_countdown_seconds
    type: int
    restore_value: False  # Runtime counter â€” cleared on reboot
    initial_value: '0'

  # --- Configurable Time Restriction Window (12-hour + AM-PM) ---
  # DEFAULT: Block 10:00 AM - 6:00 PM (Recommended for Whanganui, NZ)
  # This blocks midday watering (high evaporation) and allows efficient watering:
  #   - Early morning: 5:00 AM - 10:00 AM (BEST - low evaporation, optimal absorption)
  #   - Evening: 6:00 PM - 10:00 PM (Good - lower evaporation than midday)
  - id: restrict_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_time_restriction_start_hour}'
  - id: restrict_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: restrict_start_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'    # 0=AM, 1=PM

  - id: restrict_end_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_time_restriction_end_hour}'
  - id: restrict_end_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: restrict_end_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'    # 0=AM, 1=PM

  # --- Run lock / queue (prevents overlapping starts) ---
  - id: irrigation_busy
    type: bool
    restore_value: False  # Runtime state â€” always starts false on boot
    initial_value: 'false'

  # --- Safety gate for run_zone_with_cycles pre-flight checks ---
  # Set true when a pre-flight check fails so subsequent if-blocks skip execution.
  # Avoids calling script.stop() from within its own lambda (causes stack corruption).
  - id: zone_run_blocked
    type: bool
    restore_value: False  # Runtime state â€” reset at start of every zone run
    initial_value: 'false'

  # --- Safety gate for run_all_zones_normal_script pre-flight checks ---
  - id: normal_script_blocked
    type: bool
    restore_value: False  # Runtime state â€” reset at start of each run
    initial_value: 'false'

  # --- Safety gate for run_all_zones_cycle_soak_script pre-flight checks ---
  - id: cycle_soak_script_blocked
    type: bool
    restore_value: False  # Runtime state â€” reset at start of each run
    initial_value: 'false'

  # --- Safety gate for continue_cycle_soak_after_resume pre-flight checks ---
  # Prevents self-stop crash: set true when pre-flight fails, checked by all
  # subsequent if-blocks and while condition to skip execution cleanly.
  - id: resume_csa_blocked
    type: bool
    restore_value: False
    initial_value: 'false'

  # --- Temporary storage for normal-mode resume parameters ---
  # Lambda locals can't be passed directly to script.execute params,
  # so we stash the computed values here first.
  - id: resume_zone_param
    type: int
    restore_value: False
    initial_value: '0'
  - id: resume_duration_param
    type: int
    restore_value: False
    initial_value: '0'

  # True while run_program is executing
  - id: watchdog_last_activity
    type: int64_t
    restore_value: False  # Watchdog timer â€” reset on boot
    initial_value: '0'
  - id: in_program_run
    type: bool
    restore_value: False  # Runtime state â€” always starts false on boot
    initial_value: 'false'

  # one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
  # Queue system - supports up to 3 items (Hunter-style)
  - id: queue_types
    type: int[3]
    restore_value: False  # Runtime queue â€” cleared on reboot
  - id: queue_programs
    type: int[3]
    restore_value: False  # Runtime queue â€” cleared on reboot
  - id: queue_zones
    type: int[3]
    restore_value: False  # Runtime queue â€” cleared on reboot
  - id: queue_durations
    type: int[3]
    restore_value: False  # Runtime queue â€” cleared on reboot
  - id: queue_add_delays
    type: bool[3]
    restore_value: False  # Runtime queue â€” cleared on reboot
  - id: queue_trigger_sources
    type: std::string[3]
    restore_value: False  # Runtime queue â€” cleared on reboot
  - id: queue_count
    type: int
    restore_value: False  # Runtime queue â€” cleared on reboot
    initial_value: '0'
  
  # Normal-mode start queue (single pending start slot)
  - id: queued_type
    type: int
    restore_value: False  # Runtime state â€” cleared on reboot
    initial_value: '0'  # 0=none, 3=normal mode pending

  # Program 1 settings
  - id: program_a_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'
  - id: program_a_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_program_a_start_hour}'
  - id: program_a_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_a_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # 0=AM, 1=PM
  - id: program_a_schedule_type
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'  # 0=specific days, 1=odd days, 2=even days, 3=interval
  - id: program_a_interval_days
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '3'
  - id: program_a_last_run
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # OPTION 1: MULTIPLE START TIMES (up to 4 per program)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Program 1 additional start times
  - id: program_a_start_time_2_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_a_start_hour_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '12'
  - id: program_a_start_minute_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_a_am_pm_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  - id: program_a_start_time_3_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_a_start_hour_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '6'
  - id: program_a_start_minute_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_a_am_pm_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  - id: program_a_start_time_4_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_a_start_hour_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '9'
  - id: program_a_start_minute_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_a_am_pm_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  # Program 2 settings
  - id: program_b_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_b_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_program_b_start_hour}'
  - id: program_b_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_b_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_b_schedule_type
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_b_interval_days
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '3'
  - id: program_b_last_run
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  # Program 2 additional start times
  - id: program_b_start_time_2_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_b_start_hour_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '12'
  - id: program_b_start_minute_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_b_am_pm_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  - id: program_b_start_time_3_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_b_start_hour_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '6'
  - id: program_b_start_minute_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_b_am_pm_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  - id: program_b_start_time_4_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_b_start_hour_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '9'
  - id: program_b_start_minute_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_b_am_pm_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  # Program 3 settings
  - id: program_c_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_c_start_hour
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_program_c_start_hour}'
  - id: program_c_start_minute
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_c_am_pm
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_c_schedule_type
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_c_interval_days
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '3'
  - id: program_c_last_run
    type: int64_t
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  
  # Program 3 additional start times
  - id: program_c_start_time_2_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_c_start_hour_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '12'
  - id: program_c_start_minute_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_c_am_pm_2
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  - id: program_c_start_time_3_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_c_start_hour_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '6'
  - id: program_c_start_minute_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_c_am_pm_3
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
    
  - id: program_c_start_time_4_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'false'
  - id: program_c_start_hour_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '9'
  - id: program_c_start_minute_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '0'
  - id: program_c_am_pm_4
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'  # PM
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # OPTION 2: PER-PROGRAM ZONE DURATIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # When enabled, each program can override the default zone duration
  # 0 = use default duration from sprinkler component
  
  # Program 1 zone duration overrides (minutes)
  - id: zone1_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone1_program_a_duration}'
  - id: zone2_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone2_program_a_duration}'
  - id: zone3_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone3_program_a_duration}'
  - id: zone4_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone4_program_a_duration}'
  - id: zone5_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone5_program_a_duration}'
  - id: zone6_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone6_program_a_duration}'
  - id: zone7_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone7_program_a_duration}'
  - id: zone8_program_a_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone8_program_a_duration}'
  
  # Program 2 zone duration overrides (minutes)
  - id: zone1_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone1_program_b_duration}'
  - id: zone2_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone2_program_b_duration}'
  - id: zone3_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone3_program_b_duration}'
  - id: zone4_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone4_program_b_duration}'
  - id: zone5_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone5_program_b_duration}'
  - id: zone6_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone6_program_b_duration}'
  - id: zone7_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone7_program_b_duration}'
  - id: zone8_program_b_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone8_program_b_duration}'
    
  # Program 3 zone duration overrides (minutes)
  - id: zone1_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone1_program_c_duration}'
  - id: zone2_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone2_program_c_duration}'
  - id: zone3_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone3_program_c_duration}'
  - id: zone4_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone4_program_c_duration}'
  - id: zone5_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone5_program_c_duration}'
  - id: zone6_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone6_program_c_duration}'
  - id: zone7_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone7_program_c_duration}'
  - id: zone8_program_c_duration
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_zone8_program_c_duration}'
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # OPTION 3: NON-WATERING DAYS (Blackout Calendar)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Store up to 10 blackout dates as timestamps
  - id: blackout_date_1
    type: int64_t
    restore_value: True
    initial_value: '0'  # 0 = not set
  - id: blackout_date_2
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_3
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_4
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_5
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_6
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_7
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_8
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_9
    type: int64_t
    restore_value: True
    initial_value: '0'
  - id: blackout_date_10
    type: int64_t
    restore_value: True
    initial_value: '0'
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLACKOUT DATE DESCRIPTIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Allow users to add custom descriptions/reasons for each blackout date
  # Examples: "Summer Holiday", "System Maintenance", "Water Restrictions"
  # NOTE: std::string globals do NOT support restore_value: True in ESPHome.
  # Setting it True corrupts the NVS partition and wipes all globals (incl. timestamps) on reboot.
  # Descriptions are cosmetic only - the timestamps (longs above) carry the real data.
  - id: blackout_desc_1
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_2
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_3
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_4
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_5
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_6
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_7
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_8
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_9
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
  - id: blackout_desc_10
    type: std::string
    restore_value: False  # std::string â€” NVS restore unsupported
    initial_value: '""'
    
  # NZ Holiday timestamps (parsed from ISO datetime strings)
  - id: good_friday_timestamp
    type: int64_t
    restore_value: False  # Recalculated from current year on boot
    initial_value: '0'
  - id: easter_monday_timestamp
    type: int64_t
    restore_value: False  # Recalculated from current year on boot
    initial_value: '0'
  - id: kings_birthday_timestamp
    type: int64_t
    restore_value: False  # Recalculated from current year on boot
    initial_value: '0'
  - id: matariki_timestamp
    type: int64_t
    restore_value: False  # Recalculated from current year on boot
    initial_value: '0'
  - id: labour_day_timestamp
    type: int64_t
    restore_value: False  # Recalculated from current year on boot
    initial_value: '0'
    
  # Zone assignment to programs (0=none, 1=A, 2=B, 3=C)
  - id: zone1_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: zone2_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: zone3_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: zone4_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: zone5_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: zone6_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: zone7_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: zone8_program
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '1'
  - id: is_time_restricted
    type: bool
    restore_value: False  # Derived from live time â€” recalculated each check
    initial_value: 'false'
  - id: last_time_restriction_state
    type: int
    restore_value: False  # Derived from live time â€” recalculated each check
    initial_value: '0'


  # Adjust this if your shutdown window is longer/shorter
  - id: stop_restart_delay_seconds
    type: int
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: "${default_stop_restart_delay_sec}"
  - id: pending_normal_start
    type: bool
    restore_value: false
    initial_value: "false"
  - id: normal_start_attempts
    type: int
    restore_value: false
    initial_value: "0"
  - id: normal_last_attempt_ms
    type: uint32_t
    restore_value: false
    initial_value: "0"
  - id: last_matched_start_slot
    type: int
    restore_value: false
    initial_value: "1"
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ADVANCED FORECAST SYSTEM
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: forecast_rain_threshold_significant
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_forecast_significant_mm}'  # mm - Skip watering if this much rain forecast
  
  - id: forecast_rain_threshold_high
    type: float
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: '${default_forecast_high_mm}'  # mm - Auto rain delay if this much forecast
  

  
  - id: forecast_rain_detected
    type: bool
    restore_value: False  # Derived from live weather sensor
    initial_value: 'false'
  

  
  - id: forecast_enabled
    type: bool
    restore_value: True  # USER SETTING - must persist across reboots
    initial_value: 'true'  # Enable/disable forecast integration

# Sync time with Home Assistant
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      # Check weather every 4 hours and set/clear rain delay
      - seconds: 0
        minutes: 0
        hours: /4  # Runs at 0:00, 4:00, 8:00, 12:00, 16:00, 20:00
        then:
          - lambda: |-
              // Only auto-manage rain delay if manual override is OFF
              if (!id(manual_rain_delay_override)) {
                std::string weather = id(weather_forecast_home).state;
                if (weather.empty() || weather == "unknown" || weather == "unavailable") {
                  ESP_LOGW("irrigation", "Weather state unavailable - skipping scheduled rain delay update");
                  return;
                }
                
                // Set rain delay if it's raining
                if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                  id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (${seconds_per_day} * ${auto_rain_delay_days}); // auto rain delay
                  id(rain_delay_days) = ${auto_rain_delay_days};
                  id(rain_delay_days_input).publish_state(${auto_rain_delay_days});
                  ESP_LOGI("irrigation", "Auto rain delay activated - weather is %s", weather.c_str());
                }
                // Clear rain delay if weather is good (only if not manually overridden)
                else if (weather == "sunny" || weather == "clear" || weather == "partlycloudy" || weather == "cloudy") {
                  if (!id(manual_rain_delay_override) && id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
                    id(rain_delay_end_time) = 0;
                    id(rain_delay_days) = 0;
                    id(rain_delay_days_input).publish_state(0);
                    ESP_LOGI("irrigation", "Auto rain delay cleared - weather is %s", weather.c_str());
                  }
                }
              }
      
      # Run Predictive Watering calculation every hour
      - seconds: 0
        minutes: 0
        then:
          - script.execute: calculate_predictive_watering
      
      # Run Smart ET calculation every hour
      - seconds: 0
        minutes: 0
        then:
          - script.execute: calculate_smart_et
      
      # Check for pending Smart ET irrigation - triggers when ANY window opens
      - seconds: 0
        minutes: 0,5,10,15,20,25,30,35,40,45,50,55  # Check every 5 minutes
        then:
          - lambda: |-
              if (id(smart_et_enabled) && id(et_pending_irrigation)) {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // BLACKOUT CHECK - Block Smart ET on blackout dates
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Blackout check (incl. NZ public holidays via is_blackout_date sensor)
                if (id(is_blackout_date).state) {
                  ESP_LOGW("irrigation", "\U0001F6AB Smart ET BLOCKED - Blackout date active today");
                  return;
                }
                
                if (!id(is_time_restricted) && id(irrigation_system_enable).state) {
                  
                  // Re-check ET schedule day - pending irrigation must still be on a valid day
                  auto time_day = id(homeassistant_time).now();
                  int dow = time_day.day_of_week;  // 1=Sun, 2=Mon, 3=Tue...
                  bool day_ok = (dow == 2 && id(et_schedule_monday).state) ||
                                (dow == 3 && id(et_schedule_tuesday).state) ||
                                (dow == 4 && id(et_schedule_wednesday).state) ||
                                (dow == 5 && id(et_schedule_thursday).state) ||
                                (dow == 6 && id(et_schedule_friday).state) ||
                                (dow == 7 && id(et_schedule_saturday).state) ||
                                (dow == 1 && id(et_schedule_sunday).state);
                  if (!day_ok) {
                    const char* days[] = {"", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
                    ESP_LOGW("irrigation", "ğŸ“… Smart ET pending skipped - today (%s) is not an ET schedule day", days[dow]);
                    return;
                  }
                  auto now = id(homeassistant_time).now();
                  int current_hour = now.hour;
                  int current_minute = now.minute;
                  int current_time_minutes = (current_hour * 60) + current_minute;
                  
                  bool in_window = false;
                  std::string active_window = "";
                  
                  // Check Window 1
                  if (id(window1_enabled)) {
                    int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
                    int end_min = (id(window1_end_hour) * 60) + id(window1_end_minute);
                    if (start_min <= current_time_minutes && current_time_minutes < end_min) {
                      in_window = true;
                      active_window = "ET Watering Window 1";
                    }
                  }
                  
                  // Check Window 2
                  if (!in_window && id(window2_enabled)) {
                    int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
                    int end_min = (id(window2_end_hour) * 60) + id(window2_end_minute);
                    if (start_min <= current_time_minutes && current_time_minutes < end_min) {
                      in_window = true;
                      active_window = "ET Watering Window 2";
                    }
                  }
                  
                  // Check Window 3
                  if (!in_window && id(window3_enabled)) {
                    int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
                    int end_min = (id(window3_end_hour) * 60) + id(window3_end_minute);
                    if (start_min <= current_time_minutes && current_time_minutes < end_min) {
                      in_window = true;
                      active_window = "ET Watering Window 3";
                    }
                  }
                  
                  if (in_window) {
                    ESP_LOGI("irrigation", "ğŸŒ± Smart ET: Executing pending irrigation (%s is open)", active_window.c_str());
                    
                    // Recalculate and apply ET multiplier
                    float deficit = id(et_soil_moisture_deficit);
                    float threshold = id(et_water_threshold);
                    if (threshold <= 0.0f) threshold = 1.0f;  // Guard against divide-by-zero
                    float deficit_ratio = deficit / threshold;
                    float et_multiplier = deficit_ratio;
                    if (et_multiplier > ${max_et_multiplier}f) et_multiplier = ${max_et_multiplier}f;
                    if (et_multiplier < ${min_et_multiplier}f) et_multiplier = ${min_et_multiplier}f;
                    
                    id(et_duration_multiplier) = et_multiplier;
                    
                    // Apply combined multiplier, honouring vacation mode
                    float pw_mult = id(pw_current_multiplier);
                    float combined = pw_mult * et_multiplier;
                    if (combined > ${max_et_multiplier}f) combined = ${max_et_multiplier}f;
                    // Vacation mode applies 50% on top of the ET-boosted value
                    float combined_final = id(vacation_mode_active) ? combined * 0.5f : combined;
                    
                    ESP_LOGI("irrigation", "   ET Multiplier: %.2fx, PW: %.2fx, Combined: %.2fx%s", 
                             et_multiplier, pw_mult, combined_final,
                             id(vacation_mode_active) ? " (Ã—0.5 vacation)" : "");
                    
                    // Set trigger source for tracking
                    id(watering_trigger_source) = "Smart ET (" + active_window + ")";
                    ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Smart ET via %s", active_window.c_str());
                    
                    // Turn ON Cycle & Soak for Smart ET
                    id(cycle_soak_switch).turn_on();
                    ESP_LOGI("irrigation", "ğŸ”„ Cycle & Soak Mode: ON (Smart ET)");
                    
                    // BUG #33 FIX (part 2): Set multiplier only when idle.
                    // Bug #32 prevents calculate_smart_et running when busy, so this
                    // path only fires when the system is idle â€” multiplier change is safe.
                    // Still guard explicitly in case future code changes this invariant.
                    if (!id(irrigation_busy)) {
                      id($devicename1).set_multiplier(combined_final);
                    }
                    id(start_all_zones_cycle_soak).press();
                    // BUG #33 FIX: Only clear deficit/last_water_time when run started immediately.
                    // If queued, preserve deficit â€” it may be dropped before executing.
                    if (!id(irrigation_busy)) {
                      ESP_LOGI("irrigation", "   â„¹ï¸ Smart ET: Run queued â€” deficit preserved (%.1fmm)", id(et_soil_moisture_deficit));
                    } else {
                      id(et_soil_moisture_deficit) = 0;
                      { auto _t2b = id(homeassistant_time).now(); if (_t2b.is_valid()) id(et_last_water_time) = _t2b.timestamp; }
                    }
                    id(et_pending_irrigation) = false;
                  }
                }
              }
      
      # Restore Predictive Watering multiplier if Smart ET finished watering
      - seconds: 0
        minutes: /5  # Every 5 minutes
        then:
          - lambda: |-
              // Only restore if Smart ET is enabled and we're not currently watering
              if (!id(smart_et_enabled)) {
                return;
              }
              
              // Check if any valve is active
              bool is_watering = id($devicename1).active_valve().has_value();
              
              // If not watering and ET multiplier is not 1.0, restore PW multiplier
              if (!is_watering && id(et_duration_multiplier) != 1.0) {
                id(restore_pw_multiplier).execute();
              }
      
      # Check valve status and reset to Idle if no valves active
      - seconds: 0
        minutes: /1  # Every minute
        then:
          - lambda: |-
              // Only reset to Idle if:
              // 1. No valve is active, AND
              // 2. System is not in a mid-soak pause (irrigation_busy + cycle_soak_is_soaking)
              // This prevents the status flashing "Idle" between cycles during Cycle & Soak mode.
              bool is_active = id($devicename1).active_valve().has_value();
              bool mid_soak = id(irrigation_busy) && id(cycle_soak_is_soaking);
              
              if (!is_active && !mid_soak && id(dev1_valve_status).state != "Idle") {
                ESP_LOGI("irrigation", "No active valve detected - resetting status to Idle");
                id(dev1_valve_status).publish_state("Idle");
              }
      
# Check every minute if it's time to start programs
      - seconds: 0
        # NO minutes filter - check EVERY minute!
        then:
          # Check Program 1 (Enhanced with Multiple Start Times & Blackout Dates)
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_a_enabled)) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping ${program_a_name} check");
                    return false;
                  }
                  
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  // OPTION 3: BLACKOUT DATES CHECK 
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  // Blackout date check (incl. NZ public holidays via is_blackout_date sensor)
                  if (id(is_blackout_date).state) {
                    int64_t _now = now.timestamp;
                    if (_now - id(last_blackout_log_time) >= ${seconds_per_hour}) {
                      ESP_LOGW("irrigation", "\U0001F6AB ALL IRRIGATION BLOCKED - Blackout date active");
                      id(last_blackout_log_time) = _now;
                    }
                    return false;
                  }
                  
                  if (id(rain_delay_end_time) > now.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        // Only log once per hour to reduce spam
                        int64_t now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= ${seconds_per_hour}) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction check
                  if (id(is_time_restricted)) {
                    // Only log once per hour to reduce spam
                    int64_t now = id(homeassistant_time).now().timestamp;
                    if (now - id(last_time_restriction_log) >= ${seconds_per_hour}) {
                      ESP_LOGW("irrigation", "â° SCHEDULES BLOCKED - Time restriction active (outside allowed hours)");
                      id(last_time_restriction_log) = now;
                    }
                    return false;
                  }
                  
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  // OPTION 1: MULTIPLE START TIMES CHECK
                  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                  // Check all 4 possible start times
                  bool time_matches = false;
                  int matched_start_time = 0;
                  
                  // Start Time 1 (always active)
                  int start_hour_1 = id(program_a_start_hour);
                  if (id(program_a_am_pm) == 1) {
                    start_hour_1 = (start_hour_1 == 12) ? 12 : start_hour_1 + 12;
                  } else {
                    start_hour_1 = (start_hour_1 == 12) ? 0 : start_hour_1;
                  }
                  if (now.hour == start_hour_1 && now.minute == id(program_a_start_minute)) {
                    time_matches = true;
                    matched_start_time = 1;
                  }
                  
                  // Start Time 2 (if enabled)
                  if (!time_matches && id(program_a_start_time_2_enabled)) {
                    int start_hour_2 = id(program_a_start_hour_2);
                    if (id(program_a_am_pm_2) == 1) {
                      start_hour_2 = (start_hour_2 == 12) ? 12 : start_hour_2 + 12;
                    } else {
                      start_hour_2 = (start_hour_2 == 12) ? 0 : start_hour_2;
                    }
                    if (now.hour == start_hour_2 && now.minute == id(program_a_start_minute_2)) {
                      time_matches = true;
                      matched_start_time = 2;
                    }
                  }
                  
                  // Start Time 3 (if enabled)
                  if (!time_matches && id(program_a_start_time_3_enabled)) {
                    int start_hour_3 = id(program_a_start_hour_3);
                    if (id(program_a_am_pm_3) == 1) {
                      start_hour_3 = (start_hour_3 == 12) ? 12 : start_hour_3 + 12;
                    } else {
                      start_hour_3 = (start_hour_3 == 12) ? 0 : start_hour_3;
                    }
                    if (now.hour == start_hour_3 && now.minute == id(program_a_start_minute_3)) {
                      time_matches = true;
                      matched_start_time = 3;
                    }
                  }
                  
                  // Start Time 4 (if enabled)
                  if (!time_matches && id(program_a_start_time_4_enabled)) {
                    int start_hour_4 = id(program_a_start_hour_4);
                    if (id(program_a_am_pm_4) == 1) {
                      start_hour_4 = (start_hour_4 == 12) ? 12 : start_hour_4 + 12;
                    } else {
                      start_hour_4 = (start_hour_4 == 12) ? 0 : start_hour_4;
                    }
                    if (now.hour == start_hour_4 && now.minute == id(program_a_start_minute_4)) {
                      time_matches = true;
                      matched_start_time = 4;
                    }
                  }
                  
                  id(last_matched_start_slot) = matched_start_time;
                  if (!time_matches) return false;
                  
                  // Check schedule type
                  int schedule_type = id(program_a_schedule_type);
                  int day_of_month = now.day_of_month;
                  int day_of_week = now.day_of_week;  // 1=Sun, 2=Mon, 3=Tue, 4=Wed, 5=Thu, 6=Fri, 7=Sat
                  
                  if (schedule_type == 0) {  // Specific days
                    return (day_of_week == 2 && id(program_a_monday).state) ||
                           (day_of_week == 3 && id(program_a_tuesday).state) ||
                           (day_of_week == 4 && id(program_a_wednesday).state) ||
                           (day_of_week == 5 && id(program_a_thursday).state) ||
                           (day_of_week == 6 && id(program_a_friday).state) ||
                           (day_of_week == 7 && id(program_a_saturday).state) ||
                           (day_of_week == 1 && id(program_a_sunday).state);
                  } else if (schedule_type == 1) {  // Odd days
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {  // Even days
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {  // Interval
                    if (id(program_a_last_run) == 0) return true;  // Never run before
                    int64_t days_since = (now.timestamp - id(program_a_last_run)) / ${seconds_per_day};
                    return (days_since >= id(program_a_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    
                    // Count zones in Program 1
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 1 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 1 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 1 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 1 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 1 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 1 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 1 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 1 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM 1 TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 1
                    allow_queue: true   # Scheduled programs always queue (never block)
                    trigger_source: !lambda |-
                      return std::string("Program 1 Start #") + std::to_string(id(last_matched_start_slot));
          # Check Program 2
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_b_enabled)) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping ${program_b_name} check");
                    return false;
                  }
                  
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  if (id(rain_delay_end_time) > now.timestamp) return false;

                  // Weather check
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        int64_t now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= ${seconds_per_hour}) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  if (id(is_time_restricted)) return false;
                  
                  // Multiple start times check
                  bool time_matches = false;
                  int matched_start_time = 0;
                  
                  // Start Time 1
                  int start_hour_1 = id(program_b_start_hour);
                  if (id(program_b_am_pm) == 1) { start_hour_1 = (start_hour_1 == 12) ? 12 : start_hour_1 + 12;
                  } else { start_hour_1 = (start_hour_1 == 12) ? 0 : start_hour_1; }
                  if (now.hour == start_hour_1 && now.minute == id(program_b_start_minute)) { time_matches = true; matched_start_time = 1; }
                  
                  // Start Time 2
                  if (!time_matches && id(program_b_start_time_2_enabled)) {
                    int start_hour_2 = id(program_b_start_hour_2);
                    if (id(program_b_am_pm_2) == 1) { start_hour_2 = (start_hour_2 == 12) ? 12 : start_hour_2 + 12;
                    } else { start_hour_2 = (start_hour_2 == 12) ? 0 : start_hour_2; }
                    if (now.hour == start_hour_2 && now.minute == id(program_b_start_minute_2)) { time_matches = true; matched_start_time = 2; }
                  }
                  
                  // Start Time 3
                  if (!time_matches && id(program_b_start_time_3_enabled)) {
                    int start_hour_3 = id(program_b_start_hour_3);
                    if (id(program_b_am_pm_3) == 1) { start_hour_3 = (start_hour_3 == 12) ? 12 : start_hour_3 + 12;
                    } else { start_hour_3 = (start_hour_3 == 12) ? 0 : start_hour_3; }
                    if (now.hour == start_hour_3 && now.minute == id(program_b_start_minute_3)) { time_matches = true; matched_start_time = 3; }
                  }
                  
                  // Start Time 4
                  if (!time_matches && id(program_b_start_time_4_enabled)) {
                    int start_hour_4 = id(program_b_start_hour_4);
                    if (id(program_b_am_pm_4) == 1) { start_hour_4 = (start_hour_4 == 12) ? 12 : start_hour_4 + 12;
                    } else { start_hour_4 = (start_hour_4 == 12) ? 0 : start_hour_4; }
                    if (now.hour == start_hour_4 && now.minute == id(program_b_start_minute_4)) { time_matches = true; matched_start_time = 4; }
                  }
                  
                  id(last_matched_start_slot) = matched_start_time;
                  if (!time_matches) return false;
                  
                  int schedule_type = id(program_b_schedule_type);
                  int day_of_month = now.day_of_month;
                  int day_of_week = now.day_of_week;
                  
                  if (schedule_type == 0) {
                    return (day_of_week == 2 && id(program_b_monday).state) ||
                           (day_of_week == 3 && id(program_b_tuesday).state) ||
                           (day_of_week == 4 && id(program_b_wednesday).state) ||
                           (day_of_week == 5 && id(program_b_thursday).state) ||
                           (day_of_week == 6 && id(program_b_friday).state) ||
                           (day_of_week == 7 && id(program_b_saturday).state) ||
                           (day_of_week == 1 && id(program_b_sunday).state);
                  } else if (schedule_type == 1) {
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {
                    if (id(program_b_last_run) == 0) return true;
                    int64_t days_since = (now.timestamp - id(program_b_last_run)) / ${seconds_per_day};
                    return (days_since >= id(program_b_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    
                    // Count zones in Program 2
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 2 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 2 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 2 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 2 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 2 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 2 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 2 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 2 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM 2 TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 2
                    allow_queue: true   # Scheduled programs always queue (never block)
                    trigger_source: !lambda |-
                      return std::string("Program 2 Start #") + std::to_string(id(last_matched_start_slot));
          # Check Program 3
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_c_enabled)) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping ${program_c_name} check");
                    return false;
                  }
                  
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  if (id(rain_delay_end_time) > now.timestamp) return false;

                  // Weather check
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        int64_t now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= ${seconds_per_hour}) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  if (id(is_time_restricted)) return false;
                  
                  // Multiple start times check
                  bool time_matches = false;
                  int matched_start_time = 0;
                  
                  // Start Time 1
                  int start_hour_1 = id(program_c_start_hour);
                  if (id(program_c_am_pm) == 1) { start_hour_1 = (start_hour_1 == 12) ? 12 : start_hour_1 + 12;
                  } else { start_hour_1 = (start_hour_1 == 12) ? 0 : start_hour_1; }
                  if (now.hour == start_hour_1 && now.minute == id(program_c_start_minute)) { time_matches = true; matched_start_time = 1; }
                  
                  // Start Time 2
                  if (!time_matches && id(program_c_start_time_2_enabled)) {
                    int start_hour_2 = id(program_c_start_hour_2);
                    if (id(program_c_am_pm_2) == 1) { start_hour_2 = (start_hour_2 == 12) ? 12 : start_hour_2 + 12;
                    } else { start_hour_2 = (start_hour_2 == 12) ? 0 : start_hour_2; }
                    if (now.hour == start_hour_2 && now.minute == id(program_c_start_minute_2)) { time_matches = true; matched_start_time = 2; }
                  }
                  
                  // Start Time 3
                  if (!time_matches && id(program_c_start_time_3_enabled)) {
                    int start_hour_3 = id(program_c_start_hour_3);
                    if (id(program_c_am_pm_3) == 1) { start_hour_3 = (start_hour_3 == 12) ? 12 : start_hour_3 + 12;
                    } else { start_hour_3 = (start_hour_3 == 12) ? 0 : start_hour_3; }
                    if (now.hour == start_hour_3 && now.minute == id(program_c_start_minute_3)) { time_matches = true; matched_start_time = 3; }
                  }
                  
                  // Start Time 4
                  if (!time_matches && id(program_c_start_time_4_enabled)) {
                    int start_hour_4 = id(program_c_start_hour_4);
                    if (id(program_c_am_pm_4) == 1) { start_hour_4 = (start_hour_4 == 12) ? 12 : start_hour_4 + 12;
                    } else { start_hour_4 = (start_hour_4 == 12) ? 0 : start_hour_4; }
                    if (now.hour == start_hour_4 && now.minute == id(program_c_start_minute_4)) { time_matches = true; matched_start_time = 4; }
                  }
                  
                  id(last_matched_start_slot) = matched_start_time;
                  if (!time_matches) return false;
                  
                  int schedule_type = id(program_c_schedule_type);
                  int day_of_month = now.day_of_month;
                  int day_of_week = now.day_of_week;
                  
                  if (schedule_type == 0) {
                    return (day_of_week == 2 && id(program_c_monday).state) ||
                           (day_of_week == 3 && id(program_c_tuesday).state) ||
                           (day_of_week == 4 && id(program_c_wednesday).state) ||
                           (day_of_week == 5 && id(program_c_thursday).state) ||
                           (day_of_week == 6 && id(program_c_friday).state) ||
                           (day_of_week == 7 && id(program_c_saturday).state) ||
                           (day_of_week == 1 && id(program_c_sunday).state);
                  } else if (schedule_type == 1) {
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {
                    if (id(program_c_last_run) == 0) return true;
                    int64_t days_since = (now.timestamp - id(program_c_last_run)) / ${seconds_per_day};
                    return (days_since >= id(program_c_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    
                    // Count zones in Program 3
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 3 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 3 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 3 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 3 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 3 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 3 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 3 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 3 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM 3 TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 3
                    allow_queue: true   # Scheduled programs always queue (never block)
                    trigger_source: !lambda |-
                      return std::string("Program 3 Start #") + std::to_string(id(last_matched_start_slot));

      # Update smart multiplier at midnight based on temperature and season
      # NOTE: Only runs when Predictive Watering is DISABLED - PW manages the multiplier itself
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              // Skip if Predictive Watering is managing the multiplier
              if (id(predictive_watering_enabled)) {
                ESP_LOGD("irrigation", "Midnight multiplier skipped - Predictive Watering is active");
                return;
              }
              
              auto now = id(homeassistant_time).now();
              if (!now.is_valid()) {
                ESP_LOGW("irrigation", "Time not synchronized - skipping multiplier update");
                return;
              }
              
              int month = now.month;
              float temp = id(outside_temperature).state;
              if (isnan(temp)) {
                ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
                temp = 20.0;
              }
              
              float multiplier = 1.0;
              
              // Base seasonal multiplier
              if (month >= 12 || month <= 2) {
                multiplier = ${summer_base_multiplier};
                if (temp > ${summer_hot_temp_c}) multiplier = ${summer_hot_multiplier};
                if (temp > ${summer_very_hot_temp_c}) multiplier = ${summer_very_hot_multiplier};
              } else if (month >= 6 && month <= 8) {
                multiplier = ${winter_base_multiplier};
                if (temp < ${winter_cold_temp_c}) multiplier = ${winter_cold_multiplier};
              } else {
                // Spring/Autumn
                multiplier = ${spring_autumn_base_multiplier};
                if (temp > ${spring_autumn_warm_temp_c}) multiplier = ${spring_autumn_warm_multiplier};
              }
              
              if (id(vacation_mode_active)) {
                id($devicename1).set_multiplier(multiplier * 0.5f);
                id(normal_multiplier) = multiplier;  // Keep saved value current
                ESP_LOGI("irrigation", "Midnight multiplier %.1f Ã— 0.5 (vacation) = %.1f", multiplier, multiplier * 0.5f);
              } else {
                id($devicename1).set_multiplier(multiplier);
                ESP_LOGI("irrigation", "Midnight seasonal multiplier set to %.1f (temp: %.1fÂ°C)", multiplier, temp);
              }

# Check every minute for individual zone schedules
      - seconds: 0
        # NO minutes filter - check EVERY minute!
        then:
          # Zone 1 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;

                  if (!id(zone1_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                                    
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone1_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone1_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone1_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_1_duration).state;
                    int hour_12 = id(zone1_start_hour);
                    int minute = id(zone1_start_minute);
                    const char* ampm = (id(zone1_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 1 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 0
                    duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone1}"

          # Zone 2 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;

                  if (!id(zone2_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone2_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone2_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone2_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_2_duration).state;
                    int hour_12 = id(zone2_start_hour);
                    int minute = id(zone2_start_minute);
                    const char* ampm = (id(zone2_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 2 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 1
                    duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone2}"
          # Zone 3 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;

                  if (!id(zone3_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone3_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone3_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone3_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_3_duration).state;
                    int hour_12 = id(zone3_start_hour);
                    int minute = id(zone3_start_minute);
                    const char* ampm = (id(zone3_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 3 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 2
                    duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone3}"
          # Zone 4 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;

                  if (!id(zone4_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                                    // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone4_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone4_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone4_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_4_duration).state;
                    int hour_12 = id(zone4_start_hour);
                    int minute = id(zone4_start_minute);
                    const char* ampm = (id(zone4_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 4 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 3
                    duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone4}"
          # Zone 5 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;

                  if (!id(zone5_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone5_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone5_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone5_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_5_duration).state;
                    int hour_12 = id(zone5_start_hour);
                    int minute = id(zone5_start_minute);
                    const char* ampm = (id(zone5_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 5 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 4
                    duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone5}"
          # Zone 6 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;

                  if (!id(zone6_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone6_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone6_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone6_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_6_duration).state;
                    int hour_12 = id(zone6_start_hour);
                    int minute = id(zone6_start_minute);
                    const char* ampm = (id(zone6_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 6 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 5
                    duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone6}"
          # Zone 7 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;


                  if (!id(zone7_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) return false;
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone7_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone7_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone7_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_7_duration).state;
                    int hour_12 = id(zone7_start_hour);
                    int minute = id(zone7_start_minute);
                    const char* ampm = (id(zone7_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 7 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 6
                    duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone7}"
          # Zone 8 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) return false;

                  if (!id(zone8_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > now.timestamp) return false;
                  if (id(is_blackout_date).state) return false;  // Blackout check (incl. NZ holidays)
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) return false;
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone8_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone8_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return now.hour == hour_24 && now.minute == id(zone8_start_minute);
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_8_duration).state;
                    int hour_12 = id(zone8_start_hour);
                    int minute = id(zone8_start_minute);
                    const char* ampm = (id(zone8_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 8 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 7
                    duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
                    trigger_source: "Scheduled: ${dev1_zone8}"

          # Weekly Schedule (Schedule 1-7: Monday-Sunday)
          # Like Hunter Pro-C: Runs ALL enabled zones at set time on selected days
          - if:
              condition:
                lambda: |-
                  // Must have irrigation system enabled
                  if (!id(irrigation_system_enable).state) return false;
                  
                  // Must have weekly schedule enabled
                  if (!id(weekly_schedule_switch).state) return false;
                  
                  auto now = id(homeassistant_time).now();
                  if (!now.is_valid()) {
                    ESP_LOGW("irrigation", "Weekly schedule: Time not synchronized");
                    return false;
                  }
                  
                  // Check rain delay
                  if (id(rain_delay_end_time) > now.timestamp) {
                    ESP_LOGD("irrigation", "Weekly schedule blocked - rain delay active");
                    return false;
                  }
                  
                  // Weather check (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Weekly schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction check
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Get scheduled time
                  int hour_12 = (int)id(schedule_start_hour).state;
                  int minute = (int)id(schedule_start_minute).state;
                  int hour_24 = hour_12;
                  
                  // Convert 12-hour + AM/PM to 24-hour
                  std::string am_pm = id(schedule_am_pm).current_option();
                  if (am_pm == "PM") {
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  // Check if current time matches scheduled time
                  if (now.hour != hour_24 || now.minute != minute) return false;
                  
                  // Check if today is a scheduled day
                  // ESPHome day_of_week: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday
                  int day_of_week = now.day_of_week;
                  
                  bool day_enabled = (day_of_week == 2 && id(schedule_monday).state) ||
                                     (day_of_week == 3 && id(schedule_tuesday).state) ||
                                     (day_of_week == 4 && id(schedule_wednesday).state) ||
                                     (day_of_week == 5 && id(schedule_thursday).state) ||
                                     (day_of_week == 6 && id(schedule_friday).state) ||
                                     (day_of_week == 7 && id(schedule_saturday).state) ||
                                     (day_of_week == 1 && id(schedule_sunday).state);
                  
                  if (!day_enabled) {
                    ESP_LOGD("irrigation", "Weekly schedule: Today not scheduled (day_of_week=%d)", day_of_week);
                  }
                  
                  return day_enabled;
              then:
                - lambda: |-
                    auto now = id(homeassistant_time).now();
                    const char* day_names[] = {"", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
                    int dow = now.day_of_week;
                    
                    // Count enabled zones
                    int enabled_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_enable).state) { enabled_count++; zones_list += "Z1 "; }
                    if (id(zone2_enable).state) { enabled_count++; zones_list += "Z2 "; }
                    if (id(zone3_enable).state) { enabled_count++; zones_list += "Z3 "; }
                    if (id(zone4_enable).state) { enabled_count++; zones_list += "Z4 "; }
                    if (id(zone5_enable).state) { enabled_count++; zones_list += "Z5 "; }
                    if (id(zone6_enable).state) { enabled_count++; zones_list += "Z6 "; }
                    if (id(zone7_enable).state) { enabled_count++; zones_list += "Z7 "; }
                    if (id(zone8_enable).state) { enabled_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ”” WEEKLY SCHEDULE TRIGGERED                              â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Day: %-20s @ %02d:%02d                       â•‘",
                             day_names[dow], now.hour, now.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                        â•‘",
                             enabled_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•‘  Mode: Hunter Pro-C (full cycle with auto-advance)        â•‘");
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                    
                    // Check if system is busy
                    bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
                    
                    if (busy) {
                      // Queue as type 3 (full cycle)
                      if (id(queue_count) < 3) {
                        int pos = id(queue_count);
                        id(queue_types)[pos] = 3;  // 3 = Full Cycle (Weekly Schedule)
                        id(queue_programs)[pos] = 0;
                        id(queue_zones)[pos] = 0;
                        id(queue_durations)[pos] = 0;
                        id(queue_add_delays)[pos] = false;
                        id(queue_trigger_sources)[pos] = "Weekly Schedule";
                        id(queue_count)++;
                        
                        ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Weekly Schedule â†’ Slot %d/3 (%d zones will run when idle)",
                                 pos + 1, enabled_count);
                      } else {
                        ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Weekly Schedule will NOT run!");
                      }
                    } else {
                      ESP_LOGI("irrigation", "â–¶ï¸ STARTING Weekly Schedule immediately (system idle)");
                      // Set trigger source for weekly schedule
                      id(watering_trigger_source) = "Weekly Schedule";
                      ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Weekly Schedule");
                      // BUG #30 FIX: Set irrigation_busy=true BEFORE pending_normal_start
                      // so concurrent requests see the system as busy during the ~500ms
                      // window before the 500ms interval fires start_full_cycle.
                      id(irrigation_busy) = true;
                      id(pending_normal_start) = true;
                      id(normal_start_attempts) = 0;
                      id(normal_last_attempt_ms) = 0;
                    }

interval:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLACKOUT MONITORING - Stops irrigation if blackout becomes active
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - interval: 60s
    then:
      - lambda: |-
          if (id(is_blackout_date).state) {
            bool is_running = id($devicename1).active_valve().has_value() ||
                              id(run_zone_with_cycles).is_running() ||
                              id(run_program).is_running() ||
                              id(run_all_zones_normal_script).is_running() ||
                              id(run_all_zones_cycle_soak_script).is_running() ||
                              id(continue_cycle_soak_after_resume).is_running() ||
                              id(pending_normal_start);
            if (is_running) {
              ESP_LOGE("irrigation", "ğŸ›‘ EMERGENCY STOP - Blackout date detected while irrigating!");
              id($devicename1).shutdown();
              // Stop ALL scripts â€” including resume helpers and async drain
              id(run_zone_with_cycles).stop();
              id(run_program).stop();
              id(run_all_zones_normal_script).stop();
              id(run_all_zones_cycle_soak_script).stop();
              id(wait_until_idle_then_drain).stop();
              id(continue_cycle_soak_after_resume).stop();
              // BUG #35 FIX: Restore auto_advance â€” C&S turns it OFF at start.
              id(dev1_auto_advance).turn_on();
              // Full state reset â€” matches Stop button cleanup exactly
              id(pending_normal_start) = false;
              id(normal_start_attempts) = 0;
              id(irrigation_busy) = false;
              id(in_program_run) = false;
              id(is_paused) = false;
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;
              id(cycle_soak_is_soaking) = false;
              id(cycle_soak_soak_end_time) = 0;
              id(soak_countdown_seconds) = 0;
              id(paused_zone) = -1;
              id(paused_cycle) = 0;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              id(paused_total_cycles) = 0;
              id(paused_cycle_soak_total_duration) = 0;
              id(paused_cycle_soak_elapsed_time) = 0;
              id(resume_csa_blocked) = false;
              id(watering_trigger_source) = "Idle";
              id(dev1_valve_status).publish_state("Idle");
            }
          }
  
  - interval: 500ms
    then:
      - if:
          condition:
            lambda: |-
              // Only act if a normal run is pending
              return id(pending_normal_start);
          then:
            - lambda: |-
                // If paused, don't attempt to start
                if (id(is_paused)) return;

                // If a valve is already active, we succeeded - clear pending
                if (id($devicename1).active_valve().has_value()) {
                  ESP_LOGI("irrigation", "âœ… Normal start succeeded (valve active) - clearing pending flag");
                  id(pending_normal_start) = false;
                  id(normal_start_attempts) = 0;
                  return;
                }

                // Throttle attempts to 1/sec max
                uint32_t now = millis();
                if (now - id(normal_last_attempt_ms) < 1000) return;
                id(normal_last_attempt_ms) = now;

                // Safety: stop retrying after 30 attempts (~30s)
                if (id(normal_start_attempts) >= 30) {
                  ESP_LOGE("irrigation", "âŒ Normal start failed after 30 attempts - giving up");
                  id(pending_normal_start) = false;
                  id(normal_start_attempts) = 0;
                  // Must clear irrigation_busy â€” it was set before the failed start_full_cycle call.
                  // Without this, the system stays locked indefinitely after a hard failure.
                  id(irrigation_busy) = false;
                  id(watering_trigger_source) = "Idle";
                  return;
                }

                id(normal_start_attempts)++;
                ESP_LOGI("irrigation", "â–¶ Attempting Normal start (attempt %d)", id(normal_start_attempts));
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // SAFETY CHECKS â€” ALL must pass before relay fires
                // If any fail, abort the entire pending start (no relay click)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                auto _ns_time = id(homeassistant_time).now();
                
                if (!id(irrigation_system_enable).state) {
                  ESP_LOGW("irrigation", "ğŸš« NORMAL start BLOCKED â€” system disabled");
                  id(pending_normal_start) = false; id(normal_start_attempts) = 0;
                  id(irrigation_busy) = false; id(watering_trigger_source) = "Idle"; return;
                }
                if (id(freeze_protection_active)) {
                  ESP_LOGW("irrigation", "â„ï¸ NORMAL start BLOCKED â€” freeze protection active (%.1fÂ°C)", id(outside_temperature).state);
                  id(pending_normal_start) = false; id(normal_start_attempts) = 0;
                  id(irrigation_busy) = false; id(watering_trigger_source) = "Idle"; return;
                }
                if (id(budget_exceeded) && !id(budget_override_active)) {
                  ESP_LOGW("irrigation", "ğŸš« NORMAL start BLOCKED â€” monthly budget exceeded (%.0fL / %.0fL)", id(current_month_usage), id(monthly_water_budget));
                  id(pending_normal_start) = false; id(normal_start_attempts) = 0;
                  id(irrigation_busy) = false; id(watering_trigger_source) = "Idle"; return;
                }
                if (_ns_time.is_valid() && id(rain_delay_end_time) > _ns_time.timestamp) {
                  int64_t _rd = (id(rain_delay_end_time) - _ns_time.timestamp) / ${seconds_per_day};
                  ESP_LOGW("irrigation", "ğŸŒ§ï¸ NORMAL start BLOCKED â€” rain delay active (%lld day(s) remaining)", _rd);
                  id(pending_normal_start) = false; id(normal_start_attempts) = 0;
                  id(irrigation_busy) = false; id(watering_trigger_source) = "Idle"; return;
                }
                if (id(is_blackout_date).state) {
                  ESP_LOGW("irrigation", "ğŸš« NORMAL start BLOCKED â€” blackout date active");
                  id(pending_normal_start) = false; id(normal_start_attempts) = 0;
                  id(irrigation_busy) = false; id(watering_trigger_source) = "Idle"; return;
                }
                if (id(is_time_restricted)) {
                  ESP_LOGW("irrigation", "â° NORMAL start BLOCKED â€” outside allowed watering window");
                  id(pending_normal_start) = false; id(normal_start_attempts) = 0;
                  id(irrigation_busy) = false; id(watering_trigger_source) = "Idle"; return;
                }
                if (!id(manual_weather_override)) {
                  std::string _w = id(weather_forecast_home).state;
                  if (!_w.empty() && _w != "unknown" && _w != "unavailable") {
                    if (_w == "rainy" || _w == "pouring" || _w == "snowy" || _w == "snowy-rainy") {
                      ESP_LOGW("irrigation", "â›ˆï¸ NORMAL start BLOCKED â€” bad weather: %s", _w.c_str());
                      id(pending_normal_start) = false; id(normal_start_attempts) = 0;
                      id(irrigation_busy) = false; id(watering_trigger_source) = "Idle"; return;
                    }
                  }
                }
                
                ESP_LOGI("irrigation", "âœ… All safety checks passed â€” firing Normal mode relay");
                id(irrigation_busy) = true;

            # Try to start full cycle; if it's still stopping, next interval will retry
            - sprinkler.start_full_cycle: $devicename1

  # Update cycle & soak progress and master valve control every 1s
  - interval: 1s
    then:
      - lambda: |-
          // ====================================================================
          // MASTER VALVE CONTROL (Hunter Pro-C Style)
          // ====================================================================
          // Master valve opens ONLY if:
          // 1. Master valve system is enabled globally
          // 2. A zone is currently active
          // 3. That specific zone has MV enabled for it
          
          if (id(master_valve_enabled)) {
            auto active_valve = id($devicename1).active_valve();

            bool any_zone_active = active_valve.has_value();
            bool master_should_be_on = false;
            
            if (any_zone_active) {
              int zone = active_valve.value();  // 0-7
              
              // Check if this specific zone has master valve enabled
              bool zone_mv_enabled = false;
              switch(zone) {
                case 0: zone_mv_enabled = id(zone1_master_valve_enabled); break;
                case 1: zone_mv_enabled = id(zone2_master_valve_enabled); break;
                case 2: zone_mv_enabled = id(zone3_master_valve_enabled); break;
                case 3: zone_mv_enabled = id(zone4_master_valve_enabled); break;
                case 4: zone_mv_enabled = id(zone5_master_valve_enabled); break;
                case 5: zone_mv_enabled = id(zone6_master_valve_enabled); break;
                case 6: zone_mv_enabled = id(zone7_master_valve_enabled); break;
                case 7: zone_mv_enabled = id(zone8_master_valve_enabled); break;
              }
              
              master_should_be_on = zone_mv_enabled;
              
              // Log zone MV status (debug level to avoid spam)
              static int last_logged_zone = -1;
              static bool last_logged_mv_state = false;
              if (zone != last_logged_zone || zone_mv_enabled != last_logged_mv_state) {
                ESP_LOGD("irrigation", "Zone %d active - MV for this zone: %s",
                         zone + 1, zone_mv_enabled ? "ENABLED" : "DISABLED");
                last_logged_zone = zone;
                last_logged_mv_state = zone_mv_enabled;
              }
            }
            
            bool master_is_on = id(master_valve_relay).state;
            
            // Control master valve based on zone requirements
            // Guards: not in test mode, AND irrigation system is actively running
            // The irrigation_busy check ensures MV never opens due to a stale
            // active_valve() state after the sprinkler component has shut down.
            if (!id(test_mode_active)) {
              if (master_should_be_on && !master_is_on && id(irrigation_busy)) {
                id(master_valve_relay).turn_on();
                if (any_zone_active) {
                  auto active = id($devicename1).active_valve();
                  ESP_LOGI("irrigation", "âœ… Master Valve OPENED (Zone %d active, MV enabled for this zone)",
                           active.value() + 1);
                }
              } else if ((!master_should_be_on || !id(irrigation_busy)) && master_is_on) {
                id(master_valve_relay).turn_off();
                ESP_LOGI("irrigation", "ğŸ”’ Master Valve CLOSED (no zones active or zone MV disabled)");
              }
            }
          } else {
            // Master valve system disabled - ensure it's off (UNLESS testing)
            if (!id(test_mode_active) && id(master_valve_relay).state) {
              id(master_valve_relay).turn_off();
              ESP_LOGD("irrigation", "Master valve turned off (system disabled)");
            }
          }
          
          // Update soak countdown if currently soaking (and not paused)
          if (id(cycle_soak_is_soaking) && id(cycle_soak_soak_end_time) > 0 && !id(is_paused)) {
            int64_t now = id(homeassistant_time).now().timestamp;
            int remaining = id(cycle_soak_soak_end_time) - now;
            if (remaining < 0) remaining = 0;
            id(soak_countdown_seconds) = remaining;
          } else if (id(is_paused) && id(cycle_soak_is_soaking)) {
            // During pause keep the countdown at the frozen value (don't decrement)
            // soak_countdown_seconds was last set just before pause; leave it unchanged.
          } else {
            id(soak_countdown_seconds) = 0;
          }
          
          // Only increment if ALL conditions are met:
          // 1. Cycle & soak is active (total_duration > 0)
          // 2. Not finished yet (elapsed < total)
          // 3. NOT paused
          if (id(cycle_soak_total_duration) > 0 &&
              id(cycle_soak_elapsed_time) < id(cycle_soak_total_duration) &&
              !id(is_paused)) {
            
            bool valve_active = id($devicename1).active_valve().has_value();
            bool is_soaking = id(cycle_soak_is_soaking);
            
            // Increment if we're in an active cycle/soak session
            // (either watering OR soaking, but not idle between operations)
            if (valve_active || is_soaking) {
              id(cycle_soak_elapsed_time) += 1;  // Increment by 1 (interval is 1s)
              
              // Cap at total duration
              if (id(cycle_soak_elapsed_time) > id(cycle_soak_total_duration)) {
                id(cycle_soak_elapsed_time) = id(cycle_soak_total_duration);
              }
              
              // Debug logging every 10 seconds
              static int log_counter = 0;
              log_counter++;
              if (log_counter >= 10) {  // Every 10 seconds (10 * 1s intervals)
                ESP_LOGD("irrigation", "Progress: %d/%d sec (valve=%d, soaking=%d)",
                         id(cycle_soak_elapsed_time), id(cycle_soak_total_duration),
                         valve_active, is_soaking);
                log_counter = 0;
              }
            }
          }

          // Update remaining-time sensor so HA dashboard has a live countdown
          {
            float rem = 0.0f;
            if (id($devicename1).active_valve().has_value()) {
              rem = (float)id($devicename1).time_remaining_active_valve().value_or(0);
            }
            id(valve_remaining_seconds).publish_state(rem);
          }
  
# Watchdog - Check for stuck states every 30 seconds
  - interval: 30s
    then:
      - lambda: |-
          // Cache .now() once â€” was calling it twice in this lambda (P6 fix)
          auto _30s_time = id(homeassistant_time).now();
          if (!_30s_time.is_valid()) return;  // Time not synced yet
          int64_t now = _30s_time.timestamp;
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // PRODUCTION FEATURE CHECKS (Every 30s)
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // 1. FREEZE PROTECTION
          float temp = id(outside_temperature).state;
          if (isnan(temp) && id(freeze_protection_active)) {
            // Sensor unavailable while freeze was active â€” deactivate to prevent permanent lockout
            id(freeze_protection_active) = false;
            ESP_LOGW("irrigation", "â„ï¸ FREEZE PROTECTION DEACTIVATED â€” temperature sensor unavailable");
          }
          if (!isnan(temp)) {
            bool freeze_risk = temp < id(freeze_threshold);
            
            if (freeze_risk && !id(freeze_protection_active)) {
              // Activate freeze protection
              id(freeze_protection_active) = true;
              ESP_LOGW("irrigation", "");
              ESP_LOGW("irrigation", "â„ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGW("irrigation", "â„ï¸ FREEZE PROTECTION ACTIVATED");
              {
                char _a[80]; snprintf(_a, sizeof(_a), "â„ï¸ FREEZE PROTECTION: %.1fÂ°C (threshold %.1fÂ°C)", temp, id(freeze_threshold));
                id(irrigation_latest_alert) = _a;
                id(irrigation_alert_sensor).publish_state(_a);
              }
              ESP_LOGW("irrigation", "â„ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGW("irrigation", "â„ï¸ Temperature: %.1fÂ°C (threshold: %.1fÂ°C)", temp, id(freeze_threshold));
              ESP_LOGW("irrigation", "â„ï¸ All watering DISABLED until temperature rises above %.1fÂ°C", id(freeze_threshold) + ${freeze_recovery_offset_c}f);
              
              // Close master valve for safety
              if (id(master_valve_relay).state) {
                id(master_valve_relay).turn_off();
                ESP_LOGW("irrigation", "â„ï¸ Master valve CLOSED for safety");
              }
              
              // Stop any active watering and clear busy state immediately
              if (id($devicename1).active_valve().has_value()) {
                id($devicename1).shutdown();
                ESP_LOGW("irrigation", "â„ï¸ Active watering STOPPED");
              }
              // Stop ALL scripts â€” including resume helpers and async drain
              id(run_zone_with_cycles).stop();
              id(run_program).stop();
              id(run_all_zones_normal_script).stop();
              id(run_all_zones_cycle_soak_script).stop();
              id(wait_until_idle_then_drain).stop();
              id(continue_cycle_soak_after_resume).stop();
              // BUG #35 FIX: Restore auto_advance â€” C&S turns it OFF at start.
              // Without this, all future normal-mode runs won't advance through zones.
              id(dev1_auto_advance).turn_on();
              // Full state reset â€” matches Stop button cleanup exactly
              id(pending_normal_start) = false;
              id(normal_start_attempts) = 0;
              id(irrigation_busy) = false;
              id(in_program_run) = false;
              id(is_paused) = false;
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;
              id(cycle_soak_is_soaking) = false;
              id(cycle_soak_soak_end_time) = 0;
              id(soak_countdown_seconds) = 0;
              id(paused_zone) = -1;
              id(paused_cycle) = 0;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              id(paused_total_cycles) = 0;
              id(paused_cycle_soak_total_duration) = 0;
              id(paused_cycle_soak_elapsed_time) = 0;
              id(resume_csa_blocked) = false;
              id(watering_trigger_source) = "Idle";
              id(dev1_valve_status).publish_state("Idle");
              
              ESP_LOGW("irrigation", "â„ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGW("irrigation", "");
              
            } else if (id(freeze_protection_active) && temp > (id(freeze_threshold) + ${freeze_recovery_offset_c}f)) {
              // Deactivate freeze protection (with 3Â°C hysteresis â€” temp must exceed threshold by offset)
              id(freeze_protection_active) = false;
              ESP_LOGI("irrigation", "");
              ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "âœ… FREEZE PROTECTION DEACTIVATED");
              ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "âœ… Temperature: %.1fÂ°C - Normal operation resumed", temp);
              ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "");
            }
          }
          
          // 2. DAILY RUNTIME RESET (at midnight)
          auto& esp_time = _30s_time;  // Reuse already-fetched time (P6 fix)
          if (esp_time.is_valid()) {
            int current_day = esp_time.day_of_month;
            if (current_day != id(last_runtime_reset_day)) {
              ESP_LOGI("irrigation", "ğŸŒ… New day detected - resetting daily runtime counters");
              id(zone1_runtime_today) = 0;
              id(zone2_runtime_today) = 0;
              id(zone3_runtime_today) = 0;
              id(zone4_runtime_today) = 0;
              id(zone5_runtime_today) = 0;
              id(zone6_runtime_today) = 0;
              id(zone7_runtime_today) = 0;
              id(zone8_runtime_today) = 0;
              id(last_runtime_reset_day) = current_day;
            }
          }
          
          // 3. MONTHLY BUDGET RESET
          // last_reset_month == 0 means not yet initialised â€” skip to avoid false reset.
          // The boot check handles first-run initialisation.
          if (esp_time.is_valid() && id(last_reset_month) != 0) {
            int current_month = esp_time.month;
            if (current_month != id(last_reset_month)) {
              ESP_LOGI("irrigation", "ğŸ“… New month â€” resetting monthly budget (lifetime totals kept)");
              ESP_LOGI("irrigation", "   Previous month usage: %.1fL", id(current_month_usage));
              id(current_month_usage) = 0;
              id(last_reset_month) = current_month;
              id(budget_warning_sent) = false;
              id(budget_exceeded) = false;
            }
          }
          
          // 4. WATER BUDGET MONITORING
          if (id(monthly_water_budget) > 0) {
            float budget_percent = (id(current_month_usage) / id(monthly_water_budget)) * 100.0;
            
            // 80% warning
            if (budget_percent >= ${budget_warning_pct}f && !id(budget_warning_sent)) {
              ESP_LOGW("irrigation", "âš ï¸ WATER BUDGET WARNING: %.1f%% used (%.1fL / %.1fL)",
                       budget_percent, id(current_month_usage), id(monthly_water_budget));
              {
                char _a[100]; snprintf(_a, sizeof(_a), "âš ï¸ BUDGET 80%%: %.0fL used of %.0fL this month",
                               id(current_month_usage), id(monthly_water_budget));
                id(irrigation_latest_alert) = _a;
                id(irrigation_alert_sensor).publish_state(_a);
              }
              id(budget_warning_sent) = true;
            }
            
            // 100% limit (unless override active)
            if (budget_percent >= 100.0 && !id(budget_exceeded) && !id(budget_override_active)) {
              ESP_LOGE("irrigation", "ğŸš« WATER BUDGET EXCEEDED: %.1f%% used!", budget_percent);
              ESP_LOGE("irrigation", "ğŸš« Watering will be BLOCKED until next month or override activated");
              id(budget_exceeded) = true;
              {
                char _a[100]; snprintf(_a, sizeof(_a), "ğŸš« BUDGET EXCEEDED: %.0fL used of %.0fL this month",
                               id(current_month_usage), id(monthly_water_budget));
                id(irrigation_latest_alert) = _a;
                id(irrigation_alert_sensor).publish_state(_a);
              }
              
              // Stop any active watering and clear busy state immediately
              if (id($devicename1).active_valve().has_value()) {
                id($devicename1).shutdown();
                ESP_LOGW("irrigation", "ğŸš« Active watering STOPPED due to budget exceeded");
              }
              // Stop ALL scripts â€” including resume helpers and async drain
              id(run_zone_with_cycles).stop();
              id(run_program).stop();
              id(run_all_zones_normal_script).stop();
              id(run_all_zones_cycle_soak_script).stop();
              id(wait_until_idle_then_drain).stop();
              id(continue_cycle_soak_after_resume).stop();
              // BUG #35 FIX: Restore auto_advance â€” C&S turns it OFF at start.
              id(dev1_auto_advance).turn_on();
              // Full state reset â€” matches Stop button cleanup exactly
              id(pending_normal_start) = false;
              id(normal_start_attempts) = 0;
              id(irrigation_busy) = false;
              id(in_program_run) = false;
              id(is_paused) = false;
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;
              id(cycle_soak_is_soaking) = false;
              id(cycle_soak_soak_end_time) = 0;
              id(soak_countdown_seconds) = 0;
              id(paused_zone) = -1;
              id(paused_cycle) = 0;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              id(paused_total_cycles) = 0;
              id(paused_cycle_soak_total_duration) = 0;
              id(paused_cycle_soak_elapsed_time) = 0;
              id(resume_csa_blocked) = false;
              id(watering_trigger_source) = "Idle";
              id(dev1_valve_status).publish_state("Idle");
            }
          }
          
          // 5. NETWORK LOSS DETECTION
          float temp_check = id(outside_temperature).state;
          float hum_check = id(outside_humidity).state;
          static int sensor_fail_count = 0;
          
          if (isnan(temp_check) && isnan(hum_check)) {
            sensor_fail_count++;
            if (sensor_fail_count >= 3 && !id(network_offline_mode)) {
              // 3 consecutive failures (90 seconds) = network likely offline
              id(network_offline_mode) = true;
              ESP_LOGW("irrigation", "ğŸ“¡ NETWORK OFFLINE MODE ACTIVATED");
              // Honour vacation mode 50% reduction when going offline
              float _offline_mult = id(vacation_mode_active) ? id(fallback_multiplier) * 0.5f : id(fallback_multiplier);
              ESP_LOGW("irrigation", "ğŸ“¡ Using fallback multiplier: %.2f%s", _offline_mult,
                       id(vacation_mode_active) ? " (Ã—0.5 vacation)" : "");
              id($devicename1).set_multiplier(_offline_mult);
            }
          } else {
            sensor_fail_count = 0;
            if (id(network_offline_mode)) {
              id(network_offline_mode) = false;
              ESP_LOGI("irrigation", "ğŸ“¡ NETWORK ONLINE - Normal operation resumed");
            }
          }

          // --------------------------------------------------
          // PAUSE STATE WATCHDOG (24h safety)
          // --------------------------------------------------
          // Static is declared here (outside if/else) so BOTH branches share the same variable.
          // Previously it was declared inside each branch separately, making the else-branch
          // reset completely ineffective (two different C++ static locals).
          static int64_t pause_start_time = 0;
          if (id(is_paused)) {
            if (pause_start_time == 0) {
              pause_start_time = now;
            }

            int64_t paused_duration = now - pause_start_time;

            if (paused_duration > ${seconds_per_day}) {
              ESP_LOGE("irrigation",
                "WATCHDOG: Paused for >24 hours (%lld sec) - auto-clearing abandoned pause",
                paused_duration);

              id(is_paused) = false;
              id(irrigation_busy) = false;
              id(in_program_run) = false;

              id(paused_zone) = -1;
              id(paused_cycle) = 0;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              id(paused_total_cycles) = 0;
              id(paused_cycle_soak_total_duration) = 0;
              id(paused_cycle_soak_elapsed_time) = 0;

              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;

              id(watering_trigger_source) = "Idle";  // Clear trigger after 24h pause timeout
              pause_start_time = 0;
              id(drain_queue).execute();
            }
            else if (paused_duration > ${seconds_per_hour}) {
              if ((paused_duration % ${seconds_per_hour}) < 30) {
                ESP_LOGW("irrigation",
                  "WATCHDOG: System paused for %lld hours",
                  paused_duration / ${seconds_per_hour});
              }
            }

            return;
          }
          else {
            // Reset the shared timer so the next pause starts fresh
            pause_start_time = 0;
          }

          // --------------------------------------------------
          // ACTIVE STATE CHECK
          // --------------------------------------------------
          bool valve_active = id($devicename1).active_valve().has_value();
          bool script_running =
            id(run_zone_with_cycles).is_running() ||
            id(run_program).is_running() ||
            id(run_all_zones_cycle_soak_script).is_running() ||
            id(run_all_zones_normal_script).is_running() ||
            id(continue_cycle_soak_after_resume).is_running();
          bool soaking = id(cycle_soak_is_soaking);
          // pending_normal_start=true means a normal-mode start was triggered and the
          // 500ms retry interval is waiting for the sprinkler valve to open.
          // Must be included in the active-state check so the watchdog doesn't fire
          // the "clean completion" clear during the valve_open_delay window (2s) between
          // start_full_cycle being called and active_valve() returning a value.
          bool pending = id(pending_normal_start);

          if (valve_active || script_running || soaking || pending) {
            id(watchdog_last_activity) = now;
            return;
          }

          // --------------------------------------------------
          // SIMPLE FIX: CLEAN COMPLETION AUTO-CLEAR
          // --------------------------------------------------
          if (id(irrigation_busy) &&
              !valve_active &&
              !script_running &&
              !soaking &&
              !pending &&
              !id(is_paused)) {

            ESP_LOGI("irrigation",
              "Run finished cleanly â€” auto-clearing busy flag");

            id(irrigation_busy) = false;
            id(in_program_run) = false;
            id(active_zone_number) = -1;
            id(current_cycle) = 0;
            id(total_cycles) = 0;
            id(cycle_soak_total_duration) = 0;
            id(cycle_soak_elapsed_time) = 0;
            id(cycle_soak_is_soaking) = false;
            id(cycle_soak_soak_end_time) = 0;
            id(soak_countdown_seconds) = 0;
            id(watering_trigger_source) = "Idle";
            id(dev1_valve_status).publish_state("Idle");

            id(drain_queue).execute();
            return;
          }

          // --------------------------------------------------
          // WATCHDOG ESCALATION (REAL STUCK STATES)
          // --------------------------------------------------
          if (id(irrigation_busy)) {
            int64_t last = id(watchdog_last_activity);
            if (last == 0) last = now;
            int64_t idle_seconds = now - last;

            if (idle_seconds >= 60) {
              ESP_LOGE("irrigation",
                "WATCHDOG: System stuck for %lld seconds - clearing busy flag",
                idle_seconds);
              ESP_LOGE("irrigation",
                "  valve_active=%d, script_running=%d, soaking=%d, busy=%d",
                valve_active, script_running, soaking, id(irrigation_busy));

              id(irrigation_busy) = false;
              id(in_program_run) = false;
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(watering_trigger_source) = "Idle";  // Clear trigger after watchdog reset

              id(drain_queue).execute();
            }
            else if (idle_seconds >= 30) {
              ESP_LOGW("irrigation",
                "WATCHDOG: System idle for %lld seconds (busy=%d)",
                idle_seconds, id(irrigation_busy));
            }
          }

          // --------------------------------------------------
          // QUEUE SAFETY CHECK
          // --------------------------------------------------
          // Check BOTH the 3-slot queue (queue_count) AND the legacy
          // single-slot normal-mode queue (queued_type). Programmes and
          // zones use queue_count; normal mode uses queued_type.
          if ((id(queue_count) > 0 || id(queued_type) != 0) &&
              !id(irrigation_busy) &&
              !id(is_paused) &&
              !valve_active &&
              !script_running &&
              !soaking &&
              !pending) {

            ESP_LOGI("irrigation",
              "WATCHDOG: Queue has items but system is idle - draining (queue_count=%d, queued_type=%d)",
              id(queue_count), id(queued_type));
            // Clear stale queued_type (legacy single-slot queue â€” request_normal_start is
            // dead code, but guard against it leaving queued_type=3 stuck).
            if (id(queued_type) != 0 && id(queue_count) == 0) {
              ESP_LOGW("irrigation", "WATCHDOG: Clearing stale queued_type=%d (legacy queue)", id(queued_type));
              id(queued_type) = 0;
              return;  // Nothing actually queued in the 3-slot system â€” don't drain
            }
            id(drain_queue).execute();
          }

  # Update time restriction status every 30 seconds
  - interval: 30s
    then:
      - script.execute: check_time_restriction

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ADVANCED FORECAST SYSTEM
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Rain delay check runs automatically when forecast sensors update (on_value triggers)
  # No polling interval needed - event-driven only!

###############################################
# Text sensors with general information
###############################################
text_sensor:
  # â”€â”€ Irrigation Alerts â€” published on key events; HA automations trigger on state_changed â”€â”€
  # Persistent copy is written to ${ha_alert_entity} (create this in HA â†’ Helpers â†’ Text)
  - platform: template
    id: irrigation_alert_sensor
    name: "$upper_devicename1 Latest Alert"
    icon: "mdi:alert-circle"
    lambda: |-
      return id(irrigation_latest_alert);
    on_value:
      then:
        - if:
            condition:
              lambda: 'return !x.empty();'
            then:
              # Write to persistent HA input_text so automations survive HA restarts.
              # Create in HA: Settings â†’ Helpers â†’ Text â†’ "Irrigation Latest Alert"
              - homeassistant.service:
                  service: input_text.set_value
                  data:
                    entity_id: ${ha_alert_entity}
                    value: !lambda 'return x;'

  # â”€â”€ Last boot NVS action â€” shows what happened to water data on last reboot â”€â”€
  - platform: template
    id: last_boot_nvs_sensor
    name: "$upper_devicename1 Last Boot NVS Action"
    icon: "mdi:database-check"
    entity_category: diagnostic
    lambda: |-
      return id(last_boot_nvs_action);

  - platform: version
    name: $esphome_name ESPHome Version
    hide_timestamp: false
    internal: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NZ PUBLIC HOLIDAY DATE IMPORTS (YYYY-MM-DD format)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: homeassistant
    id: nz_good_friday_date
    entity_id: $ha_good_friday_date
    filters:
      - lambda: |-
          // Reject invalid or future dates (year > 2030 indicates stale/corrupt data)
          if (x.empty() || x == "unavailable" || x == "unknown") return {};
          if (x.length() >= 4) {
            int year = atoi(x.substr(0, 4).c_str());
            int _now_yr = id(homeassistant_time).now().year;
              if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) {
              ESP_LOGW("blackout", "âš ï¸ Good Friday date invalid/stale: %s - ignoring", x.c_str());
              return {};
            }
          }
          ESP_LOGI("blackout", "âœ… Good Friday date updated: %s", x.c_str());
          return x;
    
  - platform: homeassistant
    id: nz_easter_monday_date
    entity_id: $ha_easter_monday_date
    filters:
      - lambda: |-
          if (x.empty() || x == "unavailable" || x == "unknown") return {};
          if (x.length() >= 4) {
            int year = atoi(x.substr(0, 4).c_str());
            int _now_yr = id(homeassistant_time).now().year;
              if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) {
              ESP_LOGW("blackout", "âš ï¸ Easter Monday date invalid/stale: %s - ignoring", x.c_str());
              return {};
            }
          }
          ESP_LOGI("blackout", "âœ… Easter Monday date updated: %s", x.c_str());
          return x;
    
  - platform: homeassistant
    id: nz_kings_birthday_date
    entity_id: $ha_kings_birthday_date
    filters:
      - lambda: |-
          if (x.empty() || x == "unavailable" || x == "unknown") return {};
          if (x.length() >= 4) {
            int year = atoi(x.substr(0, 4).c_str());
            int _now_yr = id(homeassistant_time).now().year;
              if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) {
              ESP_LOGW("blackout", "âš ï¸ Kings Birthday date invalid/stale: %s - ignoring", x.c_str());
              return {};
            }
          }
          ESP_LOGI("blackout", "âœ… Kings Birthday date updated: %s", x.c_str());
          return x;
    
  - platform: homeassistant
    id: nz_labour_day_date
    entity_id: $ha_labour_day_date
    filters:
      - lambda: |-
          if (x.empty() || x == "unavailable" || x == "unknown") return {};

          if (x.length() >= 4) {
            int year = atoi(x.substr(0, 4).c_str());
            int _now_yr = id(homeassistant_time).now().year;
              if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) {
              ESP_LOGW("blackout", "âš ï¸ Labour Day date invalid/stale: %s - ignoring", x.c_str());
              return {};
            }
          }
          ESP_LOGI("blackout", "âœ… Labour Day date updated: %s", x.c_str());
          return x;
    
  - platform: homeassistant
    id: nz_matariki_date
    entity_id: $ha_matariki_date
    filters:
      - lambda: |-
          if (x.empty() || x == "unavailable" || x == "unknown") return {};
          if (x.length() >= 4) {
            int year = atoi(x.substr(0, 4).c_str());
            int _now_yr = id(homeassistant_time).now().year;
              if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) {
              ESP_LOGW("blackout", "âš ï¸ Matariki date invalid/stale: %s - ignoring", x.c_str());
              return {};
            }
          }
          ESP_LOGI("blackout", "âœ… Matariki date updated: %s", x.c_str());
          return x;

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NZ PUBLIC HOLIDAY TIMESTAMP SENSORS (ISO datetime strings)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # These parse ISO 8601 format: "2026-04-03T00:00:00+00:00"
  # and convert to Unix timestamps for the quick-add dropdown
  
  - platform: homeassistant
    id: good_friday_timestamp_text
    entity_id: $ha_good_friday_ts
    internal: true
    on_value:
      then:
        - lambda: |-
            // Parse ISO datetime string to Unix timestamp
            // Format: "2026-04-03T00:00:00+00:00" or "2026-04-03"
            if (x.empty() || x == "unavailable" || x == "unknown") {
              ESP_LOGW("blackout", "âš ï¸ Good Friday timestamp unavailable");
              return;
            }
            
            // Extract date components (works for both ISO formats)
            if (x.length() < 10) {
              ESP_LOGW("blackout", "âš ï¸ Good Friday timestamp invalid format: %s", x.c_str());
              return;
            }
            
            int year = atoi(x.substr(0, 4).c_str());
            int month = atoi(x.substr(5, 2).c_str());
            int day = atoi(x.substr(8, 2).c_str());
            
            // Validate date range
            { int _now_yr = id(homeassistant_time).now().year; if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) { ESP_LOGW("blackout", "âš ï¸ Good Friday year out of range: %d (current: %d)", year, _now_yr); return; } }
            
            // Convert to Unix timestamp
            struct tm timeinfo = {};
            timeinfo.tm_year = year - 1900;
            timeinfo.tm_mon = month - 1;
            timeinfo.tm_mday = day;
            timeinfo.tm_hour = 0;
            timeinfo.tm_min = 0;
            timeinfo.tm_sec = 0;
            timeinfo.tm_isdst = -1;
            
            time_t timestamp = mktime(&timeinfo);
            
            if (timestamp > 0) {
              id(good_friday_timestamp) = timestamp;
              ESP_LOGI("blackout", "âœ… Good Friday: %s â†’ timestamp %lld", x.c_str(), timestamp);
            } else {
              ESP_LOGW("blackout", "âš ï¸ Good Friday timestamp conversion failed");
            }
    
  - platform: homeassistant
    id: easter_monday_timestamp_text
    entity_id: $ha_easter_monday_ts
    internal: true
    on_value:
      then:
        - lambda: |-
            if (x.empty() || x == "unavailable" || x == "unknown") return;
            if (x.length() < 10) return;
            
            int year = atoi(x.substr(0, 4).c_str());
            int month = atoi(x.substr(5, 2).c_str());
            int day = atoi(x.substr(8, 2).c_str());
            
            { int _now_yr = id(homeassistant_time).now().year; if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) return; }
            
            struct tm timeinfo = {};
            timeinfo.tm_year = year - 1900;
            timeinfo.tm_mon = month - 1;
            timeinfo.tm_mday = day;
            timeinfo.tm_hour = 0;
            timeinfo.tm_min = 0;
            timeinfo.tm_sec = 0;
            timeinfo.tm_isdst = -1;
            
            time_t timestamp = mktime(&timeinfo);
            if (timestamp > 0) {
              id(easter_monday_timestamp) = timestamp;
              ESP_LOGI("blackout", "âœ… Easter Monday: %s â†’ timestamp %lld", x.c_str(), timestamp);
            }
    
  - platform: homeassistant
    id: kings_birthday_timestamp_text
    entity_id: $ha_kings_birthday_ts
    internal: true
    on_value:
      then:
        - lambda: |-
            if (x.empty() || x == "unavailable" || x == "unknown") return;
            if (x.length() < 10) return;
            
            int year = atoi(x.substr(0, 4).c_str());
            int month = atoi(x.substr(5, 2).c_str());
            int day = atoi(x.substr(8, 2).c_str());
            
            { int _now_yr = id(homeassistant_time).now().year; if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) return; }
            
            struct tm timeinfo = {};
            timeinfo.tm_year = year - 1900;
            timeinfo.tm_mon = month - 1;
            timeinfo.tm_mday = day;
            timeinfo.tm_hour = 0;
            timeinfo.tm_min = 0;
            timeinfo.tm_sec = 0;
            timeinfo.tm_isdst = -1;
            
            time_t timestamp = mktime(&timeinfo);
            if (timestamp > 0) {
              id(kings_birthday_timestamp) = timestamp;
              ESP_LOGI("blackout", "âœ… Kings Birthday: %s â†’ timestamp %lld", x.c_str(), timestamp);
            }
    
  - platform: homeassistant
    id: matariki_timestamp_text
    entity_id: $ha_matariki_ts
    internal: true
    on_value:
      then:
        - lambda: |-
            if (x.empty() || x == "unavailable" || x == "unknown") return;
            if (x.length() < 10) return;
            
            int year = atoi(x.substr(0, 4).c_str());
            int month = atoi(x.substr(5, 2).c_str());
            int day = atoi(x.substr(8, 2).c_str());
            
            { int _now_yr = id(homeassistant_time).now().year; if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) return; }
            
            struct tm timeinfo = {};
            timeinfo.tm_year = year - 1900;
            timeinfo.tm_mon = month - 1;
            timeinfo.tm_mday = day;
            timeinfo.tm_hour = 0;
            timeinfo.tm_min = 0;
            timeinfo.tm_sec = 0;
            timeinfo.tm_isdst = -1;
            
            time_t timestamp = mktime(&timeinfo);
            if (timestamp > 0) {
              id(matariki_timestamp) = timestamp;
              ESP_LOGI("blackout", "âœ… Matariki: %s â†’ timestamp %lld", x.c_str(), timestamp);
            }
    
  - platform: homeassistant
    id: labour_day_timestamp_text
    entity_id: $ha_labour_day_ts
    internal: true
    on_value:
      then:
        - lambda: |-
            if (x.empty() || x == "unavailable" || x == "unknown") return;
            if (x.length() < 10) return;
            
            int year = atoi(x.substr(0, 4).c_str());
            int month = atoi(x.substr(5, 2).c_str());
            int day = atoi(x.substr(8, 2).c_str());
            
            { int _now_yr = id(homeassistant_time).now().year; if (_now_yr > 0 && (year < (_now_yr - 1) || year > (_now_yr + 4))) return; }
            
            struct tm timeinfo = {};
            timeinfo.tm_year = year - 1900;
            timeinfo.tm_mon = month - 1;
            timeinfo.tm_mday = day;
            timeinfo.tm_hour = 0;
            timeinfo.tm_min = 0;
            timeinfo.tm_sec = 0;
            timeinfo.tm_isdst = -1;
            
            time_t timestamp = mktime(&timeinfo);
            if (timestamp > 0) {
              id(labour_day_timestamp) = timestamp;
              ESP_LOGI("blackout", "âœ… Labour Day: %s â†’ timestamp %lld", x.c_str(), timestamp);
            }

# Current Time and Day Display
  - platform: template
    id: current_time_display
    name: "Current Time"
    icon: "mdi:clock-digital"
    update_interval: 1s
    lambda: |-
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) return {"Time not synced"};
      
      int hour_12 = now.hour;
      std::string am_pm = "AM";
      
      if (hour_12 >= 12) {
        am_pm = "PM";
        if (hour_12 > 12) hour_12 -= 12;
      }
      if (hour_12 == 0) hour_12 = 12;
      
      char buffer[20];
      sprintf(buffer, "%d:%02d %s", hour_12, now.minute, am_pm.c_str());
      return {std::string(buffer)};

  - platform: template
    id: current_day_display
    name: "Current Day"
    icon: "mdi:calendar-today"
    update_interval: 60s
    lambda: |-
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) return {"Day unknown"};
      
      const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
      // ESPHome: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday
      int day_index = now.day_of_week - 1;
      if (day_index < 0 || day_index > 6) return {"Error"};
      
      return {std::string(days[day_index])};

  - platform: template
    id: current_datetime_display
    name: "Current Date & Time"
    icon: "mdi:calendar-clock"
    update_interval: 1s
    lambda: |-
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) return {"Not synced"};
      
      const char* days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
      int day_index = now.day_of_week - 1;
      
      int hour_12 = now.hour;
      std::string am_pm = "AM";
      if (hour_12 >= 12) {
        am_pm = "PM";
        if (hour_12 > 12) hour_12 -= 12;
      }
      if (hour_12 == 0) hour_12 = 12;
      
      char buffer[50];
      sprintf(buffer, "%s %d/%d/%d %d:%02d %s",
              days[day_index], now.day_of_month, now.month, now.year,
              hour_12, now.minute, am_pm.c_str());
      return {std::string(buffer)};

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATERING TRIGGER TRACKING DISPLAYS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Shows what triggered the current/last watering session
  - platform: template
    id: current_watering_trigger
    name: "$dev1_what Current Watering Trigger"
    icon: "mdi:debug-step-over"
    update_interval: 2s
    lambda: |-
      return id(watering_trigger_source);
  
  # Per-zone last trigger displays
  - platform: template
    id: zone1_last_trigger_display
    name: "${dev1_zone1} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone1_last_trigger);
  
  - platform: template
    id: zone2_last_trigger_display
    name: "${dev1_zone2} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone2_last_trigger);
  
  - platform: template
    id: zone3_last_trigger_display
    name: "${dev1_zone3} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone3_last_trigger);
  
  - platform: template
    id: zone4_last_trigger_display
    name: "${dev1_zone4} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone4_last_trigger);
  
  - platform: template
    id: zone5_last_trigger_display
    name: "${dev1_zone5} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone5_last_trigger);
  
  - platform: template
    id: zone6_last_trigger_display
    name: "${dev1_zone6} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone6_last_trigger);
  
  - platform: template
    id: zone7_last_trigger_display
    name: "${dev1_zone7} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone7_last_trigger);
  
  - platform: template
    id: zone8_last_trigger_display
    name: "${dev1_zone8} Last Trigger"
    icon: "mdi:history"
    lambda: |-
      return id(zone8_last_trigger);

  # Predictive Wateringâ„¢ status
  - platform: template
    name: "$dev1_what Predictive Watering Status"
    icon: "mdi:water-check"
    update_interval: 10s
    lambda: |-
      if (!id(predictive_watering_enabled)) {
        return {"Disabled"};
      }
      
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) {
        return {"Waiting for time sync"};
      }
      
      int64_t last_calc = id(pw_last_calculation_time);
      
      if (last_calc == 0) {
        return {"Initializing..."};
      }
      
      float multiplier = id(pw_current_multiplier);
      int pct_change = (int)((multiplier - 1.0) * 100);
      
      // Calculate next update time (hourly updates)
      int64_t current_time = now.timestamp;
      int64_t time_since_calc = current_time - last_calc;
      int64_t next_calc_sec = ${seconds_per_hour} - (time_since_calc % ${seconds_per_hour}); // 3600 = 1 hour
      int mins_until = next_calc_sec / 60;
      
      char buf[80];
      
      // Determine status description
      if (multiplier >= 1.8) {
        snprintf(buf, sizeof(buf), "Very Hot (+%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 1.5) {
        snprintf(buf, sizeof(buf), "Hot Weather (+%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 1.2) {
        snprintf(buf, sizeof(buf), "Warm (+%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 0.95 && multiplier <= 1.05) {
        snprintf(buf, sizeof(buf), "Normal (%.2fx) - Next: %dm", multiplier, mins_until);
      } else if (multiplier >= 0.5) {
        snprintf(buf, sizeof(buf), "Reduced (%d%%) - Next: %dm", pct_change, mins_until);
      } else if (multiplier >= 0.3) {
        snprintf(buf, sizeof(buf), "Cool/Rainy (%d%%) - Next: %dm", pct_change, mins_until);
      } else {
        snprintf(buf, sizeof(buf), "Minimal (%d%%) - Next: %dm", pct_change, mins_until);
      }
      
      return {buf};

  # Smart ET Watering status
  - platform: template
    name: "$dev1_what Smart ET Status"
    icon: "mdi:sprinkler-variant"
    update_interval: 5s
    lambda: |-
      if (!id(smart_et_enabled)) {
        return {"Disabled"};
      }
      
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) {
        return {"Waiting for time sync"};
      }
      
      float deficit = id(et_soil_moisture_deficit);
      float threshold = id(et_water_threshold);
      float pct = (deficit / threshold) * 100.0;
      float et_mult = id(et_duration_multiplier);
      
      char buf[80];
      
      if (id(et_pending_irrigation)) {
        // Find next window that will open
        int current_hour = now.hour;
        int current_minute = now.minute;
        int current_time_minutes = (current_hour * 60) + current_minute;
        
        int next_window_min = 2400; // Sentinel (max valid = 1439 = 23:59, so 2400 is safely impossible)
        int next_window_num = 0;
        
        // Check Window 1
        if (id(window1_enabled)) {
          int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
          if (start_min > current_time_minutes && start_min < next_window_min) {
            next_window_min = start_min;
            next_window_num = 1;
          }
        }
        
        // Check Window 2
        if (id(window2_enabled)) {
          int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
          if (start_min > current_time_minutes && start_min < next_window_min) {
            next_window_min = start_min;
            next_window_num = 2;
          }
        }
        
        // Check Window 3
        if (id(window3_enabled)) {
          int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
          if (start_min > current_time_minutes && start_min < next_window_min) {
            next_window_min = start_min;
            next_window_num = 3;
          }
        }
        
        // If no window today, check tomorrow's earliest
        if (next_window_min == 2400) {
          if (id(window1_enabled)) {
            int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
            if (start_min < next_window_min) {
              next_window_min = start_min;
              next_window_num = 1;
            }
          }
          if (id(window2_enabled)) {
            int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
            if (start_min < next_window_min) {
              next_window_min = start_min;
              next_window_num = 2;
            }
          }
          if (id(window3_enabled)) {
            int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
            if (start_min < next_window_min) {
              next_window_min = start_min;
              next_window_num = 3;
            }
          }
        }
        
        // Guard: no windows enabled
        if (next_window_num == 0) {
          return {"Disabled (no watering windows enabled)"};
        }

        // Convert to 12-hour format
        int next_hour_24 = next_window_min / 60;
        int next_min = next_window_min % 60;
        int hour_12 = (next_hour_24 == 0 || next_hour_24 == 12) ? 12 : next_hour_24 % 12;
        const char* ampm = (next_hour_24 < 12) ? "AM" : "PM";
        
        snprintf(buf, sizeof(buf), "PENDING - Win%d: %d:%02d %s", next_window_num, hour_12, next_min, ampm);
        return {buf};
      }
      
      if (deficit >= threshold) {
        // Find next window for "READY" status
        int current_hour = now.hour;
        int current_minute = now.minute;
        int current_time_minutes = (current_hour * 60) + current_minute;
        
        int next_window_min = 2400;
        int next_window_num = 0;
        
        // Check all 3 windows
        if (id(window1_enabled)) {
          int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
          if (start_min > current_time_minutes && start_min < next_window_min) {
            next_window_min = start_min;
            next_window_num = 1;
          }
        }
        if (id(window2_enabled)) {
          int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
          if (start_min > current_time_minutes && start_min < next_window_min) {
            next_window_min = start_min;
            next_window_num = 2;
          }
        }
        if (id(window3_enabled)) {
          int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
          if (start_min > current_time_minutes && start_min < next_window_min) {
            next_window_min = start_min;
            next_window_num = 3;
          }
        }
        
        // If no window today, check tomorrow
        if (next_window_min == 2400) {
          if (id(window1_enabled)) {
            int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
            if (start_min < next_window_min) {
              next_window_min = start_min;
              next_window_num = 1;
            }
          }
          if (id(window2_enabled)) {
            int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
            if (start_min < next_window_min) {
              next_window_min = start_min;
              next_window_num = 2;
            }
          }
          if (id(window3_enabled)) {
            int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
            if (start_min < next_window_min) {
              next_window_min = start_min;
              next_window_num = 3;
            }
          }
        }
        
        if (threshold <= 0.0f) threshold = 1.0f;  // Guard against divide-by-zero
        float deficit_ratio = deficit / threshold;

        // Guard: no windows enabled
        if (next_window_num == 0) {
          return {"Disabled (no watering windows enabled)"};
        }

        int next_hour_24 = next_window_min / 60;
        int next_min = next_window_min % 60;
        int hour_12 = (next_hour_24 == 0 || next_hour_24 == 12) ? 12 : next_hour_24 % 12;
        const char* ampm = (next_hour_24 < 12) ? "AM" : "PM";
        
        snprintf(buf, sizeof(buf), "READY @ Win%d %d:%02d %s", 
                 next_window_num, hour_12, next_min, ampm);
        return {buf};
      }
      
      if (et_mult > 1.0) {
        snprintf(buf, sizeof(buf), "OK (%.1fmm, %.0f%%) [%.2fx]", deficit, pct, et_mult);
      } else {
        snprintf(buf, sizeof(buf), "OK (%.1fmm, %.0f%%)", deficit, pct);
      }
      return {buf};

# Master Valve Status Display (Hunter Pro-C Style)
  - platform: template
    id: master_valve_status
    name: "Master Valve Status"
    icon: "mdi:valve"
    update_interval: 2s
    lambda: |-
      if (!id(master_valve_enabled)) {
        return {"System Disabled"};
      }
      
      bool mv_is_on = id(master_valve_relay).state;
      auto active_valve = id($devicename1).active_valve();
      
      if (!active_valve.has_value()) {
        if (mv_is_on) {
          return std::string("âš ï¸ ON (no zone active)");
        } else {
          return std::string("Closed (Standby)");
        }
      }
      
      int zone = active_valve.value();
      bool zone_mv_enabled = false;
      
      switch(zone) {
        case 0: zone_mv_enabled = id(zone1_master_valve_enabled); break;
        case 1: zone_mv_enabled = id(zone2_master_valve_enabled); break;
        case 2: zone_mv_enabled = id(zone3_master_valve_enabled); break;
        case 3: zone_mv_enabled = id(zone4_master_valve_enabled); break;
        case 4: zone_mv_enabled = id(zone5_master_valve_enabled); break;
        case 5: zone_mv_enabled = id(zone6_master_valve_enabled); break;
        case 6: zone_mv_enabled = id(zone7_master_valve_enabled); break;
        case 7: zone_mv_enabled = id(zone8_master_valve_enabled); break;
      }
      
      char buffer[80];
      if (zone_mv_enabled) {
        sprintf(buffer, "âœ… OPEN - Zone %d (MV Enabled)", zone + 1);
      } else {
        sprintf(buffer, "ğŸ”’ Closed - Zone %d (MV Disabled)", zone + 1);
      }
      return {std::string(buffer)};

# Weekly Schedule Status (Hunter Pro-C Style)
  - platform: template
    id: weekly_schedule_status
    name: "Weekly Schedule Status"
    icon: "mdi:calendar-clock"
    update_interval: 30s
    lambda: |-
      if (!id(weekly_schedule_switch).state) {
        return {"Disabled"};
      }
      
      // Build list of enabled days
      std::string days = "";
      if (id(schedule_monday).state) days += "Mon ";
      if (id(schedule_tuesday).state) days += "Tue ";
      if (id(schedule_wednesday).state) days += "Wed ";
      if (id(schedule_thursday).state) days += "Thu ";
      if (id(schedule_friday).state) days += "Fri ";
      if (id(schedule_saturday).state) days += "Sat ";
      if (id(schedule_sunday).state) days += "Sun ";
      
      if (days.empty()) {
        return {"Enabled - No days selected!"};
      }
      
      // Remove trailing space
      if (!days.empty()) days.pop_back();
      
      // Get scheduled time
      int hour = (int)id(schedule_start_hour).state;
      int minute = (int)id(schedule_start_minute).state;
      std::string am_pm = id(schedule_am_pm).current_option();
      
      char buffer[150];
      sprintf(buffer, "âœ“ Active: %s @ %d:%02d %s (All enabled zones)",
              days.c_str(), hour, minute, am_pm.c_str());
      return {std::string(buffer)};

# Program status sensors
  - platform: template
    id: program_a_status
    name: "${program_a_name} Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_a_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_a_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_a_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_a_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_a_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_a_interval_days)) + " days";
      
      int hour = id(program_a_start_hour);
      std::string am_pm = (id(program_a_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_a_start_minute) < 10 ? "0" : "") + std::to_string(id(program_a_start_minute)) + " " + am_pm};

  - platform: template
    id: program_b_status
    name: "${program_b_name} Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_b_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_b_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_b_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_b_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_b_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_b_interval_days)) + " days";
      
      int hour = id(program_b_start_hour);
      std::string am_pm = (id(program_b_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_b_start_minute) < 10 ? "0" : "") + std::to_string(id(program_b_start_minute)) + " " + am_pm};

  - platform: template
    id: program_c_status
    name: "${program_c_name} Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_c_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_c_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_c_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_c_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_c_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_c_interval_days)) + " days";
      
      int hour = id(program_c_start_hour);
      std::string am_pm = (id(program_c_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_c_start_minute) < 10 ? "0" : "") + std::to_string(id(program_c_start_minute)) + " " + am_pm};

# Vacation Mode Status
  - platform: template
    id: vacation_mode_status
    name: "Vacation Mode Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (id(vacation_mode_active)) {
        float current_mult = id($devicename1).multiplier();
        return {"Active - Watering at " + std::to_string((int)(current_mult * 100)) + "%"};
      }
      return {"Inactive"};

  # Expose Time Remaining as a sensor
  - platform: template
    id: dev1_time_remaining
    name: $upper_devicename1 Time Remaining
    update_interval: $sensor_update_frequency
    icon: "mdi:timer-sand"
    lambda: |-
      int seconds = round(id($devicename1).time_remaining_active_valve().value_or(0));
      int days = seconds / (24 * ${seconds_per_hour});
      seconds = seconds % (24 * ${seconds_per_hour});
      int hours = seconds / ${seconds_per_hour};
      seconds = seconds % ${seconds_per_hour};
      int minutes = seconds /  60;
      seconds = seconds % 60;
      std::string result = "";
      if (days) result += std::to_string(days) + "d ";
      if (hours) result += std::to_string(hours) + "h ";
      if (minutes) result += std::to_string(minutes) + "m ";
      result += std::to_string(seconds) + "s";
      return result;
          
# Expose Progress Percent as a sensor
  - platform: template
    id: dev1_progress_percent
    name: $upper_devicename1 Progress %
    update_interval: $sensor_update_frequency
    icon: "mdi:progress-clock"
    lambda: |-
      // Check if a valve is active
      if (!id($devicename1).active_valve().has_value()) {
        return {"0%"};
      }
      
      auto valve_num = id($devicename1).active_valve().value();
      auto remaining = id($devicename1).time_remaining_active_valve().value_or(0);
      auto duration = id($devicename1).valve_run_duration_adjusted(valve_num);
      
      if (duration <= 0 || remaining < 0) {
        return {"0%"};
      }
      
      float elapsed = duration - remaining;
      int progress = (int)((elapsed / duration) * 100.0);
      
      if (progress < 0) progress = 0;
      if (progress > 100) progress = 100;
      
      return {std::to_string(progress) + "%"};
      
  # Expose Valve Status as a sensor
  - platform: template
    id: dev1_valve_status
    name: $upper_devicename1 Status
    update_interval: never
    icon: "mdi:information-variant"
    
  - platform: template
    id: espboard_type
    icon: "mdi:developer-board"
    name: $esphome_name ESPBoard
    update_interval: $sensor_hourly_update
    internal: true
    lambda: |-
      return {"${esphome_board}"};

# Weather state from Home Assistant
  - platform: homeassistant
    id: weather_forecast_home
    entity_id: $ha_weather_entity
    internal: true
    on_value:
      then:
        # Immediately react to weather changes
        - lambda: |-
            // Only auto-manage rain delay if manual override is OFF
            if (!id(manual_rain_delay_override)) {
              std::string weather = x;
              if (weather.empty() || weather == "unknown" || weather == "unavailable") {
                ESP_LOGW("irrigation", "Weather state unavailable - skipping auto rain delay update");
                return;
              }
              
              // Set rain delay if it starts raining
              if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (${seconds_per_day} * ${auto_rain_delay_days}); // auto rain delay
                id(rain_delay_days) = ${auto_rain_delay_days};
                id(rain_delay_days_input).publish_state(${auto_rain_delay_days});
                ESP_LOGI("irrigation", "Auto rain delay activated immediately - weather changed to %s", weather.c_str());
              }
              // Clear rain delay if weather improves (only if not manually overridden)
              else if (weather == "sunny" || weather == "clear" || weather == "partlycloudy" || weather == "cloudy") {
                if (!id(manual_rain_delay_override) && id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
                  id(rain_delay_end_time) = 0;
                  id(rain_delay_days) = 0;
                  id(rain_delay_days_input).publish_state(0);
                  ESP_LOGI("irrigation", "Auto rain delay cleared immediately - weather changed to %s", weather.c_str());
                }
              }
            }


  # Time Restriction Status (live)
  - platform: template
    id: time_restriction_status
    name: "Time Restriction Status"
    icon: "mdi:clock-alert"
    update_interval: 30s
    lambda: |-
      auto t = id(homeassistant_time).now();
      int sh = id(restrict_start_hour);
      int eh = id(restrict_end_hour);
      int s24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
      int e24 = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
      int now_min = t.hour * 60 + t.minute;
      int start_min = s24 * 60 + id(restrict_start_minute);
      int end_min   = e24 * 60 + id(restrict_end_minute);
      bool enabled = id(time_restriction_switch).state && !id(manual_time_restriction_override).state;
      bool blocked = enabled && ((start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                                       : (now_min >= start_min || now_min < end_min));
      char buf[96];
      if (!enabled) {
        snprintf(buf, sizeof(buf), "Disabled");
      } else if (blocked) {
        snprintf(buf, sizeof(buf), "BLOCKED NOW (Restricted: %d:%02d %s - %d:%02d %s)",
                 id(restrict_start_hour), id(restrict_start_minute), (id(restrict_start_am_pm) == 0 ? "AM" : "PM"),
                 id(restrict_end_hour), id(restrict_end_minute), (id(restrict_end_am_pm) == 0 ? "AM" : "PM"));
      } else {
        snprintf(buf, sizeof(buf), "Allowed (Restricted: %d:%02d %s - %d:%02d %s)",
                 id(restrict_start_hour), id(restrict_start_minute), (id(restrict_start_am_pm) == 0 ? "AM" : "PM"),
                 id(restrict_end_hour), id(restrict_end_minute), (id(restrict_end_am_pm) == 0 ? "AM" : "PM"));
      }
      return {buf};

  - platform: template
    id: time_restriction_next_allowed
    name: "Time Restriction Next Allowed"
    icon: "mdi:calendar-clock"
    update_interval: 30s
    lambda: |-
      auto t = id(homeassistant_time).now();
      int sh = id(restrict_start_hour);
      int eh = id(restrict_end_hour);
      int s24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
      int e24 = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
      int now_min = t.hour * 60 + t.minute;
      int start_min = s24 * 60 + id(restrict_start_minute);
      int end_min   = e24 * 60 + id(restrict_end_minute);
      bool enabled = id(time_restriction_switch).state && !id(manual_time_restriction_override).state;
      if (!enabled) return {"Now"};
      bool blocked = (start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                           : (now_min >= start_min || now_min < end_min);
      if (!blocked) return {"Now"};
      int next_min = end_min;
      int h24 = next_min / 60;
      int mm = next_min % 60;
      int ampm = (h24 >= 12) ? 1 : 0;
      int h12 = h24 % 12;
      if (h12 == 0) h12 = 12;
      char buf[32];
      snprintf(buf, sizeof(buf), "%d:%02d %s", h12, mm, (ampm == 0 ? "AM" : "PM"));
      return {buf};

# Weather condition display
  - platform: template
    id: weather_condition
    name: "Weather Condition"
    icon: "mdi:weather-partly-cloudy"
    lambda: |-
      if (id(weather_forecast_home).state.empty() || id(weather_forecast_home).state == "unknown" || id(weather_forecast_home).state == "unavailable") {
        return {"clear"};  // Default to clear if no data
      }
      return id(weather_forecast_home).state;


# Next scheduled watering day
  - platform: template
    id: next_watering_day
    name: "Next Watering Day"
    icon: "mdi:calendar-clock"
    update_interval: 30s  # Update every 30 seconds for faster response
    lambda: |-
      auto now = id(homeassistant_time).now();
      int current_day = now.day_of_week;
      
      const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
      
      // Check next 7 days
      for (int i = 1; i <= 7; i++) {
        int check_day = (current_day + i) % 7;
        if ((check_day == 1 && id(schedule_monday).state) ||
            (check_day == 2 && id(schedule_tuesday).state) ||
            (check_day == 3 && id(schedule_wednesday).state) ||
            (check_day == 4 && id(schedule_thursday).state) ||
            (check_day == 5 && id(schedule_friday).state) ||
            (check_day == 6 && id(schedule_saturday).state) ||
            (check_day == 0 && id(schedule_sunday).state)) {
          return {days[check_day]};
        }
      }
      return {"None scheduled"};

# ET Watering Window 1 Display (12-hour format with minutes)
  - platform: template
    id: window1_display
    name: "ET Watering Window 1"
    icon: "mdi:clock-time-four"
    update_interval: 60s
    lambda: |-
      if (!id(window1_enabled)) {
        return {"Disabled"};
      }
      
      // Get stored 24-hour times
      int start_24 = id(window1_start_hour);
      int start_min = id(window1_start_minute);
      int end_24 = id(window1_end_hour);
      int end_min = id(window1_end_minute);
      
      // Convert to 12-hour format
      int start_12 = (start_24 == 0 || start_24 == 12) ? 12 : start_24 % 12;
      const char* start_ampm = (start_24 < 12) ? "AM" : "PM";
      
      int end_12 = (end_24 == 0 || end_24 == 12) ? 12 : end_24 % 12;
      const char* end_ampm = (end_24 < 12) ? "AM" : "PM";
      
      char buffer[50];
      sprintf(buffer, "%d:%02d %s - %d:%02d %s", 
              start_12, start_min, start_ampm, end_12, end_min, end_ampm);
      return {buffer};

# ET Watering Window 2 Display (12-hour format with minutes)
  - platform: template
    id: window2_display
    name: "ET Watering Window 2"
    icon: "mdi:clock-time-eight"
    update_interval: 60s
    lambda: |-
      if (!id(window2_enabled)) {
        return {"Disabled"};
      }
      
      // Get stored 24-hour times
      int start_24 = id(window2_start_hour);
      int start_min = id(window2_start_minute);
      int end_24 = id(window2_end_hour);
      int end_min = id(window2_end_minute);
      
      // Convert to 12-hour format
      int start_12 = (start_24 == 0 || start_24 == 12) ? 12 : start_24 % 12;
      const char* start_ampm = (start_24 < 12) ? "AM" : "PM";
      
      int end_12 = (end_24 == 0 || end_24 == 12) ? 12 : end_24 % 12;
      const char* end_ampm = (end_24 < 12) ? "AM" : "PM";
      
      char buffer[50];
      sprintf(buffer, "%d:%02d %s - %d:%02d %s", 
              start_12, start_min, start_ampm, end_12, end_min, end_ampm);
      return {buffer};

# ET Watering Window 3 Display (12-hour format with minutes)
  - platform: template
    id: window3_display
    name: "ET Watering Window 3"
    icon: "mdi:clock-time-two"
    update_interval: 60s
    lambda: |-
      if (!id(window3_enabled)) {
        return {"Disabled"};
      }
      
      // Get stored 24-hour times
      int start_24 = id(window3_start_hour);
      int start_min = id(window3_start_minute);
      int end_24 = id(window3_end_hour);
      int end_min = id(window3_end_minute);
      
      // Convert to 12-hour format
      int start_12 = (start_24 == 0 || start_24 == 12) ? 12 : start_24 % 12;
      const char* start_ampm = (start_24 < 12) ? "AM" : "PM";
      
      int end_12 = (end_24 == 0 || end_24 == 12) ? 12 : end_24 % 12;
      const char* end_ampm = (end_24 < 12) ? "AM" : "PM";
      
      char buffer[50];
      sprintf(buffer, "%d:%02d %s - %d:%02d %s", 
              start_12, start_min, start_ampm, end_12, end_min, end_ampm);
      return {buffer};

# Cycle & Soak detailed status
  - platform: template
    id: cycle_soak_detailed_status
    name: "Cycle & Soak Detailed Status"
    icon: "mdi:water-sync"
    update_interval: 1s  # Changed from 2s to 1s for faster updates
    lambda: |-
      // Check if we're in cycle & soak mode with active tracking
      if (id(cycle_soak_total_duration) > 0 && id(active_zone_number) >= 0) {
        // Check if a valve is currently watering
        if (id($devicename1).active_valve().has_value()) {
          int valve = id($devicename1).active_valve().value();
          return {"Zone " + std::to_string(valve + 1) + " - Cycle " +
                  std::to_string(id(current_cycle)) + "/" +
                  std::to_string(id(total_cycles)) + " - Watering"};
        } else {
          // No valve active but we're tracking - must be soaking
          if (id(current_cycle) <= id(total_cycles) && id(current_cycle) > 0) {
            int countdown_sec = id(soak_countdown_seconds);
            int countdown_min = countdown_sec / 60;
            int countdown_sec_remaining = countdown_sec % 60;
            
            return {"Zone " + std::to_string(id(active_zone_number) + 1) +
                    " - Soaking (" + std::to_string(countdown_min) + "m " +
                    std::to_string(countdown_sec_remaining) + "s remaining)"};
          }
        }
      }
      
      // Check if any valve is active in normal mode
      if (id($devicename1).active_valve().has_value()) {
        int valve = id($devicename1).active_valve().value();
        return {"Zone " + std::to_string(valve + 1) + " - Active"};
      }
      
      return {"Idle"};

# Zone 1 Last Watered
  - platform: template
    id: zone1_last_watered_text
    name: "${dev1_zone1} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone1_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw1_time = id(homeassistant_time).now();
      if (!_lw1_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw1_time.timestamp - id(zone1_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 2 Last Watered
  - platform: template
    id: zone2_last_watered_text
    name: "${dev1_zone2} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone2_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw2_time = id(homeassistant_time).now();
      if (!_lw2_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw2_time.timestamp - id(zone2_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 3 Last Watered
  - platform: template
    id: zone3_last_watered_text
    name: "${dev1_zone3} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone3_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw3_time = id(homeassistant_time).now();
      if (!_lw3_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw3_time.timestamp - id(zone3_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 4 Last Watered
  - platform: template
    id: zone4_last_watered_text
    name: "${dev1_zone4} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone4_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw4_time = id(homeassistant_time).now();
      if (!_lw4_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw4_time.timestamp - id(zone4_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 5 Last Watered
  - platform: template
    id: zone5_last_watered_text
    name: "${dev1_zone5} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone5_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw5_time = id(homeassistant_time).now();
      if (!_lw5_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw5_time.timestamp - id(zone5_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 6 Last Watered
  - platform: template
    id: zone6_last_watered_text
    name: "${dev1_zone6} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone6_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw6_time = id(homeassistant_time).now();
      if (!_lw6_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw6_time.timestamp - id(zone6_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 7 Last Watered
  - platform: template
    id: zone7_last_watered_text
    name: "${dev1_zone7} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone7_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw7_time = id(homeassistant_time).now();
      if (!_lw7_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw7_time.timestamp - id(zone7_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 8 Last Watered
  - platform: template
    id: zone8_last_watered_text
    name: "${dev1_zone8} Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone8_last_watered) == 0) {
        return {"Never"};
      }
      auto _lw8_time = id(homeassistant_time).now();
      if (!_lw8_time.is_valid()) return {"-"};
      int64_t seconds_ago = _lw8_time.timestamp - id(zone8_last_watered);
      int64_t days = seconds_ago / ${seconds_per_day};
      int64_t hours = (seconds_ago % ${seconds_per_day}) / ${seconds_per_hour};
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        int64_t minutes = (seconds_ago % ${seconds_per_hour}) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Queue Status Display (Hunter Pro-C style)
  - platform: template
    id: queue_status_display
    name: "Queue Status"
    icon: "mdi:format-list-numbered"
    update_interval: 2s
    lambda: |-
      if (id(queue_count) == 0) {
        return {"Empty (0/3)"};
      }
      
      std::string result = std::to_string(id(queue_count)) + "/3: ";
      for (int i = 0; i < id(queue_count) && i < 3; i++) {
        if (i > 0) result += ", ";
        int type = id(queue_types)[i];
        if (type == 1) {
          // Program
          result += "Prg " + std::string(1, 'A' + id(queue_programs)[i] - 1);
        } else if (type == 2) {
          // Zone
          result += "Zone " + std::to_string(id(queue_zones)[i] + 1);
        }
      }
      return {result};

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MULTIPLIER BREAKDOWN DISPLAY (Whanganui - Sand Soil)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    id: multiplier_breakdown
    name: "$dev1_what Multiplier Breakdown"
    icon: "mdi:calculator"
    update_interval: 60s
    lambda: |-
      if (!id(predictive_watering_enabled)) {
        return {"Predictive Watering Disabled"};
      }
      
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) {
        return {"Time not synced"};
      }
      
      // Get seasonal factor
      float seasonal = 1.0;
      int month = now.month;
      switch (month) {
        case 1:  seasonal = id(seasonal_jan); break;
        case 2:  seasonal = id(seasonal_feb); break;
        case 3:  seasonal = id(seasonal_mar); break;
        case 4:  seasonal = id(seasonal_apr); break;
        case 5:  seasonal = id(seasonal_may); break;
        case 6:  seasonal = id(seasonal_jun); break;
        case 7:  seasonal = id(seasonal_jul); break;
        case 8:  seasonal = id(seasonal_aug); break;
        case 9:  seasonal = id(seasonal_sep); break;
        case 10: seasonal = id(seasonal_oct); break;
        case 11: seasonal = id(seasonal_nov); break;
        case 12: seasonal = id(seasonal_dec); break;
      }
      
      // Get soil factor
      float soil = 1.0;
      std::string soil_name = "Unknown";
      if (id(soil_type) == 0) {
        soil = 1.15;
        soil_name = "Sand";
      } else if (id(soil_type) == 1) {
        soil = 1.0;
        soil_name = "Loam";
      } else if (id(soil_type) == 2) {
        soil = 0.85;
        soil_name = "Clay";
      }
      
      // Get current multiplier
      float total = id(pw_current_multiplier);
      
      char buffer[150];
      sprintf(buffer, "Season: %.2f | Soil (%s): %.2f | Total: %.2f",
              seasonal, soil_name.c_str(), soil, total);
      return {std::string(buffer)};

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ADVANCED FORECAST SYSTEM DISPLAYS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Rain Forecast Summary
  - platform: template
    name: "$dev1_what Rain Forecast Summary"
    id: lawn_rain_forecast_summary
    icon: "mdi:weather-rainy"
    update_interval: never  # Only updates when forecast sensors change (via on_value triggers)
    lambda: |-
      if (!id(forecast_enabled)) {
        return {"Forecast disabled"};
      }
      
      float f1h = id(rain_forecast_1h).state;
      float f0d = id(rain_probability).state;  // Today's total forecast (0d)
      
      // Debug logging
      ESP_LOGI("forecast", "Rain Summary - 1h: %.2f, Today: %.2f", f1h, f0d);
      
      char buf[200];
      if (isnan(f1h) && isnan(f0d)) {
        snprintf(buf, sizeof(buf), "Waiting for forecast data...");
      } else if (isnan(f1h)) {
        // Only have today's forecast
        if (f0d >= 5.0) {
          snprintf(buf, sizeof(buf), "Heavy rain today: %.1fmm", f0d);
        } else if (f0d >= 2.0) {
          snprintf(buf, sizeof(buf), "Rain today: %.1fmm", f0d);
        } else {
          snprintf(buf, sizeof(buf), "Light/no rain: %.1fmm today", f0d);
        }
      } else if (isnan(f0d)) {
        // Only have 1h forecast
        if (f1h >= 5.0) {
          snprintf(buf, sizeof(buf), "Heavy rain soon: %.1fmm in 1h", f1h);
        } else if (f1h >= 2.0) {
          snprintf(buf, sizeof(buf), "Rain soon: %.1fmm in 1h", f1h);
        } else {
          snprintf(buf, sizeof(buf), "Light: %.1fmm in 1h", f1h);
        }
      } else {
        // Have BOTH forecasts - show smartest summary
        if (f1h >= 5.0) {
          snprintf(buf, sizeof(buf), "Heavy rain NOW: %.1fmm/1h, %.1fmm/day", f1h, f0d);
        } else if (f1h >= 2.0) {
          snprintf(buf, sizeof(buf), "Rain soon: %.1fmm/1h, %.1fmm/day", f1h, f0d);
        } else if (f0d >= 5.0) {
          snprintf(buf, sizeof(buf), "Heavy later: %.1fmm/day (%.1fmm/1h now)", f0d, f1h);
        } else if (f0d >= 2.0 || f1h >= 0.5) {
          snprintf(buf, sizeof(buf), "Light rain: %.1fmm/1h, %.1fmm/day", f1h, f0d);
        } else {
          snprintf(buf, sizeof(buf), "Minimal rain: %.1fmm/1h, %.1fmm/day", f1h, f0d);
        }
      }
      return {buf};
  
  # Forecast Watering Recommendation
  - platform: template
    name: "$dev1_what Forecast Watering Recommendation"
    id: lawn_forecast_watering_recommendation
    icon: "mdi:lightbulb-on"
    update_interval: 10min
    lambda: |-
      if (!id(forecast_enabled)) {
        return {"Forecast disabled"};
      }
      
      float f1h = id(rain_forecast_1h).state;
      float f0d = id(rain_probability).state;  // Today's total
      float threshold_sig = id(forecast_rain_threshold_significant);
      float threshold_high = id(forecast_rain_threshold_high);
      
      // Debug logging
      ESP_LOGI("forecast", "Watering Rec - 1h: %.2f, 0d: %.2f, thresholds: sig=%.1f high=%.1f", 
               f1h, f0d, threshold_sig, threshold_high);
      
      char buf[150];
      
      // Smart combined logic: 1h = urgency, 0d = daily planning
      if (isnan(f1h) && isnan(f0d)) {
        snprintf(buf, sizeof(buf), "PROCEED - Waiting for forecast");
      } 
      // URGENCY CHECK (1h forecast) - takes priority
      else if (!isnan(f1h) && f1h >= threshold_high) {
        snprintf(buf, sizeof(buf), "DELAY - Heavy rain NOW (%.1fmm/1h)", f1h);
      } 
      else if (!isnan(f1h) && f1h >= threshold_sig) {
        snprintf(buf, sizeof(buf), "SKIP - Rain imminent (%.1fmm/1h)", f1h);
      }
      // DAILY PLANNING CHECK (0d forecast)
      else if (!isnan(f0d) && f0d >= threshold_high) {
        snprintf(buf, sizeof(buf), "REDUCE 50%% - Heavy rain today (%.1fmm)", f0d);
      }
      else if (!isnan(f0d) && f0d >= threshold_sig) {
        snprintf(buf, sizeof(buf), "REDUCE 30%% - Rain today (%.1fmm)", f0d);
      }
      // COMBINED LOW RAIN
      else if (!isnan(f1h) && !isnan(f0d) && (f1h + f0d) >= 2.0) {
        snprintf(buf, sizeof(buf), "REDUCE 20%% - Light rain (%.1f+%.1fmm)", f1h, f0d);
      }
      // ALL CLEAR
      else {
        float total = 0;
        if (!isnan(f1h)) total += f1h;
        if (!isnan(f0d)) total += f0d;
        snprintf(buf, sizeof(buf), "PROCEED - Minimal rain (%.1fmm)", total);
      }
      return {buf};

sensor:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # FLOW SENSOR â€” YF-B5 (Copper G3/4 DN20, Hall effect)
  # Pin:    ${flow_sensor_pin}  (internal pull-up, no external resistor)
  # Wiring: VCC=5V  GND=GND  Signal=${flow_sensor_pin}
  #
  # MEASUREMENT METHOD â€” pulse count delta (not accumulation):
  #   on_turn_on:  snapshot flow_pulse_total -> flow_zone_start_pulses
  #   on_turn_off: zone_litres = (flow_pulse_total - flow_zone_start_pulses) / PPL
  #   This is exact â€” every pulse is counted, no timing sensitivity.
  #
  # LIVE DISPLAY â€” flow_sensor_current_lpm is updated every tick
  #   so Flow Rate and Flow Session Volume update in real time.
  #   Session Volume shows live progress during the run.
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: pulse_counter
    pin:
      number: ${flow_sensor_pin}
      mode:
        input: true
        pullup: true
    id: flow_sensor_raw
    name: "$upper_devicename1 Flow Sensor Raw Pulses"
    unit_of_measurement: "pulses/min"
    accuracy_decimals: 0
    use_pcnt: true        # Hardware PCNT â€” counts in silicon, immune to CPU load
    internal_filter: 13us # Max for PCNT mode. EMI spikes are <1us, real pulses >5ms â€” safe margin
    update_interval: ${flow_sensor_update_interval}
    on_value:
      - lambda: |-
          // â”€â”€ LIVE FLOW RATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // x = pulses/min (ESPHome pulse_counter always normalises to per-min)
          // lpm = pulses/min / pulses_per_litre
          // Math: at 15 L/min -> 15 x 277 = 4155 p/min -> 4155/277 = 15.0 L/min (exact)
          const float PPL = ${flow_sensor_pulses_per_litre}.0f;
          float lpm = (x > 0.0f) ? (x / PPL) : 0.0f;
          id(flow_sensor_current_lpm) = lpm;

          // â”€â”€ RUNNING PULSE TOTAL + LIVE SESSION VOLUME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // x = pulses/min, update_interval=1s -> pulses this tick = x/60
          // We maintain flow_pulse_total ourselves to avoid circular dependency
          // with the total sub-sensor (cannot reference it from its parent on_value).
          // Live session = (running_total - start_snapshot) / PPL
          // This matches exactly what on_turn_off computes.
          id(flow_pulse_total) += (x / 60.0f);
          if (id(zone_flow_active)) {
            float elapsed = id(flow_pulse_total) - id(flow_zone_start_pulses);
            if (elapsed < 0.0f) elapsed = 0.0f;
            id(flow_sensor_session_litres) = elapsed / PPL;
          }

          // â”€â”€ LEAK DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Suppress after zone stops (solenoid de-energise noise) and
          // at zone start (valve opening transient).
          bool zone_active = id(zone_flow_active);
          static int64_t stop_ts = 0;
          static int64_t start_ts = 0;
          // Cache timestamp once â€” was calling .now() 3 times (P4 fix)
          int64_t now_s = (int64_t)(id(homeassistant_time).now().timestamp);
          if (zone_active) {
            stop_ts = 0;
            if (start_ts == 0) start_ts = now_s;
          } else {
            start_ts = 0;
            if (stop_ts == 0) stop_ts = now_s;
          }
          bool suppressed = (stop_ts  > 0 && (now_s - stop_ts)  < ${flow_sensor_post_stop_cooldown})
                         || (start_ts > 0 && (now_s - start_ts) < ${flow_sensor_post_start_settle});

          static uint16_t leak_ticks = 0;  // uint16 prevents wrap-around at 255 during sustained leaks
          if (lpm > ${flow_sensor_leak_threshold_lpm}f && !zone_active && !suppressed) {
            if (leak_ticks < 1000) leak_ticks++;  // Cap to prevent pathological overflow
            if (leak_ticks >= ${flow_sensor_leak_grace_ticks} && !id(flow_sensor_leak_detected)) {
              id(flow_sensor_leak_detected) = true;
              ESP_LOGW("flow", "LEAK: %.2f L/min sustained with no zone active!", lpm);
              {
                char _a[80]; snprintf(_a, sizeof(_a), "ğŸ’§ LEAK DETECTED: %.2f L/min (no zone active)", lpm);
                id(irrigation_latest_alert) = _a;
                id(irrigation_alert_sensor).publish_state(_a);
              }
            }
          } else {
            leak_ticks = 0;
            if (zone_active || lpm < ${flow_sensor_leak_threshold_lpm}f) id(flow_sensor_leak_detected) = false;
          }

          // Publish live values to HA (sensors use update_interval: never)
          id(flow_sensor_session_volume).publish_state(id(flow_sensor_session_litres));
          id(flow_leak_indicator).publish_state(id(flow_sensor_leak_detected) ? 1.0f : 0.0f);
          id(flow_leak_binary).publish_state(id(flow_sensor_leak_detected));

          ESP_LOGD("flow", "Flow: %.2fL/min | %.0f p/min | Session: %.2fL | Zone: %s | Leak: %s",
                   lpm, x, id(flow_sensor_session_litres),
                   zone_active ? "ON" : "off", id(flow_sensor_leak_detected) ? "YES" : "no");

  # â”€â”€ Valve Remaining Time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Seconds remaining on the active valve. Updates via the 1s interval.
  # Use in HA as a countdown timer or progress bar (divide by zone duration for %).
  - platform: template
    id: valve_remaining_seconds
    name: "$upper_devicename1 Valve Remaining Seconds"
    icon: "mdi:timer-outline"
    unit_of_measurement: "s"
    state_class: measurement
    accuracy_decimals: 0
    update_interval: never      # Published every second from the 1s interval
    lambda: |-
      if (!id($devicename1).active_valve().has_value()) return 0.0f;
      return (float)id($devicename1).time_remaining_active_valve().value_or(0);

  # â”€â”€ FLOW RATE display sensor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - platform: template
    id: flow_rate_lpm
    name: "$upper_devicename1 Flow Rate"
    icon: "mdi:water-pump"
    unit_of_measurement: "L/min"
    accuracy_decimals: 2
    device_class: water          # Enables HA water dashboard integration
    state_class: measurement     # Instantaneous flow rate
    update_interval: ${flow_sensor_update_interval}
    lambda: |-
      return id(flow_sensor_current_lpm);

  # â”€â”€ SESSION VOLUME display sensor (live during run, resets at zone start) â”€
  # update_interval: never â€” published directly from on_value each sensor tick
  # and from on_turn_off with the final accurate pulse-delta value.
  - platform: template
    id: flow_sensor_session_volume
    name: "$upper_devicename1 Flow Session Volume"
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    device_class: water          # HA water dashboard
    state_class: total_increasing
    update_interval: never
    lambda: |-
      return id(flow_sensor_session_litres);

  # â”€â”€ LEAK INDICATOR (0/1 numeric for HA dashboards) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # update_interval: never â€” published from on_value whenever leak state changes
  - platform: template
    id: flow_leak_indicator
    name: "$upper_devicename1 Leak Indicator"
    icon: "mdi:pipe-leak"
    unit_of_measurement: ""
    accuracy_decimals: 0
    update_interval: never
    lambda: |-
      return id(flow_sensor_leak_detected) ? 1.0f : 0.0f;


  # Uptime sensor
  - platform: uptime
    name: $upper_devicename1 Uptime
    internal: true

  # Internal sensors from Home Assistant (no template.publish here)
  - platform: homeassistant
    id: ha_temperature
    entity_id: $ha_weather_entity
    attribute: temperature
    internal: true

  # Humidity from weather forecast entity
  - platform: homeassistant
    id: ha_humidity
    entity_id: $ha_weather_forecast_entity
    attribute: humidity
    internal: true

  # Template sensors for display + fallback values
  - platform: template
    id: outside_temperature
    name: "Outside Temperature"
    icon: "mdi:thermometer"
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1
    lambda: |-
      if (isnan(id(ha_temperature).state)) {
        return 20.0;  // Default fallback temperature
      }
      return id(ha_temperature).state;

  - platform: template
    id: outside_humidity
    name: "Outside Humidity"
    icon: "mdi:water-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 60s
    lambda: |-
      if (isnan(id(ha_humidity).state)) {
        return 70.0;  // Default fallback humidity
      }
      return id(ha_humidity).state;
  
  # ============================================================
  # PREDICTIVE WATERINGâ„¢ WEATHER SENSORS
  # ============================================================
  # Wind speed sensor from Home Assistant
  - platform: homeassistant
    id: wind_speed
    entity_id: $ha_weather_entity
    attribute: wind_speed
    internal: true
    filters:
      - lambda: |-
          if (isnan(x)) return 10.0;  // Default 10 km/h

          return x;
  
  # Rain forecast (precipitation amount in mm) from Home Assistant template sensor
  # This uses actual precipitation forecast instead of probability - MORE ACCURATE!
  # Create this sensor in Home Assistant configuration.yaml:
  # template:
  #   - sensor:
  #       - name: "Rain Forecast Today"
  #         unique_id: home_rain_forecast_0d
  #         state: >
  #           {% set forecast = state_attr('YOUR_WEATHER_ENTITY', 'forecast') %}
  #           {% if forecast and forecast|length > 0 %}
  #             {{ forecast[0].precipitation | default(0) }}
  #           {% else %}
  #             0
  #           {% endif %}
  #         unit_of_measurement: "mm"
  # NOTE: Replace YOUR_WEATHER_ENTITY with your actual weather entity (e.g., weather.home)
  # Then update ha_rain_probability_entity in substitutions to match your sensor name
  - platform: homeassistant
    id: rain_probability
    entity_id: $ha_rain_probability_entity
    internal: true
    on_value:
      then:
        - lambda: |-
            // Only process valid numeric values
            if (!isnan(x) && x >= 0) {
              ESP_LOGD("irrigation", "Precipitation forecast updated: %.1f mm", x);
            }
        # Update forecast summary immediately
        - component.update: lawn_rain_forecast_summary
        # IMMEDIATE CHECK: Run rain delay logic when forecast updates
        - script.execute: check_forecast_rain_delay
    filters:
      - lambda: |-
          // Reject unavailable, unknown, or invalid values
          if (isnan(x) || x < 0) {
            // Keep previous value, don't update
            return {};
          }
          return x;  // Return actual mm value

  # ============================================================
  # ADVANCED FORECAST SYSTEM
  # ============================================================
  # Import hourly rain forecast sensor from Home Assistant
  # This sensor must be created in HA configuration.yaml first!
  # See Anthropic/ESPHome documentation for HA sensor configuration
  
  - platform: homeassistant
    id: rain_forecast_1h
    entity_id: $ha_rain_forecast_1h_entity
    internal: true
    filters:
      - lambda: |-
          if (isnan(x) || x < 0) return 0.0;
          return x;
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("forecast", "ğŸŒ§ï¸ Rain forecast 1h updated: %.2fmm", x);
        # Update forecast summary immediately
        - component.update: lawn_rain_forecast_summary
        # IMMEDIATE CHECK: Run rain delay logic when forecast updates
        - script.execute: check_forecast_rain_delay

  # Predictive Watering Multiplier Display
  - platform: template
    name: "$dev1_what Predictive Watering Multiplier"
    id: pw_multiplier_display
    icon: "mdi:water-percent"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 10s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_current_multiplier);
      }
      return {};

  # Individual factor displays
  - platform: template
    name: "$dev1_what PW Temperature Factor"
    icon: "mdi:thermometer"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_temperature_factor);
      }
      return {};

  - platform: template
    name: "$dev1_what PW Humidity Factor"
    icon: "mdi:water-percent"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_humidity_factor);
      }
      return {};

  - platform: template
    name: "$dev1_what PW Wind Factor"
    icon: "mdi:weather-windy"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_wind_factor);
      }
      return {};

  - platform: template
    name: "$dev1_what PW Rain Factor"
    icon: "mdi:weather-rainy"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      if (id(predictive_watering_enabled)) {
        return id(pw_rain_factor);
      }
      return {};
  
  # ============================================================
  # SMART ET WATERING SENSORS
  # ============================================================
  - platform: template
    name: "$dev1_what ET Soil Moisture Deficit"
    id: et_deficit_display
    icon: "mdi:water-minus"
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    update_interval: 10s
    lambda: |-
      if (id(smart_et_enabled)) {
        return id(et_soil_moisture_deficit);
      }
      return {};

  - platform: template
    name: "$dev1_what ET Daily Evapotranspiration"
    icon: "mdi:water-outline"
    unit_of_measurement: "mm/day"
    accuracy_decimals: 1
    update_interval: 30s
    lambda: |-
      if (id(smart_et_enabled)) {
        return id(et_daily_et);
      }
      return {};

  - platform: template
    name: "$dev1_what ET Deficit Percentage"
    icon: "mdi:water-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      if (id(smart_et_enabled)) {
        float threshold = id(et_water_threshold);
        if (threshold > 0) {
          float pct = (id(et_soil_moisture_deficit) / threshold) * 100.0;
          if (pct > 100) pct = 100;
          return pct;
        }
      }
      return {};
  
  # Smart ET Duration Multiplier (shows deficit-based adjustment)
  - platform: template
    name: "$dev1_what ET Duration Multiplier"
    icon: "mdi:multiplication"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 10s
    lambda: |-
      if (id(smart_et_enabled)) {
        return id(et_duration_multiplier);
      }
      return {};
    
  # Rain delay countdown
  - platform: template
    id: rain_delay_remaining
    name: "Rain Delay Days Remaining"
    icon: "mdi:timer-sand"
    unit_of_measurement: "days"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      if (id(rain_delay_end_time) == 0) return 0.0f;
      int64_t current_time = id(homeassistant_time).now().timestamp;
      int64_t remaining_seconds = id(rain_delay_end_time) - current_time;
      if (remaining_seconds <= 0) {
        id(rain_delay_end_time) = 0;
        id(rain_delay_days) = 0;
        return 0.0f;
      }
      return remaining_seconds / (float)${seconds_per_day};

  # Current seasonal multiplier
  - platform: template
    id: seasonal_multiplier
    name: "Seasonal Multiplier"
    icon: "mdi:calendar-month"
    unit_of_measurement: "x"
    accuracy_decimals: 1
    update_interval: $sensor_hourly_update
    lambda: |-
      return id($devicename1).multiplier();

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ADVANCED FORECAST SYSTEM SENSORS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # ET Effective Deficit (accounts for forecast rain)
  - platform: template
    name: "$dev1_what ET Effective Deficit"
    id: et_effective_deficit
    icon: "mdi:water-minus-outline"
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    update_interval: 30min
    lambda: |-
      if (!id(smart_et_enabled)) {
        return {};
      }
      if (!id(forecast_enabled)) {
        return id(et_soil_moisture_deficit);
      }
      float deficit = id(et_soil_moisture_deficit);
      
      // Use dual forecast
      float rain_1h = id(rain_forecast_1h).state;
      float rain_0d = id(rain_probability).state;
      
      if (isnan(rain_1h) || rain_1h < 0) rain_1h = 0.0;
      if (isnan(rain_0d) || rain_0d < 0) rain_0d = 0.0;
      
      // Calculate expected rain (same logic as Smart ET)
      float expected_rain;
      if (rain_1h >= 2.0) {
        expected_rain = rain_1h + (rain_0d * 0.3);
      } else {
        expected_rain = rain_1h + (rain_0d * 0.7);
      }
      
      float effective = deficit - expected_rain;
      return (effective > 0) ? effective : 0;
  
  # Forecast Rain Factor (shows what Predictive Watering is using)
  - platform: template
    name: "$dev1_what Forecast Rain Factor"
    icon: "mdi:water-percent"
    unit_of_measurement: "x"
    accuracy_decimals: 2
    update_interval: 10min
    lambda: |-
      if (!id(forecast_enabled) || !id(predictive_watering_enabled)) {
        return 1.0;
      }
      
      // Use dual forecast like Predictive Watering does
      float rain_1h = id(rain_forecast_1h).state;
      float rain_0d = id(rain_probability).state;
      
      if (isnan(rain_1h) || rain_1h < 0) rain_1h = 0.0;
      if (isnan(rain_0d) || rain_0d < 0) rain_0d = 0.0;
      
      // Smart combined calculation
      float combined;
      if (rain_1h >= 5.0) {
        combined = rain_1h + (rain_0d * 0.2);
      } else if (rain_1h >= 2.0) {
        combined = rain_1h + (rain_0d * 0.5);
      } else {
        combined = rain_1h + (rain_0d * 0.8);
      }
      
      // Calculate factor based on combined forecast
      if (combined > 10.0) return 0.2;
      else if (combined > 5.0) return 0.3;
      else if (combined > 2.0) return 0.5;
      else if (combined > 1.0) return 0.7;
      else if (combined > 0.5) return 0.85;
      else if (combined > 0.1) return 0.95;
      return 1.0;

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER USAGE TRACKING SENSORS (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Zone 1 Water Used
  - platform: template
    name: "$dev1_zone1 Water Used"
    id: zone1_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone1_water_litres);"
    
  # Zone 2 Water Used
  - platform: template
    name: "$dev1_zone2 Water Used"
    id: zone2_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone2_water_litres);"
    
  # Zone 3 Water Used
  - platform: template
    name: "$dev1_zone3 Water Used"
    id: zone3_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone3_water_litres);"
    
  # Zone 4 Water Used
  - platform: template
    name: "$dev1_zone4 Water Used"
    id: zone4_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone4_water_litres);"
    
  # Zone 5 Water Used
  - platform: template
    name: "$dev1_zone5 Water Used"
    id: zone5_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone5_water_litres);"
    
  # Zone 6 Water Used
  - platform: template
    name: "$dev1_zone6 Water Used"
    id: zone6_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone6_water_litres);"
    
  # Zone 7 Water Used
  - platform: template
    name: "$dev1_zone7 Water Used"
    id: zone7_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone7_water_litres);"
    
  # Zone 8 Water Used
  - platform: template
    name: "$dev1_zone8 Water Used"
    id: zone8_water_sensor
    icon: "mdi:water"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: "return id(zone8_water_litres);"
    
  # Total System Water Used
  - platform: template
    name: "$dev1_what Total Water Used"
    id: total_water_sensor
    icon: "mdi:water-pump"
    unit_of_measurement: "L"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: water
    update_interval: 10s
    lambda: |-
      return id(total_water_litres);
  
  # Days Into Current Water Budget Period
  - platform: template
    name: "$dev1_what Days Into Budget Period"
    icon: "mdi:calendar-clock"
    unit_of_measurement: "days"
    accuracy_decimals: 1
    update_interval: 60s
    lambda: |-
      if (id(water_reset_timestamp) == 0) {
        return 0.0;
      }
      int64_t now = id(homeassistant_time).now().timestamp;
      float days = (now - id(water_reset_timestamp)) / (float)${seconds_per_day};
      return days;

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Active Blackout Dates Counter
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "ğŸ“… Active Blackout Dates"
    id: active_blackout_count
    icon: "mdi:calendar-check"
    unit_of_measurement: "dates"
    accuracy_decimals: 0
    update_interval: 5s
    lambda: |-
      int count = 0;
      if (id(blackout_date_1) > 0) count++;
      if (id(blackout_date_2) > 0) count++;
      if (id(blackout_date_3) > 0) count++;
      if (id(blackout_date_4) > 0) count++;
      if (id(blackout_date_5) > 0) count++;
      if (id(blackout_date_6) > 0) count++;
      if (id(blackout_date_7) > 0) count++;
      if (id(blackout_date_8) > 0) count++;
      if (id(blackout_date_9) > 0) count++;
      if (id(blackout_date_10) > 0) count++;
      return count;


###############################################
# Binary Sensors (Status Indicators)
###############################################
binary_sensor:
  # Master Valve Status
  # â”€â”€ YF-B5 Leak Detection Binary Sensor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # update_interval: never â€” published from on_value when leak state changes
  - platform: template
    name: "$upper_devicename1 Leak Detected"
    id: flow_leak_binary
    icon: "mdi:pipe-leak"
    device_class: problem
    lambda: |-
      return id(flow_sensor_leak_detected);

  - platform: template
    name: "$dev1_what Master Valve Status"
    id: master_valve_status_sensor
    icon: "mdi:valve"
    device_class: opening
    lambda: "return id(master_valve_relay).state;"
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLACKOUT DATE DETECTION - Checks if today is a holiday/mowing day
  # â”€â”€ Combined safety gate â€” consolidates all system-level checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # All per-zone checks (zone enable, daily runtime) still happen in request_zone_start.
  # update_interval: 5s keeps the state fresh without hammering the CPU.
  - platform: template
    id: is_safe_to_water
    name: "$upper_devicename1 Safe To Water"
    icon: "mdi:check-circle"
    device_class: running
    lambda: |-
      // Must be paused-free, system-enabled, not frozen, within budget,
      // no rain delay, inside watering window, no blackout, weather OK.
      if (id(is_paused)) return false;
      if (!id(irrigation_system_enable).state) return false;
      if (id(freeze_protection_active)) return false;
      if (id(budget_exceeded) && !id(budget_override_active)) return false;
      auto _stw_now = id(homeassistant_time).now();
      if (_stw_now.is_valid() && id(rain_delay_end_time) > _stw_now.timestamp) return false;
      if (id(is_time_restricted)) return false;
      if (id(is_blackout_date).state) return false;
      if (!id(manual_weather_override)) {
        std::string _stw_w = id(weather_forecast_home).state;
        if (!_stw_w.empty() && _stw_w != "unknown" && _stw_w != "unavailable") {
          if (_stw_w == "rainy" || _stw_w == "pouring" || _stw_w == "snowy" || _stw_w == "snowy-rainy")
            return false;
        }
      }
      return true;

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    id: is_blackout_date
    name: "$dev1_what Irrigation Blackout Active"
    icon: "mdi:cancel"
    device_class: problem
    lambda: |-
      // B2 FIX: Block during boot sync window (first 2 min), then allow if time never syncs.
      // This prevents permanent irrigation lockout if HA connection is lost indefinitely,
      // while still protecting against spurious schedules firing before the clock is set.
      auto now = id(homeassistant_time).now();
      if (!now.is_valid()) {
        // Block for up to 2 minutes after boot to let HA time sync
        return (millis() < 120000UL);
      }

      // Build today string once (stack buffer â€” no heap alloc)
      char today_str[11];
      snprintf(today_str, sizeof(today_str), "%04d-%02d-%02d", now.year, now.month, now.day_of_month);

      bool is_blackout = false;
      const char* reason = "";

      // CHECK 1: Manual blackout slots 1-10
      // Each slot: parse ESPTime struct ONCE (B3 fix: was calling from_epoch_local twice per slot)
      {
        int64_t _dates[] = {id(blackout_date_1),id(blackout_date_2),id(blackout_date_3),id(blackout_date_4),id(blackout_date_5),
                         id(blackout_date_6),id(blackout_date_7),id(blackout_date_8),id(blackout_date_9),id(blackout_date_10)};
        int _ty = now.year; int _td = now.day_of_year;

        for (int _i = 0; _i < 10; _i++) {
          if (_dates[_i] > 0) {
            auto _et = ESPTime::from_epoch_local(_dates[_i]);  // Parse once, check both fields
            if (_et.year == _ty && _et.day_of_year == _td) {
              is_blackout = true;
              // Use existing description string directly â€” no copy (P2 fix: was building 10-string array)
              const std::string& _desc = [&]() -> const std::string& {
                switch(_i) {
                  case 0: return id(blackout_desc_1);
                  case 1: return id(blackout_desc_2);
                  case 2: return id(blackout_desc_3);
                  case 3: return id(blackout_desc_4);
                  case 4: return id(blackout_desc_5);
                  case 5: return id(blackout_desc_6);
                  case 6: return id(blackout_desc_7);
                  case 7: return id(blackout_desc_8);
                  case 8: return id(blackout_desc_9);
                  default: return id(blackout_desc_10);
                }
              }();
              reason = _desc.empty() ? "Blackout date" : _desc.c_str();
              break;
            }
          }
        }
      }

      // CHECK 2: NZ Public Holidays â€” compare char buffers (P3 fix: was allocating 5 std::strings)
      if (!is_blackout) {
        struct { const char* name; bool has; const char* state; } holidays[] = {
          { "Good Friday",    id(nz_good_friday_date).has_state(),   id(nz_good_friday_date).has_state()   ? id(nz_good_friday_date).state.c_str()   : "" },
          { "Easter Monday",  id(nz_easter_monday_date).has_state(), id(nz_easter_monday_date).has_state() ? id(nz_easter_monday_date).state.c_str() : "" },
          { "Kings Birthday", id(nz_kings_birthday_date).has_state(),id(nz_kings_birthday_date).has_state()? id(nz_kings_birthday_date).state.c_str(): "" },
          { "Labour Day",     id(nz_labour_day_date).has_state(),    id(nz_labour_day_date).has_state()    ? id(nz_labour_day_date).state.c_str()    : "" },
          { "Matariki",       id(nz_matariki_date).has_state(),      id(nz_matariki_date).has_state()      ? id(nz_matariki_date).state.c_str()      : "" },
        };
        for (auto& h : holidays) {
          if (h.has && h.state[0] != '\0' &&
              strncmp(h.state, "unavailable", 11) != 0 &&
              strncmp(h.state, "unknown", 7) != 0 &&
              strncmp(h.state, today_str, 10) == 0) {
            is_blackout = true;
            reason = h.name;
            break;
          }
        }
      }

      // Log once per hour to prevent spam
      if (is_blackout) {
        int64_t now_ts = now.timestamp;  // Reuse already-fetched time â€” no extra .now() call
        if (now_ts - id(last_blackout_log_time) >= ${seconds_per_hour}) {
          ESP_LOGW("blackout", "ğŸš« BLACKOUT ACTIVE: %s (%s)", reason, today_str);
          id(last_blackout_log_time) = now_ts;
        }
      }

      return is_blackout;

###############################################
# Configuration to set multiplier via number
###############################################
number:
  # Manual multiplier override
  - platform: template
    id: "${dev1_what}_multiplier"
    name: "${devicename1}_multiplier"
    min_value: 0.01
    max_value: 2.00
    step: 0.01
    icon: "mdi:water-percent"
    mode: slider
    lambda: "return id($devicename1).multiplier();"
    set_action:
      - sprinkler.set_multiplier:
          id: $devicename1
          multiplier: !lambda 'return x;'

  # Rain delay days
  - platform: template
    id: rain_delay_days_input
    name: "Rain Delay Days"
    min_value: 0
    max_value: 14
    step: 1
    icon: "mdi:weather-rainy"
    mode: box
    lambda: "return id(rain_delay_days);"
    set_action:
      - lambda: |-
          id(rain_delay_days) = x;
          if (x > 0) {
            auto _rd_time = id(homeassistant_time).now();
            if (!_rd_time.is_valid()) {
              ESP_LOGW("irrigation", "âš ï¸ Rain delay set but time not synced â€” end time will be corrected when time syncs");
              id(rain_delay_end_time) = 0;  // Will be set correctly once time syncs
            } else {
              id(rain_delay_end_time) = _rd_time.timestamp + (x * ${seconds_per_day});
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ Rain delay set: %d day(s)", (int)x);
              {
                char _a[80]; snprintf(_a, sizeof(_a), "ğŸŒ§ï¸ MANUAL RAIN DELAY: %d day(s)", (int)x);
                id(irrigation_latest_alert) = _a;
                id(irrigation_alert_sensor).publish_state(_a);
              }
            }
          } else {
            id(rain_delay_end_time) = 0;
          }

  # Smart ET watering threshold
  - platform: template
    id: et_threshold_input
    name: "$dev1_what ET Water Threshold"
    min_value: 10
    max_value: 50
    step: 1
    icon: "mdi:water-alert"

    mode: slider
    unit_of_measurement: "mm"
    lambda: "return id(et_water_threshold);"
    set_action:
      - lambda: |-
          id(et_water_threshold) = x;
          ESP_LOGI("irrigation", "ET threshold updated to %.0f mm", x);

  # Quick run duration
  - platform: template
    id: quick_run_duration
    name: "Quick Run Duration"
    min_value: 1
    max_value: 15
    step: 1
    initial_value: ${default_quick_run_min}
    icon: "mdi:timer"
    mode: slider
    unit_of_measurement: "min"
    optimistic: true
    restore_value: True  # USER SETTING - must persist across reboots

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ZONE FLOW RATES (For Water Usage Tracking)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    id: zone1_flow_rate_input
    name: "$dev1_zone1 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone1_flow_rate);"
    set_action:
      - lambda: "id(zone1_flow_rate) = x;"
      
  - platform: template
    id: zone2_flow_rate_input
    name: "$dev1_zone2 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone2_flow_rate);"
    set_action:
      - lambda: "id(zone2_flow_rate) = x;"
      
  - platform: template
    id: zone3_flow_rate_input
    name: "$dev1_zone3 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone3_flow_rate);"
    set_action:
      - lambda: "id(zone3_flow_rate) = x;"
      
  - platform: template
    id: zone4_flow_rate_input
    name: "$dev1_zone4 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone4_flow_rate);"
    set_action:
      - lambda: "id(zone4_flow_rate) = x;"
      
  - platform: template
    id: zone5_flow_rate_input
    name: "$dev1_zone5 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone5_flow_rate);"
    set_action:
      - lambda: "id(zone5_flow_rate) = x;"
      
  - platform: template
    id: zone6_flow_rate_input
    name: "$dev1_zone6 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone6_flow_rate);"
    set_action:
      - lambda: "id(zone6_flow_rate) = x;"
      
  - platform: template
    id: zone7_flow_rate_input
    name: "$dev1_zone7 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone7_flow_rate);"
    set_action:
      - lambda: "id(zone7_flow_rate) = x;"
      
  - platform: template
    id: zone8_flow_rate_input
    name: "$dev1_zone8 Flow Rate"
    min_value: 1
    max_value: 100
    step: 0.5
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L/min"
    lambda: "return id(zone8_flow_rate);"
    set_action:
      - lambda: "id(zone8_flow_rate) = x;"

# Schedule start hour (12-hour format)
  - platform: template
    id: schedule_start_hour
    name: "Weekly Schedule Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    initial_value: 6
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    optimistic: true
    restore_value: True  # USER SETTING - must persist across reboots

# Schedule start minute
  - platform: template
    id: schedule_start_minute
    name: "Weekly Schedule Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    optimistic: true
    restore_value: True  # USER SETTING - must persist across reboots

# Cycle duration
  - platform: template
    id: cycle_duration_input
    name: "Cycle Duration"
    min_value: 3
    max_value: 20
    step: 1
    icon: "mdi:timer-play"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(cycle_duration_minutes);"
    set_action:
      - lambda: "id(cycle_duration_minutes) = x;"

  # Soak duration
  - platform: template
    id: soak_duration_input
    name: "Soak Duration"
    min_value: 3         # Match cycle minimum
    max_value: 20        # Match cycle maximum
    step: 1
    icon: "mdi:timer-pause"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(soak_duration_minutes);"
    set_action:
      - lambda: "id(soak_duration_minutes) = x;"

# Station delay between zones
  - platform: template
    id: station_delay_input
    name: "Station Delay Between Zones"
    min_value: 0
    max_value: 60
    step: 5
    icon: "mdi:timer-cog"
    mode: slider
    unit_of_measurement: "sec"
    lambda: "return id(station_delay_seconds);"
    set_action:
      - lambda: "id(station_delay_seconds) = x;"


  # Time Restriction Window (12-hour format)
  - platform: template
    id: restrict_start_hour_input
    name: "Time Restriction Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(restrict_start_hour);"
    set_action:
      - lambda: "id(restrict_start_hour) = (int)x;"

  - platform: template
    id: restrict_start_minute_input
    name: "Time Restriction Start Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(restrict_start_minute);"
    set_action:
      - lambda: "id(restrict_start_minute) = (int)x;"

  - platform: template
    id: restrict_end_hour_input
    name: "Time Restriction End Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(restrict_end_hour);"
    set_action:
      - lambda: "id(restrict_end_hour) = (int)x;"

  - platform: template
    id: restrict_end_minute_input
    name: "Time Restriction End Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(restrict_end_minute);"
    set_action:
      - lambda: "id(restrict_end_minute) = (int)x;"

# Zone 1 Schedule Time
  - platform: template
    id: zone1_schedule_hour
    name: "${dev1_zone1} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone1_start_hour);"
    set_action:
      - lambda: "id(zone1_start_hour) = x;"

  - platform: template
    id: zone1_schedule_minute
    name: "${dev1_zone1} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone1_start_minute);"
    set_action:
      - lambda: "id(zone1_start_minute) = x;"

# Zone 2 Schedule Time
  - platform: template
    id: zone2_schedule_hour
    name: "${dev1_zone2} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone2_start_hour);"
    set_action:
      - lambda: "id(zone2_start_hour) = x;"

  - platform: template
    id: zone2_schedule_minute
    name: "${dev1_zone2} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone2_start_minute);"
    set_action:
      - lambda: "id(zone2_start_minute) = x;"

  # Zone 3 Schedule Time
  - platform: template
    id: zone3_schedule_hour
    name: "${dev1_zone3} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone3_start_hour);"
    set_action:
      - lambda: "id(zone3_start_hour) = x;"

  - platform: template
    id: zone3_schedule_minute
    name: "${dev1_zone3} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone3_start_minute);"
    set_action:
      - lambda: "id(zone3_start_minute) = x;"

  # Zone 4 Schedule Time
  - platform: template
    id: zone4_schedule_hour
    name: "${dev1_zone4} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone4_start_hour);"
    set_action:
      - lambda: "id(zone4_start_hour) = x;"

  - platform: template
    id: zone4_schedule_minute
    name: "${dev1_zone4} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone4_start_minute);"
    set_action:
      - lambda: "id(zone4_start_minute) = x;"

  # Zone 5 Schedule Time
  - platform: template
    id: zone5_schedule_hour
    name: "${dev1_zone5} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone5_start_hour);"
    set_action:
      - lambda: "id(zone5_start_hour) = x;"

  - platform: template
    id: zone5_schedule_minute
    name: "${dev1_zone5} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone5_start_minute);"
    set_action:
      - lambda: "id(zone5_start_minute) = x;"

  # Zone 6 Schedule Time
  - platform: template
    id: zone6_schedule_hour
    name: "${dev1_zone6} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone6_start_hour);"
    set_action:
      - lambda: "id(zone6_start_hour) = x;"

  - platform: template
    id: zone6_schedule_minute
    name: "${dev1_zone6} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone6_start_minute);"
    set_action:
      - lambda: "id(zone6_start_minute) = x;"

  # Zone 7 Schedule Time
  - platform: template
    id: zone7_schedule_hour
    name: "${dev1_zone7} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone7_start_hour);"
    set_action:
      - lambda: "id(zone7_start_hour) = x;"

  - platform: template
    id: zone7_schedule_minute
    name: "${dev1_zone7} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone7_start_minute);"
    set_action:
      - lambda: "id(zone7_start_minute) = x;"

  # Zone 8 Schedule Time
  - platform: template
    id: zone8_schedule_hour
    name: "${dev1_zone8} Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone8_start_hour);"
    set_action:
      - lambda: "id(zone8_start_hour) = x;"

  - platform: template
    id: zone8_schedule_minute
    name: "${dev1_zone8} Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone8_start_minute);"
    set_action:
      - lambda: "id(zone8_start_minute) = x;"

# Program 1 start time
  - platform: template
    id: program_a_start_hour_input
    name: "${program_a_name} Start #1 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_a_start_hour);"
    set_action:
      - lambda: "id(program_a_start_hour) = x;"

  - platform: template
    id: program_a_start_minute_input
    name: "${program_a_name} Start #1 - Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_a_start_minute);"
    set_action:
      - lambda: "id(program_a_start_minute) = x;"

  - platform: template
    id: program_a_interval_input
    name: "${program_a_name} Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_a_interval_days);"
    set_action:
      - lambda: "id(program_a_interval_days) = x;"

  # Program 2 start time
  - platform: template
    id: program_b_start_hour_input
    name: "${program_b_name} Start #1 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_b_start_hour);"
    set_action:
      - lambda: "id(program_b_start_hour) = x;"

  - platform: template
    id: program_b_start_minute_input
    name: "${program_b_name} Start #1 - Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_b_start_minute);"
    set_action:
      - lambda: "id(program_b_start_minute) = x;"

  - platform: template
    id: program_b_interval_input
    name: "${program_b_name} Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_b_interval_days);"
    set_action:
      - lambda: "id(program_b_interval_days) = x;"

  # Program 3 start time
  - platform: template
    id: program_c_start_hour_input
    name: "${program_c_name} Start #1 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_c_start_hour);"
    set_action:
      - lambda: "id(program_c_start_hour) = x;"

  - platform: template
    id: program_c_start_minute_input
    name: "${program_c_name} Start #1 - Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_c_start_minute);"
    set_action:
      - lambda: "id(program_c_start_minute) = x;"

  - platform: template
    id: program_c_interval_input
    name: "${program_c_name} Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_c_interval_days);"
    set_action:
      - lambda: "id(program_c_interval_days) = x;"
# Insert this section after line 6156 (after program_c_interval_input)

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UI CONTROLS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # OPTION 1: MULTIPLE START TIMES (up to 4 per program)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  # â”€â”€â”€ PROGRAM A - ADDITIONAL START TIMES â”€â”€â”€
  - platform: template
    id: program_a_start_hour_2_input
    name: "${program_a_name} Start #2 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_a_start_hour_2);"
    set_action:
      - lambda: "id(program_a_start_hour_2) = x;"
  
  - platform: template
    id: program_a_start_minute_2_input
    name: "${program_a_name} Start #2 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_a_start_minute_2);"
    set_action:
      - lambda: "id(program_a_start_minute_2) = x;"
  
  - platform: template
    id: program_a_start_hour_3_input
    name: "${program_a_name} Start #3 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_a_start_hour_3);"
    set_action:
      - lambda: "id(program_a_start_hour_3) = x;"
  
  - platform: template
    id: program_a_start_minute_3_input
    name: "${program_a_name} Start #3 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_a_start_minute_3);"
    set_action:
      - lambda: "id(program_a_start_minute_3) = x;"
  
  - platform: template
    id: program_a_start_hour_4_input
    name: "${program_a_name} Start #4 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_a_start_hour_4);"
    set_action:
      - lambda: "id(program_a_start_hour_4) = x;"
  
  - platform: template
    id: program_a_start_minute_4_input
    name: "${program_a_name} Start #4 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_a_start_minute_4);"
    set_action:
      - lambda: "id(program_a_start_minute_4) = x;"
  
  # â”€â”€â”€ PROGRAM B - ADDITIONAL START TIMES â”€â”€â”€
  - platform: template
    id: program_b_start_hour_2_input
    name: "${program_b_name} Start #2 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_b_start_hour_2);"
    set_action:
      - lambda: "id(program_b_start_hour_2) = x;"
  
  - platform: template
    id: program_b_start_minute_2_input
    name: "${program_b_name} Start #2 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_b_start_minute_2);"
    set_action:
      - lambda: "id(program_b_start_minute_2) = x;"
  
  - platform: template
    id: program_b_start_hour_3_input
    name: "${program_b_name} Start #3 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_b_start_hour_3);"
    set_action:
      - lambda: "id(program_b_start_hour_3) = x;"
  
  - platform: template
    id: program_b_start_minute_3_input
    name: "${program_b_name} Start #3 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_b_start_minute_3);"
    set_action:
      - lambda: "id(program_b_start_minute_3) = x;"
  
  - platform: template
    id: program_b_start_hour_4_input
    name: "${program_b_name} Start #4 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_b_start_hour_4);"
    set_action:
      - lambda: "id(program_b_start_hour_4) = x;"
  
  - platform: template
    id: program_b_start_minute_4_input
    name: "${program_b_name} Start #4 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_b_start_minute_4);"
    set_action:
      - lambda: "id(program_b_start_minute_4) = x;"
  
  # â”€â”€â”€ PROGRAM C - ADDITIONAL START TIMES â”€â”€â”€
  - platform: template
    id: program_c_start_hour_2_input
    name: "${program_c_name} Start #2 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_c_start_hour_2);"
    set_action:
      - lambda: "id(program_c_start_hour_2) = x;"
  
  - platform: template
    id: program_c_start_minute_2_input
    name: "${program_c_name} Start #2 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_c_start_minute_2);"
    set_action:
      - lambda: "id(program_c_start_minute_2) = x;"
  
  - platform: template
    id: program_c_start_hour_3_input
    name: "${program_c_name} Start #3 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_c_start_hour_3);"
    set_action:
      - lambda: "id(program_c_start_hour_3) = x;"
  
  - platform: template
    id: program_c_start_minute_3_input
    name: "${program_c_name} Start #3 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_c_start_minute_3);"
    set_action:
      - lambda: "id(program_c_start_minute_3) = x;"
  
  - platform: template
    id: program_c_start_hour_4_input
    name: "${program_c_name} Start #4 - Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_c_start_hour_4);"
    set_action:
      - lambda: "id(program_c_start_hour_4) = x;"
  
  - platform: template
    id: program_c_start_minute_4_input
    name: "${program_c_name} Start #4 - Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-plus"
    mode: box
    lambda: "return id(program_c_start_minute_4);"
    set_action:
      - lambda: "id(program_c_start_minute_4) = x;"
  
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # OPTION 2: PER-PROGRAM ZONE DURATIONS (8 zones Ã— 3 programs)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # NOTE: Set to 0 to use the zone's default duration
  
  # â”€â”€â”€ ZONE 1 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone1_program_a_duration_input
    name: "$dev1_zone1 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone1_program_a_duration);"
    set_action:
      - lambda: "id(zone1_program_a_duration) = x;"
  
  - platform: template
    id: zone1_program_b_duration_input
    name: "$dev1_zone1 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone1_program_b_duration);"
    set_action:
      - lambda: "id(zone1_program_b_duration) = x;"
  
  - platform: template
    id: zone1_program_c_duration_input
    name: "$dev1_zone1 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone1_program_c_duration);"
    set_action:
      - lambda: "id(zone1_program_c_duration) = x;"
  
  # â”€â”€â”€ ZONE 2 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone2_program_a_duration_input
    name: "$dev1_zone2 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone2_program_a_duration);"
    set_action:
      - lambda: "id(zone2_program_a_duration) = x;"
  
  - platform: template
    id: zone2_program_b_duration_input
    name: "$dev1_zone2 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone2_program_b_duration);"
    set_action:
      - lambda: "id(zone2_program_b_duration) = x;"
  
  - platform: template
    id: zone2_program_c_duration_input
    name: "$dev1_zone2 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone2_program_c_duration);"
    set_action:
      - lambda: "id(zone2_program_c_duration) = x;"
  
  # â”€â”€â”€ ZONE 3 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone3_program_a_duration_input
    name: "$dev1_zone3 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone3_program_a_duration);"
    set_action:
      - lambda: "id(zone3_program_a_duration) = x;"
  
  - platform: template
    id: zone3_program_b_duration_input
    name: "$dev1_zone3 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone3_program_b_duration);"
    set_action:
      - lambda: "id(zone3_program_b_duration) = x;"
  
  - platform: template
    id: zone3_program_c_duration_input
    name: "$dev1_zone3 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone3_program_c_duration);"
    set_action:
      - lambda: "id(zone3_program_c_duration) = x;"
  
  # â”€â”€â”€ ZONE 4 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone4_program_a_duration_input
    name: "$dev1_zone4 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone4_program_a_duration);"
    set_action:
      - lambda: "id(zone4_program_a_duration) = x;"
  
  - platform: template
    id: zone4_program_b_duration_input
    name: "$dev1_zone4 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone4_program_b_duration);"
    set_action:
      - lambda: "id(zone4_program_b_duration) = x;"
  
  - platform: template
    id: zone4_program_c_duration_input
    name: "$dev1_zone4 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone4_program_c_duration);"
    set_action:
      - lambda: "id(zone4_program_c_duration) = x;"
  
  # â”€â”€â”€ ZONE 5 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone5_program_a_duration_input
    name: "$dev1_zone5 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone5_program_a_duration);"
    set_action:
      - lambda: "id(zone5_program_a_duration) = x;"
  
  - platform: template
    id: zone5_program_b_duration_input
    name: "$dev1_zone5 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone5_program_b_duration);"
    set_action:
      - lambda: "id(zone5_program_b_duration) = x;"
  
  - platform: template
    id: zone5_program_c_duration_input
    name: "$dev1_zone5 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone5_program_c_duration);"
    set_action:
      - lambda: "id(zone5_program_c_duration) = x;"
  
  # â”€â”€â”€ ZONE 6 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone6_program_a_duration_input
    name: "$dev1_zone6 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone6_program_a_duration);"
    set_action:
      - lambda: "id(zone6_program_a_duration) = x;"
  
  - platform: template
    id: zone6_program_b_duration_input
    name: "$dev1_zone6 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone6_program_b_duration);"
    set_action:
      - lambda: "id(zone6_program_b_duration) = x;"
  
  - platform: template
    id: zone6_program_c_duration_input
    name: "$dev1_zone6 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone6_program_c_duration);"
    set_action:
      - lambda: "id(zone6_program_c_duration) = x;"
  
  # â”€â”€â”€ ZONE 7 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone7_program_a_duration_input
    name: "$dev1_zone7 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone7_program_a_duration);"
    set_action:
      - lambda: "id(zone7_program_a_duration) = x;"
  
  - platform: template
    id: zone7_program_b_duration_input
    name: "$dev1_zone7 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone7_program_b_duration);"
    set_action:
      - lambda: "id(zone7_program_b_duration) = x;"
  
  - platform: template
    id: zone7_program_c_duration_input
    name: "$dev1_zone7 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone7_program_c_duration);"
    set_action:
      - lambda: "id(zone7_program_c_duration) = x;"
  
  # â”€â”€â”€ ZONE 8 PROGRAM DURATIONS â”€â”€â”€
  - platform: template
    id: zone8_program_a_duration_input
    name: "$dev1_zone8 â†’ ${program_a_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone8_program_a_duration);"
    set_action:
      - lambda: "id(zone8_program_a_duration) = x;"
  
  - platform: template
    id: zone8_program_b_duration_input
    name: "$dev1_zone8 â†’ ${program_b_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone8_program_b_duration);"
    set_action:
      - lambda: "id(zone8_program_b_duration) = x;"
  
  - platform: template
    id: zone8_program_c_duration_input
    name: "$dev1_zone8 â†’ ${program_c_name} Duration (0=default)"
    min_value: 0
    max_value: 90
    step: 1
    icon: "mdi:timer-sand"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone8_program_c_duration);"
    set_action:
      - lambda: "id(zone8_program_c_duration) = x;"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SEASONAL ADJUSTMENT MULTIPLIERS (Whanganui - Southern Hemisphere)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    id: seasonal_jan_input
    name: "$dev1_what Seasonal Jan"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_jan);"
    set_action:
      - lambda: "id(seasonal_jan) = x;"

  - platform: template
    id: seasonal_feb_input
    name: "$dev1_what Seasonal Feb"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_feb);"
    set_action:
      - lambda: "id(seasonal_feb) = x;"

  - platform: template
    id: seasonal_mar_input
    name: "$dev1_what Seasonal Mar"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_mar);"
    set_action:
      - lambda: "id(seasonal_mar) = x;"

  - platform: template
    id: seasonal_apr_input
    name: "$dev1_what Seasonal Apr"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_apr);"
    set_action:
      - lambda: "id(seasonal_apr) = x;"

  - platform: template
    id: seasonal_may_input
    name: "$dev1_what Seasonal May"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_may);"
    set_action:
      - lambda: "id(seasonal_may) = x;"

  - platform: template
    id: seasonal_jun_input
    name: "$dev1_what Seasonal Jun"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_jun);"
    set_action:
      - lambda: "id(seasonal_jun) = x;"

  - platform: template
    id: seasonal_jul_input
    name: "$dev1_what Seasonal Jul"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_jul);"
    set_action:
      - lambda: "id(seasonal_jul) = x;"

  - platform: template
    id: seasonal_aug_input
    name: "$dev1_what Seasonal Aug"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_aug);"
    set_action:
      - lambda: "id(seasonal_aug) = x;"

  - platform: template
    id: seasonal_sep_input
    name: "$dev1_what Seasonal Sep"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_sep);"
    set_action:
      - lambda: "id(seasonal_sep) = x;"

  - platform: template
    id: seasonal_oct_input
    name: "$dev1_what Seasonal Oct"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_oct);"
    set_action:
      - lambda: "id(seasonal_oct) = x;"

  - platform: template
    id: seasonal_nov_input
    name: "$dev1_what Seasonal Nov"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_nov);"
    set_action:
      - lambda: "id(seasonal_nov) = x;"

  - platform: template
    id: seasonal_dec_input
    name: "$dev1_what Seasonal Dec"
    min_value: 0.5
    max_value: 2.0
    step: 0.1
    icon: "mdi:calendar-month"
    mode: slider
    lambda: "return id(seasonal_dec);"
    set_action:
      - lambda: "id(seasonal_dec) = x;"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PRODUCTION FEATURES - UI CONTROLS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Freeze Protection Threshold
  - platform: template
    id: freeze_threshold_input
    name: "$dev1_what Freeze Threshold"
    min_value: -5
    max_value: 10
    step: 0.5
    icon: "mdi:snowflake-thermometer"
    mode: box
    unit_of_measurement: "Â°C"
    lambda: "return id(freeze_threshold);"
    set_action:
      - lambda: |-
          id(freeze_threshold) = x;
          ESP_LOGI("irrigation", "â„ï¸ Freeze threshold set to %.1fÂ°C", x);
  
  # Monthly Water Budget
  - platform: template
    id: monthly_budget_input
    name: "$dev1_what Monthly Water Budget"
    min_value: 1000
    max_value: 100000
    step: 100
    icon: "mdi:water-pump"
    mode: box
    unit_of_measurement: "L"
    lambda: "return id(monthly_water_budget);"
    set_action:
      - lambda: |-
          id(monthly_water_budget) = x;
          ESP_LOGI("irrigation", "ğŸ’° Monthly water budget set to %.0f L", x);
  
  # Zone Daily Runtime Limit
  - platform: template
    id: zone_runtime_limit_input
    name: "$dev1_what Zone Runtime Limit"
    min_value: 30
    max_value: 240
    step: 5
    icon: "mdi:timer-sand"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(max_zone_runtime_daily);"
    set_action:
      - lambda: |-
          id(max_zone_runtime_daily) = x;
          ESP_LOGI("irrigation", "â±ï¸ Zone daily runtime limit set to %.0f minutes", x);
  
  # Watering Window 1 - Start Hour (12-hour format)
  - platform: template
    id: window1_start_input
    name: "$dev1_what Window 1 Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: |-
      // Convert stored 24-hour to 12-hour for display
      int hour_24 = id(window1_start_hour);
      if (hour_24 == 0) return 12;  // Midnight = 12 AM
      if (hour_24 <= 12) return hour_24;
      return hour_24 - 12;  // PM hours
    set_action:
      - lambda: |-
          // Convert 12-hour + AM/PM to 24-hour for storage
          int hour_12 = (int)x;
          int hour_24;
          
          if (id(window1_start_am_pm) == 0) {  // AM
            hour_24 = (hour_12 == 12) ? 0 : hour_12;  // 12 AM = 0, others stay same
          } else {  // PM
            hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;  // 12 PM = 12, others +12
          }
          
          id(window1_start_hour) = hour_24;
          
          const char* am_pm = id(window1_start_am_pm) == 0 ? "AM" : "PM";
          ESP_LOGI("irrigation", "ğŸ• Window 1 start set to %d:%02d %s (%d:%02d 24h)", 
                   hour_12, id(window1_start_minute), am_pm, hour_24, id(window1_start_minute));
  
  # Watering Window 1 - Start Minute
  - platform: template
    id: window1_start_minute_input
    name: "$dev1_what Window 1 Start Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(window1_start_minute);"
    set_action:
      - lambda: |-
          id(window1_start_minute) = (int)x;
          ESP_LOGI("irrigation", "ğŸ• Window 1 start minute set to :%02d", (int)x);
  
  # Watering Window 1 - End Hour (12-hour format)
  - platform: template
    id: window1_end_input
    name: "$dev1_what Window 1 End Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: |-
      // Convert stored 24-hour to 12-hour for display
      int hour_24 = id(window1_end_hour);
      if (hour_24 == 0) return 12;  // Midnight = 12 AM
      if (hour_24 <= 12) return hour_24;
      return hour_24 - 12;  // PM hours
    set_action:
      - lambda: |-
          // Convert 12-hour + AM/PM to 24-hour for storage
          int hour_12 = (int)x;
          int hour_24;
          
          if (id(window1_end_am_pm) == 0) {  // AM
            hour_24 = (hour_12 == 12) ? 0 : hour_12;  // 12 AM = 0, others stay same
          } else {  // PM
            hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;  // 12 PM = 12, others +12
          }
          
          id(window1_end_hour) = hour_24;
          
          const char* am_pm = id(window1_end_am_pm) == 0 ? "AM" : "PM";
          ESP_LOGI("irrigation", "ğŸ• Window 1 end set to %d:%02d %s (%d:%02d 24h)", 
                   hour_12, id(window1_end_minute), am_pm, hour_24, id(window1_end_minute));
  
  # Watering Window 1 - End Minute
  - platform: template
    id: window1_end_minute_input
    name: "$dev1_what Window 1 End Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(window1_end_minute);"
    set_action:
      - lambda: |-
          id(window1_end_minute) = (int)x;
          ESP_LOGI("irrigation", "ğŸ• Window 1 end minute set to :%02d", (int)x);
  
  # Watering Window 2 - Start Hour (12-hour format)
  - platform: template
    id: window2_start_input
    name: "$dev1_what Window 2 Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: |-
      // Convert stored 24-hour to 12-hour for display
      int hour_24 = id(window2_start_hour);
      if (hour_24 == 0) return 12;  // Midnight = 12 AM
      if (hour_24 <= 12) return hour_24;
      return hour_24 - 12;  // PM hours
    set_action:
      - lambda: |-
          // Convert 12-hour + AM/PM to 24-hour for storage
          int hour_12 = (int)x;
          int hour_24;
          
          if (id(window2_start_am_pm) == 0) {  // AM
            hour_24 = (hour_12 == 12) ? 0 : hour_12;  // 12 AM = 0, others stay same
          } else {  // PM
            hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;  // 12 PM = 12, others +12
          }
          
          id(window2_start_hour) = hour_24;
          
          const char* am_pm = id(window2_start_am_pm) == 0 ? "AM" : "PM";
          ESP_LOGI("irrigation", "ğŸ• Window 2 start set to %d:%02d %s (%d:%02d 24h)", 
                   hour_12, id(window2_start_minute), am_pm, hour_24, id(window2_start_minute));
  
  # Watering Window 2 - Start Minute
  - platform: template
    id: window2_start_minute_input
    name: "$dev1_what Window 2 Start Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(window2_start_minute);"
    set_action:
      - lambda: |-
          id(window2_start_minute) = (int)x;
          ESP_LOGI("irrigation", "ğŸ• Window 2 start minute set to :%02d", (int)x);
  
  # Watering Window 2 - End Hour (12-hour format)
  - platform: template
    id: window2_end_input
    name: "$dev1_what Window 2 End Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: |-
      // Convert stored 24-hour to 12-hour for display
      int hour_24 = id(window2_end_hour);
      if (hour_24 == 0) return 12;  // Midnight = 12 AM
      if (hour_24 <= 12) return hour_24;
      return hour_24 - 12;  // PM hours
    set_action:
      - lambda: |-
          // Convert 12-hour + AM/PM to 24-hour for storage
          int hour_12 = (int)x;
          int hour_24;
          
          if (id(window2_end_am_pm) == 0) {  // AM
            hour_24 = (hour_12 == 12) ? 0 : hour_12;  // 12 AM = 0, others stay same
          } else {  // PM
            hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;  // 12 PM = 12, others +12
          }
          
          id(window2_end_hour) = hour_24;
          
          const char* am_pm = id(window2_end_am_pm) == 0 ? "AM" : "PM";
          ESP_LOGI("irrigation", "ğŸ• Window 2 end set to %d:%02d %s (%d:%02d 24h)", 
                   hour_12, id(window2_end_minute), am_pm, hour_24, id(window2_end_minute));
  
  # Watering Window 2 - End Minute
  - platform: template
    id: window2_end_minute_input
    name: "$dev1_what Window 2 End Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(window2_end_minute);"
    set_action:
      - lambda: |-
          id(window2_end_minute) = (int)x;
          ESP_LOGI("irrigation", "ğŸ• Window 2 end minute set to :%02d", (int)x);
  
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATERING WINDOW 3 (Optional - for additional ET runs)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Watering Window 3 - Start Hour (12-hour format)
  - platform: template
    id: window3_start_input
    name: "$dev1_what Window 3 Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: |-
      // Convert stored 24-hour to 12-hour for display
      int hour_24 = id(window3_start_hour);
      if (hour_24 == 0) return 12;  // Midnight = 12 AM
      if (hour_24 <= 12) return hour_24;
      return hour_24 - 12;  // PM hours
    set_action:
      - lambda: |-
          // Convert 12-hour + AM/PM to 24-hour for storage
          int hour_12 = (int)x;
          int hour_24;
          
          if (id(window3_start_am_pm) == 0) {  // AM
            hour_24 = (hour_12 == 12) ? 0 : hour_12;  // 12 AM = 0, others stay same
          } else {  // PM
            hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;  // 12 PM = 12, others +12
          }
          
          id(window3_start_hour) = hour_24;
          
          const char* am_pm = id(window3_start_am_pm) == 0 ? "AM" : "PM";
          ESP_LOGI("irrigation", "ğŸ• Window 3 start set to %d:%02d %s (%d:%02d 24h)", 
                   hour_12, id(window3_start_minute), am_pm, hour_24, id(window3_start_minute));
  
  # Watering Window 3 - Start Minute
  - platform: template
    id: window3_start_minute_input
    name: "$dev1_what Window 3 Start Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(window3_start_minute);"
    set_action:
      - lambda: |-
          id(window3_start_minute) = (int)x;
          ESP_LOGI("irrigation", "ğŸ• Window 3 start minute set to :%02d", (int)x);
  
  # Watering Window 3 - End Hour (12-hour format)
  - platform: template
    id: window3_end_input
    name: "$dev1_what Window 3 End Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: |-
      // Convert stored 24-hour to 12-hour for display
      int hour_24 = id(window3_end_hour);
      if (hour_24 == 0) return 12;  // Midnight = 12 AM
      if (hour_24 <= 12) return hour_24;
      return hour_24 - 12;  // PM hours
    set_action:
      - lambda: |-
          // Convert 12-hour + AM/PM to 24-hour for storage
          int hour_12 = (int)x;
          int hour_24;
          
          if (id(window3_end_am_pm) == 0) {  // AM
            hour_24 = (hour_12 == 12) ? 0 : hour_12;  // 12 AM = 0, others stay same
          } else {  // PM
            hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;  // 12 PM = 12, others +12
          }
          
          id(window3_end_hour) = hour_24;
          
          const char* am_pm = id(window3_end_am_pm) == 0 ? "AM" : "PM";
          ESP_LOGI("irrigation", "ğŸ• Window 3 end set to %d:%02d %s (%d:%02d 24h)", 
                   hour_12, id(window3_end_minute), am_pm, hour_24, id(window3_end_minute));
  
  # Watering Window 3 - End Minute
  - platform: template
    id: window3_end_minute_input
    name: "$dev1_what Window 3 End Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(window3_end_minute);"
    set_action:
      - lambda: |-
          id(window3_end_minute) = (int)x;
          ESP_LOGI("irrigation", "ğŸ• Window 3 end minute set to :%02d", (int)x);

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ADVANCED FORECAST SYSTEM THRESHOLDS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Forecast Skip Threshold (ET and watering decisions)
  - platform: template
    name: "$dev1_what Forecast Skip Threshold"
    icon: "mdi:water-alert"
    min_value: 1.0
    max_value: 10.0
    step: 0.5
    unit_of_measurement: "mm"
    mode: box
    lambda: "return id(forecast_rain_threshold_significant);"
    set_action:
      - lambda: |-
          id(forecast_rain_threshold_significant) = x;
          ESP_LOGI("forecast", "");
          ESP_LOGI("forecast", "ğŸŒ§ï¸ Forecast skip threshold set to %.1fmm", x);
          ESP_LOGI("forecast", "   Smart ET will skip watering if %.1fmm+ forecast in 1h", x);
          ESP_LOGI("forecast", "");
  
  # Forecast Auto-Delay Threshold (automatic rain delay)
  - platform: template
    name: "$dev1_what Forecast Auto-Delay Threshold"
    icon: "mdi:water-off"
    min_value: 5.0
    max_value: 20.0
    step: 1.0
    unit_of_measurement: "mm"
    mode: box
    lambda: "return id(forecast_rain_threshold_high);"
    set_action:
      - lambda: |-
          id(forecast_rain_threshold_high) = x;
          ESP_LOGI("forecast", "");
          ESP_LOGI("forecast", "ğŸŒ§ï¸ Auto rain delay threshold set to %.1fmm", x);
          ESP_LOGI("forecast", "   System will auto-set rain delay if %.1fmm+ forecast in 1h", x);
          ESP_LOGI("forecast", "");

script:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ADVANCED FORECAST SYSTEM
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - id: check_forecast_rain_delay
    mode: single
    then:
      - lambda: |-
          if (!id(forecast_enabled)) {
            ESP_LOGD("forecast", "Forecast system disabled");
            return;
          }
          
          // GUARD: Don't run without valid time â€” timestamps would be epoch 0
          // Cache .now() result here; reuse timestamp below instead of calling .now() again (P5 fix)
          auto _fc_time = id(homeassistant_time).now();
          if (!_fc_time.is_valid()) {
            ESP_LOGW("forecast", "âš ï¸ Time not synced - skipping forecast rain delay check");
            return;
          }
          
          ESP_LOGI("forecast", "");
          ESP_LOGI("forecast", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("forecast", "ğŸŒ§ï¸ SMART FORECAST RAIN DELAY CHECK");
          ESP_LOGI("forecast", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          // Get dual forecast data
          float forecast_1h = id(rain_forecast_1h).state;
          float forecast_0d = id(rain_probability).state;
          float threshold_high = id(forecast_rain_threshold_high);
          
          if (isnan(forecast_1h) || forecast_1h < 0) {
            forecast_1h = 0.0;
          }
          if (isnan(forecast_0d) || forecast_0d < 0) {
            forecast_0d = 0.0;
          }
          
          ESP_LOGI("forecast", "ğŸ“Š Dual Forecast:");
          ESP_LOGI("forecast", "   1h (imminent): %.1fmm", forecast_1h);
          ESP_LOGI("forecast", "   0d (today): %.1fmm", forecast_0d);
          ESP_LOGI("forecast", "ğŸ¯ Auto-delay threshold: %.1fmm", threshold_high);
          
          // Update detection flag - either imminent or significant daily

          // forecast_rain_detected = display/HA indicator (rain is coming)
          // Thresholds tuned separately from auto-delay to give earlier warning
          if (forecast_1h >= ${rain_detect_threshold_1h_mm}f || forecast_0d >= ${rain_detect_threshold_day_mm}f) {
            id(forecast_rain_detected) = true;
          } else {
            id(forecast_rain_detected) = false;
          }
          
          // Smart rain delay logic: Consider BOTH forecasts
          bool should_delay = false;
          int delay_days = 1;
          char delay_reason[128];  // Stack buffer - no heap allocation!
          delay_reason[0] = '\0';  // Initialize empty
          
          // PRIORITY 1: Heavy rain imminent (1h)
          if (forecast_1h >= threshold_high) {
            should_delay = true;
            delay_days = (forecast_1h > 15.0) ? 2 : 1;
            snprintf(delay_reason, sizeof(delay_reason),
                    "Heavy rain imminent (%dmm/1h)", (int)forecast_1h);
          }
          // PRIORITY 2: Very heavy rain expected today (0d)
          else if (forecast_0d >= (threshold_high * 1.5)) {
            should_delay = true;
            delay_days = (forecast_0d > 20.0) ? 2 : 1;
            snprintf(delay_reason, sizeof(delay_reason),
                    "Very heavy rain today (%dmm)", (int)forecast_0d);
          }
          // PRIORITY 3: Combined moderate amounts
          else if ((forecast_1h + forecast_0d) >= (threshold_high * 1.2)) {
            should_delay = true;
            delay_days = 1;
            snprintf(delay_reason, sizeof(delay_reason),
                    "Combined forecast high (%dmm/1h + %dmm/day)",
                    (int)forecast_1h, (int)forecast_0d);
          }
          
          if (should_delay) {
            ESP_LOGW("forecast", "âš ï¸ HIGH RAIN FORECAST DETECTED!");
            ESP_LOGW("forecast", "   Reason: %s", delay_reason);
            ESP_LOGW("forecast", "   Setting %d-day rain delay automatically", delay_days);
            
            // Only set rain delay if manual override is OFF
            if (!id(manual_rain_delay_override)) {
              id(rain_delay_days) = delay_days;
              int64_t now_ts = _fc_time.timestamp;  // Reuse cached time (P5 fix)
              id(rain_delay_end_time) = now_ts + (delay_days * ${seconds_per_day});
              
              ESP_LOGI("forecast", "âœ… Auto Rain Delay SET: %d days", delay_days);
              ESP_LOGI("forecast", "   %s", delay_reason);
              {
                char _a[100]; snprintf(_a, sizeof(_a), "ğŸŒ§ï¸ AUTO RAIN DELAY: %d days â€” %s", delay_days, delay_reason);
                id(irrigation_latest_alert) = _a;
                id(irrigation_alert_sensor).publish_state(_a);
              }
            } else {
              ESP_LOGI("forecast", "â„¹ï¸ Rain delay override is ON - not setting auto delay");
            }
          } else {
            ESP_LOGI("forecast", "âœ… No significant rain forecast");
            ESP_LOGI("forecast", "   Imminent: %.1fmm, Today: %.1fmm", forecast_1h, forecast_0d);
            
            // SMART CLEARING: Clear rain delay if conditions have improved
            int64_t now_ts = _fc_time.timestamp;  // Reuse cached time (P5 fix)
            if (id(rain_delay_end_time) > now_ts) {
              // There's an active rain delay - check if we should clear it
              // Thresholds configured in substitutions at top of file
              bool minimal_rain = (forecast_1h < ${rain_clear_threshold_1h_mm} && 
                                  forecast_0d < ${rain_clear_threshold_day_mm});
              
              if (minimal_rain && !id(manual_rain_delay_override)) {
                float days_remaining = (id(rain_delay_end_time) - now_ts) / (float)${seconds_per_day};
                ESP_LOGW("forecast", "ğŸŒ¤ï¸ WEATHER IMPROVED - Clearing auto rain delay");
                ESP_LOGW("forecast", "   Previous delay: %.1f days remaining", days_remaining);
                
                id(rain_delay_end_time) = 0;
                id(rain_delay_days) = 0;
                id(rain_delay_days_input).publish_state(0);
                
                ESP_LOGI("forecast", "âœ… Rain delay CLEARED - watering can resume");
              } else if (id(manual_rain_delay_override)) {
                ESP_LOGI("forecast", "â„¹ï¸ Rain delay active but manual override ON - keeping delay");
              } else {
                ESP_LOGI("forecast", "â„¹ï¸ Rain delay active but still some rain forecast - keeping delay");
                ESP_LOGI("forecast", "   Will auto-clear when forecast drops below ${rain_clear_threshold_1h_mm}mm/1h AND ${rain_clear_threshold_day_mm}mm/day");
              }
            } else {
              ESP_LOGI("forecast", "   Watering can proceed normally");
            }
          }
          
          ESP_LOGI("forecast", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("forecast", "");

  # ============================================================
  # PREDICTIVE WATERINGâ„¢ SCRIPT
  # ============================================================
  - id: calculate_predictive_watering
    mode: single
    then:
      - lambda: |-
          if (!id(predictive_watering_enabled)) {
            ESP_LOGI("irrigation", "ğŸ’§ Predictive Wateringâ„¢ is DISABLED - skipping calculation");
            return;
          }
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ’§ PREDICTIVE WATERINGâ„¢ - Daily Calculation");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          // Get current weather data
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          float rain_mm = id(rain_probability).state;  // Sensor reports mm precipitation (not probability %)
          
          // Validate data
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "âš ï¸ Temperature unavailable, using 20Â°C");
            temp = 20.0;
          }
          if (isnan(humidity)) {
            ESP_LOGW("irrigation", "âš ï¸ Humidity unavailable, using 50%%");
            humidity = 50.0;
          }
          if (isnan(wind)) {
            ESP_LOGW("irrigation", "âš ï¸ Wind speed unavailable, using 10 km/h");
            wind = 10.0;
          }
          if (isnan(rain_mm) || rain_mm < 0) {
            ESP_LOGI("irrigation", "â„¹ï¸ Rain forecast not available - assuming 0mm (no rain forecast)");
            rain_mm = 0.0;
          }
          
          ESP_LOGI("irrigation", "ğŸ“Š Weather Conditions:");
          ESP_LOGI("irrigation", "   Temperature: %.1fÂ°C", temp);
          ESP_LOGI("irrigation", "   Humidity: %.0f%%", humidity);
          ESP_LOGI("irrigation", "   Wind Speed: %.1f km/h", wind);
          ESP_LOGI("irrigation", "   Rain Forecast: %.1f mm", rain_mm);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // TEMPERATURE FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float temp_factor = 1.0;
          if (temp < 10) {
            temp_factor = 0.3;  // Very cold - minimal watering
          } else if (temp < 15) {
            temp_factor = 0.5;  // Cool
          } else if (temp < 20) {
            temp_factor = 0.8;  // Mild
          } else if (temp < 25) {
            temp_factor = 1.0;  // Normal
          } else if (temp < 28) {
            temp_factor = 1.3;  // Warm
          } else if (temp < 32) {
            temp_factor = 1.6;  // Hot
          } else {
            temp_factor = 1.9;  // Very hot
          }
          id(pw_temperature_factor) = temp_factor;
          ESP_LOGI("irrigation", "ğŸŒ¡ï¸ Temperature Factor: %.2f", temp_factor);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // HUMIDITY FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float humidity_factor = 1.0;
          if (humidity < 30) {
            humidity_factor = 1.3;  // Very dry - more water needed
          } else if (humidity < 50) {
            humidity_factor = 1.15;  // Dry
          } else if (humidity < 70) {
            humidity_factor = 1.0;  // Normal
          } else if (humidity < 85) {
            humidity_factor = 0.85;  // Humid - less evaporation
          } else {
            humidity_factor = 0.7;  // Very humid
          }
          id(pw_humidity_factor) = humidity_factor;
          ESP_LOGI("irrigation", "ğŸ’¨ Humidity Factor: %.2f", humidity_factor);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // WIND FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float wind_factor = 1.0;
          if (wind < 10) {
            wind_factor = 1.0;  // Calm
          } else if (wind < 20) {
            wind_factor = 1.1;  // Light wind - slight increase in evaporation
          } else if (wind < 30) {
            wind_factor = 1.2;  // Moderate wind
          } else {
            wind_factor = 1.3;  // Strong wind - high evaporation
          }
          id(pw_wind_factor) = wind_factor;
          ESP_LOGI("irrigation", "ğŸŒ¬ï¸ Wind Factor: %.2f", wind_factor);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // RAIN FORECAST FACTOR - SMART DUAL FORECAST
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Combines 1h (imminent) + 0d (today) for smart grass health decisions
          
          float rain_1h = 0.0;
          float rain_0d = 0.0;
          
          if (id(forecast_enabled)) {
            // Get 1h forecast (imminent rain)
            float forecast_1h = id(rain_forecast_1h).state;
            if (!isnan(forecast_1h) && forecast_1h >= 0) {
              rain_1h = forecast_1h;
            }
            
            // Get 0d forecast (today's total)
            float forecast_0d = id(rain_probability).state;
            if (!isnan(forecast_0d) && forecast_0d >= 0) {
              rain_0d = forecast_0d;
            }
            
            ESP_LOGI("irrigation", "ğŸŒ§ï¸ Dual Forecast: 1h=%.1fmm (imminent), 0d=%.1fmm (today)", rain_1h, rain_0d);
            
            // Smart combined total: prioritize imminent rain, add portion of daily
            // If heavy rain in 1h, that's most important
            // But also account for rain throughout the day
            if (rain_1h >= 5.0) {
              // Heavy rain imminent - use mostly 1h forecast
              rain_mm = rain_1h + (rain_0d * 0.2);  // 1h + 20% of day
            } else if (rain_1h >= 2.0) {
              // Moderate imminent - balance both
              rain_mm = rain_1h + (rain_0d * 0.5);  // 1h + 50% of day
            } else {
              // Light/no imminent rain - use more of daily forecast
              rain_mm = rain_1h + (rain_0d * 0.8);  // 1h + 80% of day
            }
            
            ESP_LOGI("irrigation", "ğŸŒ§ï¸ Combined rain factor: %.1fmm (weighted)", rain_mm);
            
          } else {
            // Forecast system disabled, use basic 0d only
            rain_mm = id(rain_probability).state;
            if (isnan(rain_mm) || rain_mm < 0) rain_mm = 0.0;
            ESP_LOGI("irrigation", "ğŸŒ§ï¸ Using basic forecast: %.1fmm (forecast system disabled)", rain_mm);
          }
          
          // Calculate rain factor based on expected precipitation
          // 0mm = 1.0 (no rain, normal watering)
          // 0.1-0.5mm = 0.95 (trace/light drizzle expected)
          // 0.5-1mm = 0.85 (light rain expected)
          // 1-2mm = 0.7 (light-moderate rain)
          // 2-5mm = 0.5 (moderate rain)
          // 5-10mm = 0.3 (heavy rain)
          // >10mm = 0.2 (very heavy rain)
          
          float rain_factor = 1.0;
          if (rain_mm > 10.0) {
            rain_factor = 0.2;  // Very heavy rain forecast - minimal watering
          } else if (rain_mm > 5.0) {
            rain_factor = 0.3;  // Heavy rain forecast
          } else if (rain_mm > 2.0) {
            rain_factor = 0.5;  // Moderate rain forecast
          } else if (rain_mm > 1.0) {
            rain_factor = 0.7;  // Light-moderate rain
          } else if (rain_mm > 0.5) {
            rain_factor = 0.85;  // Light rain forecast
          } else if (rain_mm > 0.1) {
            rain_factor = 0.95;  // Trace amounts/drizzle
          } else {
            rain_factor = 1.0;  // No rain forecast
          }
          id(pw_rain_factor) = rain_factor;
          ESP_LOGI("irrigation", "ğŸŒ§ï¸ Rain Factor: %.2f (%.1fmm forecast)", rain_factor, rain_mm);

      # â”€â”€ YIELD POINT â”€â”€ delay: 0ms hands control back to ESPHome scheduler
      # httpd and API tasks run here before Part 2 continues
      - delay: 0ms
      - lambda: |-
          // Re-read factors from globals (local vars don't survive between lambda blocks)
          float temp_factor     = id(pw_temperature_factor);
          float humidity_factor = id(pw_humidity_factor);
          float wind_factor     = id(pw_wind_factor);
          float rain_factor     = id(pw_rain_factor);

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SEASONAL ADJUSTMENT FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          auto now = id(homeassistant_time).now();
          float seasonal_factor = 1.0;
          if (now.is_valid()) {
            int month = now.month;
            switch (month) {
              case 1:  seasonal_factor = id(seasonal_jan); break;
              case 2:  seasonal_factor = id(seasonal_feb); break;
              case 3:  seasonal_factor = id(seasonal_mar); break;
              case 4:  seasonal_factor = id(seasonal_apr); break;
              case 5:  seasonal_factor = id(seasonal_may); break;
              case 6:  seasonal_factor = id(seasonal_jun); break;
              case 7:  seasonal_factor = id(seasonal_jul); break;
              case 8:  seasonal_factor = id(seasonal_aug); break;
              case 9:  seasonal_factor = id(seasonal_sep); break;
              case 10: seasonal_factor = id(seasonal_oct); break;
              case 11: seasonal_factor = id(seasonal_nov); break;
              case 12: seasonal_factor = id(seasonal_dec); break;
            }
          }
          ESP_LOGI("irrigation", "ğŸ“… Seasonal Factor: %.2f (month %d)", seasonal_factor, now.month);
          id(pw_seasonal_factor) = seasonal_factor;
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SOIL TYPE ADJUSTMENT FACTOR
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float soil_factor = 1.0;
          const char* soil_name = "Unknown";
          if (id(soil_type) == 0) {
            soil_factor = 1.15;  // Sand: drains fast
            soil_name = "Sand";
          } else if (id(soil_type) == 1) {
            soil_factor = 1.0;   // Loam: balanced
            soil_name = "Loam";
          } else if (id(soil_type) == 2) {
            soil_factor = 0.85;  // Clay: holds moisture
            soil_name = "Clay";
          }
          ESP_LOGI("irrigation", "ğŸŒ± Soil Factor: %.2f (%s)", soil_factor, soil_name);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CALCULATE FINAL MULTIPLIER
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float combined_multiplier = temp_factor * humidity_factor * wind_factor * rain_factor * seasonal_factor * soil_factor;
          
          // Preserve uncapped value for logging â€” helps diagnose extreme sensor readings
          float uncapped_multiplier = combined_multiplier;
          
          // Apply reasonable limits (0.1 to 2.0)
          if (combined_multiplier < 0.1) {
            ESP_LOGW("irrigation", "âš ï¸ MULTIPLIER CAPPED: %.4f â†’ 0.10 (below minimum)", combined_multiplier);
            ESP_LOGW("irrigation", "   Extreme conditions detected - verify weather sensors");
            combined_multiplier = 0.1;
          }
          if (combined_multiplier > 2.0) {
            ESP_LOGW("irrigation", "âš ï¸ MULTIPLIER CAPPED: %.2f â†’ 2.00 (above maximum)", combined_multiplier);
            ESP_LOGW("irrigation", "   Very hot/dry conditions - safety limit applied");
            combined_multiplier = 2.0;
          }
          
          float old_multiplier = id(pw_current_multiplier);
          id(pw_current_multiplier) = combined_multiplier;
          id(pw_last_calculation_time) = id(homeassistant_time).now().timestamp;
          
          // Save as fallback for network offline mode
          id(fallback_multiplier) = combined_multiplier;
          
          // Log multiplier change if significant (>5% difference)
          if (fabs(old_multiplier - combined_multiplier) > 0.05) {
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ“Š MULTIPLIER CHANGED: %.2f â†’ %.2f (%.1f%% %s)", 
                     old_multiplier, combined_multiplier,
                     fabs(((combined_multiplier - old_multiplier) / old_multiplier) * 100.0),
                     (combined_multiplier > old_multiplier) ? "increase" : "decrease");
          }
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âœ… FINAL MULTIPLIER: %.2f%s", combined_multiplier,
                   (uncapped_multiplier != combined_multiplier) ? " (CAPPED)" : "");
          ESP_LOGI("irrigation", "   Weather: Temp:%.2f Hum:%.2f Wind:%.2f Rain:%.2f", 
                   temp_factor, humidity_factor, wind_factor, rain_factor);
          ESP_LOGI("irrigation", "   Season: %.2f | Soil: %.2f", seasonal_factor, soil_factor);
          if (uncapped_multiplier != combined_multiplier) {
            ESP_LOGI("irrigation", "   Uncapped: %.4f â†’ Capped: %.2f", uncapped_multiplier, combined_multiplier);
          }
          
          // Apply to sprinkler controller - honour vacation mode 50% reduction
          if (id(vacation_mode_active)) {
            id($devicename1).set_multiplier(combined_multiplier * 0.5f);
            id(normal_multiplier) = combined_multiplier;  // Keep saved value current
            ESP_LOGI("irrigation", "ğŸ’§ Vacation mode active â€” multiplier %.2fx Ã— 0.5 = %.2fx",
                     combined_multiplier, combined_multiplier * 0.5f);
          } else {
            id($devicename1).set_multiplier(combined_multiplier);
          }
          
          ESP_LOGI("irrigation", "ğŸ’§ Predictive Wateringâ„¢ multiplier applied to system");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  # ============================================================
  # RESTORE PREDICTIVE WATERING MULTIPLIER (after Smart ET)
  # ============================================================
  - id: restore_pw_multiplier
    mode: single
    then:
      - lambda: |-
          if (!id(smart_et_enabled)) {
            // Smart ET is off â€” nothing to restore (ET multiplier was never set)
            return;
          }
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”„ Restoring Predictive Watering multiplier...");
          
          // Reset ET multiplier
          id(et_duration_multiplier) = 1.0;
          
          // Restore Predictive Watering's weather-based multiplier
          // Honour vacation mode 50% reduction if active
          float pw_mult = id(pw_current_multiplier);
          float _restore_final = id(vacation_mode_active) ? pw_mult * 0.5f : pw_mult;
          id($devicename1).set_multiplier(_restore_final);
          
          ESP_LOGI("irrigation", "   âœ… Multiplier restored to %.2fx (Predictive Watering%s)",
                   _restore_final, id(vacation_mode_active) ? ", Ã—0.5 vacation" : "");
          ESP_LOGI("irrigation", "   â„¹ï¸ Smart ET watering complete");

  # ============================================================
  # SMART ET WATERING SCRIPT
  # ============================================================
  - id: calculate_smart_et
    mode: single
    then:
      - lambda: |-
          if (!id(smart_et_enabled)) {
            return;
          }
          
          // BUG #32 FIX: If a run is active, don't touch the multiplier.
          // set_multiplier() is called below based on the new ET calculation; changing
          // it mid-run corrupts the duration of zones not yet started.
          // Mark pending â€” the every-5-min check will fire it when the system is free.
          if (id(irrigation_busy)) {
            ESP_LOGI("irrigation", "ğŸŒ± Smart ET: System busy â€” deferring ET calculation until idle");
            id(et_pending_irrigation) = true;
            return;
          }
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸŒ± SMART ET WATERING - Daily Calculation");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          // Get weather data
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          
          // Validate
          if (isnan(temp)) temp = 20.0;
          if (isnan(humidity)) humidity = 50.0;
          if (isnan(wind)) wind = 10.0;
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CALCULATE REFERENCE ET (ET0) - Simplified Penman-Monteith
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // Temperature factor (base ET increases with temperature)
          float temp_et = 0.0;
          if (temp < 10) {
            temp_et = 1.0;
          } else if (temp < 15) {
            temp_et = 2.0;
          } else if (temp < 20) {
            temp_et = 3.5;
          } else if (temp < 25) {
            temp_et = 5.0;
          } else if (temp < 30) {
            temp_et = 6.5;
          } else {
            temp_et = 8.0;
          }
          
          // Humidity adjustment (dry air increases ET)
          float humidity_adj = 1.0;
          if (humidity < 30) {
            humidity_adj = 1.4;
          } else if (humidity < 50) {
            humidity_adj = 1.2;
          } else if (humidity < 70) {
            humidity_adj = 1.0;
          } else if (humidity < 85) {
            humidity_adj = 0.8;
          } else {
            humidity_adj = 0.6;
          }
          
          // Wind adjustment (wind increases ET)
          float wind_adj = 1.0;
          if (wind < 10) {
            wind_adj = 1.0;
          } else if (wind < 20) {
            wind_adj = 1.15;
          } else if (wind < 30) {
            wind_adj = 1.3;
          } else {
            wind_adj = 1.5;
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SOIL TYPE ADJUSTMENT
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float soil_adj = 1.0;
          if (id(soil_type) == 0) {
            soil_adj = 1.15;  // Sand: drains fast, needs more frequent watering
          } else if (id(soil_type) == 1) {
            soil_adj = 1.0;   // Loam: balanced
          } else if (id(soil_type) == 2) {
            soil_adj = 0.85;  // Clay: holds moisture longer
          }
          
          // Calculate daily ET in mm (with soil adjustment)
          float daily_et = temp_et * humidity_adj * wind_adj * soil_adj;
          id(et_daily_et) = daily_et;
          
          ESP_LOGI("irrigation", "ğŸ“Š ET Calculation:");
          ESP_LOGI("irrigation", "   Temperature ET: %.1f mm", temp_et);
          ESP_LOGI("irrigation", "   Humidity Adj: %.2fx", humidity_adj);
          ESP_LOGI("irrigation", "   Wind Adj: %.2fx", wind_adj);
          ESP_LOGI("irrigation", "   Soil Adj: %.2fx (Sand=1.15, Loam=1.0, Clay=0.85)", soil_adj);
          ESP_LOGI("irrigation", "   Daily ET: %.1f mm/day", daily_et);
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CHECK FOR RAINFALL - SMART DUAL FORECAST
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float rainfall = 0.0;
          
          if (id(forecast_enabled)) {
            // Use dual forecast for smart rainfall calculation
            float rain_1h = id(rain_forecast_1h).state;
            float rain_0d = id(rain_probability).state;
            
            if (isnan(rain_1h) || rain_1h < 0) rain_1h = 0.0;
            if (isnan(rain_0d) || rain_0d < 0) rain_0d = 0.0;
            
            ESP_LOGI("irrigation", "ğŸŒ§ï¸ Dual Forecast Available:");
            ESP_LOGI("irrigation", "   1h forecast (imminent): %.1f mm", rain_1h);
            ESP_LOGI("irrigation", "   0d forecast (today total): %.1f mm", rain_0d);
            
            // For moisture balance, use today's total but adjust if heavy rain imminent
            if (rain_1h >= 5.0) {
              // Heavy rain imminent - it will happen, use 1h + some of 0d
              rainfall = rain_1h + (rain_0d * 0.3);
              ESP_LOGI("irrigation", "   Heavy rain imminent - using %.1f + 30%% of %.1f", rain_1h, rain_0d);
            } else if (rain_1h >= 2.0) {
              // Moderate imminent - balance both
              rainfall = rain_1h + (rain_0d * 0.5);
              ESP_LOGI("irrigation", "   Moderate rain imminent - using %.1f + 50%% of %.1f", rain_1h, rain_0d);
            } else if (rain_0d >= 2.0) {
              // Significant daily forecast but not imminent - use mostly daily
              rainfall = rain_1h + (rain_0d * 0.8);
              ESP_LOGI("irrigation", "   Rain forecast today - using %.1f + 80%% of %.1f", rain_1h, rain_0d);
            } else {
              // Light amounts - use direct sum
              rainfall = rain_1h + rain_0d;
              ESP_LOGI("irrigation", "   Light forecast - using direct sum");
            }
            
            ESP_LOGI("irrigation", "ğŸŒ§ï¸ Smart combined rainfall: %.1f mm", rainfall);
            
          } else {
            // Forecast disabled - try basic sensor
            float rain_forecast_mm = id(rain_probability).state;
            if (!isnan(rain_forecast_mm) && rain_forecast_mm >= 0) {
              rainfall = rain_forecast_mm;
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ Using basic forecast: %.1f mm", rainfall);
            } else {
              // FALLBACK: Estimate from weather condition
              std::string weather = id(weather_forecast_home).state;
              
              if (weather == "pouring") {
                rainfall = 15.0;  // Heavy rain: 15mm
              } else if (weather == "rainy") {
                rainfall = 8.0;   // Rain: 8mm
              } else if (weather == "snowy-rainy") {
                rainfall = 5.0;   // Light rain: 5mm
              }
              
              if (rainfall > 0) {
                ESP_LOGI("irrigation", "ğŸŒ§ï¸ Estimated from weather (%s): %.1f mm", weather.c_str(), rainfall);
              } else {
                ESP_LOGI("irrigation", "ğŸŒ§ï¸ No rainfall expected (weather: %s)", weather.c_str());
              }
            }
          }
          
          // Store rainfall to global so Part 2 lambda can read it after the yield
          id(et_rainfall_today) = rainfall;

      # â”€â”€ YIELD POINT â”€â”€ delay: 0ms hands control back to ESPHome scheduler
      # httpd and API tasks run here before Part 2 continues
      - delay: 0ms
      - lambda: |-
          // Re-read from globals (local vars don't survive between lambda blocks)
          float daily_et = id(et_daily_et);
          float rainfall = id(et_rainfall_today);

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // UPDATE SOIL MOISTURE DEFICIT
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          float old_deficit = id(et_soil_moisture_deficit);
          
          // Add ET (water lost)
          id(et_soil_moisture_deficit) += daily_et;
          
          // Subtract rainfall (water gained)
          id(et_soil_moisture_deficit) -= rainfall;
          
          // Don't let deficit go negative (soil can't be oversaturated for our purposes)
          if (id(et_soil_moisture_deficit) < 0) {
            id(et_soil_moisture_deficit) = 0;
          }
          
          float new_deficit = id(et_soil_moisture_deficit);
          
          ESP_LOGI("irrigation", "ğŸ’§ Moisture Balance:");
          ESP_LOGI("irrigation", "   Previous Deficit: %.1f mm", old_deficit);
          ESP_LOGI("irrigation", "   + ET Lost: %.1f mm", daily_et);
          ESP_LOGI("irrigation", "   - Rainfall: %.1f mm", rainfall);
          ESP_LOGI("irrigation", "   = New Deficit: %.1f mm", new_deficit);
          ESP_LOGI("irrigation", "   Threshold: %.1f mm", id(et_water_threshold));
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // CHECK IF IRRIGATION NEEDED
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          if (new_deficit >= id(et_water_threshold)) {
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸš¨ DEFICIT THRESHOLD REACHED!");
            ESP_LOGI("irrigation", "   Irrigation is NEEDED");
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SMART DUAL FORECAST CHECK BEFORE WATERING
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (id(forecast_enabled)) {
              float forecast_1h = id(rain_forecast_1h).state;
              float forecast_0d = id(rain_probability).state;
              float threshold_sig = id(forecast_rain_threshold_significant);
              
              if (isnan(forecast_1h) || forecast_1h < 0) {
                forecast_1h = 0.0;
              }
              if (isnan(forecast_0d) || forecast_0d < 0) {
                forecast_0d = 0.0;
              }
              
              ESP_LOGI("irrigation", "");
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ SMART FORECAST CHECK (ET)");
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "   1h forecast (imminent): %.1fmm", forecast_1h);
              ESP_LOGI("irrigation", "   0d forecast (today): %.1fmm", forecast_0d);
              ESP_LOGI("irrigation", "   Skip threshold: %.1fmm", threshold_sig);
              
              // URGENCY CHECK: Skip if significant rain imminent (1h)
              if (forecast_1h >= threshold_sig) {
                ESP_LOGW("irrigation", "ğŸŒ§ï¸ ET WATERING SKIPPED - IMMINENT RAIN");
                ESP_LOGW("irrigation", "   Reason: Heavy rain in next hour (%.1fmm)", forecast_1h);
                ESP_LOGW("irrigation", "   Rain will reduce soil moisture deficit");
                ESP_LOGW("irrigation", "   Will re-evaluate after rain passes");
                ESP_LOGI("irrigation", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGI("irrigation", "");
                id(et_pending_irrigation) = false;
                return;
              }
              
              // DAILY CHECK: Calculate combined expected rain
              // Prioritize imminent rain, but also account for rain throughout day
              float expected_rain;
              if (forecast_1h >= 2.0) {
                // Significant imminent rain - use mostly 1h
                expected_rain = forecast_1h + (forecast_0d * 0.3);
                ESP_LOGI("irrigation", "   Using mostly 1h forecast (%.1f + 30%% of 0d)", forecast_1h);
              } else {
                // Light/no imminent rain - use more of daily forecast
                expected_rain = forecast_1h + (forecast_0d * 0.7);
                ESP_LOGI("irrigation", "   Using combined forecast (%.1f + 70%% of 0d)", forecast_1h);
              }
              
              float effective_deficit = new_deficit - expected_rain;
              
              ESP_LOGI("irrigation", "ğŸ’§ EFFECTIVE DEFICIT:");
              ESP_LOGI("irrigation", "   Current deficit: %.1fmm", new_deficit);
              ESP_LOGI("irrigation", "   Expected rain (weighted): %.1fmm", expected_rain);
              ESP_LOGI("irrigation", "   Effective deficit: %.1fmm", effective_deficit);
              
              // If effective deficit is below threshold, skip watering
              if (effective_deficit < id(et_water_threshold)) {
                ESP_LOGW("irrigation", "â­ï¸ ET WATERING SKIPPED - RAIN COVERS DEFICIT");
                ESP_LOGW("irrigation", "   Reason: Expected rain will cover deficit");
                ESP_LOGW("irrigation", "   Effective deficit (%.1fmm) < threshold (%.1fmm)", 
                         effective_deficit, id(et_water_threshold));
                ESP_LOGI("irrigation", "   Today's forecast (%.1f) + Imminent (%.1f) = enough", forecast_0d, forecast_1h);
                ESP_LOGI("irrigation", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGI("irrigation", "");
                id(et_pending_irrigation) = false;
                return;
              }
              
              // Proceed with watering, but reduce amount for expected rain
              ESP_LOGI("irrigation", "âœ… Watering needed even with forecast");
              ESP_LOGI("irrigation", "   Effective deficit above threshold");
              ESP_LOGI("irrigation", "   Will water %.1fmm (reduced by expected %.1fmm)", effective_deficit, expected_rain);
              ESP_LOGI("irrigation", "ğŸŒ§ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              ESP_LOGI("irrigation", "");
              
              // Use effective deficit for duration calculation
              new_deficit = effective_deficit;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CALCULATE SMART ET DURATION MULTIPLIER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Adjust watering duration based on deficit severity
            float threshold = id(et_water_threshold);
            if (threshold <= 0.0f) threshold = 1.0f;  // Guard against divide-by-zero
            float deficit_ratio = new_deficit / threshold;
            
            // Duration multiplier scales with how far over threshold we are
            // At threshold (1.0x): multiply by 1.0
            // 20% over (1.2x): multiply by 1.2
            // 50% over (1.5x): multiply by 1.5
            // Cap at 2.0x for safety
            float et_multiplier = deficit_ratio;
            if (et_multiplier > ${max_et_multiplier}f) et_multiplier = ${max_et_multiplier}f;
            if (et_multiplier < ${min_et_multiplier}f) et_multiplier = ${min_et_multiplier}f;
            
            id(et_duration_multiplier) = et_multiplier;
            
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ’§ Smart ET Duration Adjustment:");
            ESP_LOGI("irrigation", "   Deficit: %.1f mm (%.0f%% over threshold)", new_deficit, (deficit_ratio - 1.0) * 100);
            ESP_LOGI("irrigation", "   ET Multiplier: %.2fx", et_multiplier);
            
            // Calculate combined multiplier with Predictive Watering
            // Use pw_current_multiplier (undiscounted) â€” NOT .multiplier() which may
            // already be 0.5x if vacation mode is active, causing double-discount.
            // Vacation mode is applied once below, after the ET combination.
            float pw_mult = id(pw_current_multiplier);
            float combined = pw_mult * et_multiplier;
            if (combined > ${max_et_multiplier}f) combined = ${max_et_multiplier}f;  // Safety cap
            float combined_vac = id(vacation_mode_active) ? combined * 0.5f : combined;
            
            ESP_LOGI("irrigation", "   Predictive Watering: %.2fx (base, before vacation)", pw_mult);
            ESP_LOGI("irrigation", "   Combined Multiplier: %.2fx%s", combined_vac,
                     id(vacation_mode_active) ? " (x0.5 vacation)" : "");
            ESP_LOGI("irrigation", "   (Example: 15min zone â†’ %.1f min)", 15.0 * combined);
            
            // Apply ET multiplier temporarily (vacation-adjusted)
            id($devicename1).set_multiplier(combined_vac);
            
            // Check if system is enabled and not in rain delay
            if (!id(irrigation_system_enable).state) {
              ESP_LOGW("irrigation", "   âŒ System is DISABLED - cannot water");
              id(et_duration_multiplier) = 1.0;
              // Restore PW multiplier immediately â€” sprinkler was already set to combined
              // et_duration_multiplier=1.0 prevents the 5-min restore loop from firing
              // Honour vacation mode 50% reduction during restore
              { float _r = id(pw_current_multiplier); id($devicename1).set_multiplier(id(vacation_mode_active) ? _r * 0.5f : _r); }
            } else if (id(homeassistant_time).now().is_valid() && id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
              ESP_LOGW("irrigation", "   âŒ Rain delay is ACTIVE - cannot water");
              id(et_duration_multiplier) = 1.0;
              { float _r = id(pw_current_multiplier); id($devicename1).set_multiplier(id(vacation_mode_active) ? _r * 0.5f : _r); }  // Restore immediately
            } else if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "   â° Time restricted - will water when allowed");
              id(et_pending_irrigation) = true;
            } else {
              // Check if current time matches Smart ET schedule
              auto now = id(homeassistant_time).now();
              int current_hour = now.hour;
              int current_minute = now.minute;
              int day_of_week = now.day_of_week;  // 1=Sunday, 2=Monday, etc.
              
              // CHECK ET SCHEDULE DAYS FIRST
              bool day_enabled = false;
              if ((day_of_week == 2 && id(et_schedule_monday).state) ||
                  (day_of_week == 3 && id(et_schedule_tuesday).state) ||
                  (day_of_week == 4 && id(et_schedule_wednesday).state) ||
                  (day_of_week == 5 && id(et_schedule_thursday).state) ||
                  (day_of_week == 6 && id(et_schedule_friday).state) ||
                  (day_of_week == 7 && id(et_schedule_saturday).state) ||
                  (day_of_week == 1 && id(et_schedule_sunday).state)) {
                day_enabled = true;
              }
              
              if (!day_enabled) {
                const char* days[] = {"", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
                ESP_LOGW("irrigation", "   ğŸ“… Today is %s - NOT an ET schedule day", days[day_of_week]);
                ESP_LOGW("irrigation", "   Watering will wait for next ET schedule day");
                id(et_pending_irrigation) = true;
                id(et_duration_multiplier) = 1.0;
                // Restore PW multiplier â€” sprinkler was already set to combined above
                // Honour vacation mode 50% reduction during restore
                { float _r = id(pw_current_multiplier); id($devicename1).set_multiplier(id(vacation_mode_active) ? _r * 0.5f : _r); }
                return;
              }
              
              ESP_LOGI("irrigation", "   ğŸ“… ET Schedule day check: PASS (today is enabled)");
              
              // Check if we're currently in ANY enabled watering window
              int current_time_minutes = (current_hour * 60) + current_minute;
              bool in_window = false;
              std::string active_window = "";
              
              // Check Window 1
              if (id(window1_enabled)) {
                int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
                int end_min = (id(window1_end_hour) * 60) + id(window1_end_minute);
                if (start_min <= current_time_minutes && current_time_minutes < end_min) {
                  in_window = true;
                  active_window = "Window 1";
                }
              }
              
              // Check Window 2
              if (!in_window && id(window2_enabled)) {
                int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
                int end_min = (id(window2_end_hour) * 60) + id(window2_end_minute);
                if (start_min <= current_time_minutes && current_time_minutes < end_min) {
                  in_window = true;
                  active_window = "Window 2";
                }
              }
              
              // Check Window 3
              if (!in_window && id(window3_enabled)) {
                int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
                int end_min = (id(window3_end_hour) * 60) + id(window3_end_minute);
                if (start_min <= current_time_minutes && current_time_minutes < end_min) {
                  in_window = true;
                  active_window = "Window 3";
                }
              }
              
              if (in_window) {
                // Set trigger source for tracking
                id(watering_trigger_source) = "Smart ET (" + active_window + ")";
                
                ESP_LOGI("irrigation", "");
                ESP_LOGI("irrigation", "   âœ… Starting irrigation cycle NOW (%s is open)", active_window.c_str());
                ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Smart ET via %s", active_window.c_str());
                id(et_pending_irrigation) = false;
                
                // Turn ON Cycle & Soak for Smart ET
                id(cycle_soak_switch).turn_on();
                ESP_LOGI("irrigation", "ğŸ”„ Cycle & Soak Mode: ON (Smart ET)");
                
                // Start all enabled zones (vacation-adjusted multiplier already applied)
                id(start_all_zones_cycle_soak).press();
                
                // BUG #33 FIX: Only clear deficit and record last_water_time when the
                // run actually started (system was idle). If the system is busy, the run
                // was just queued â€” clearing the deficit now would lose the data if the
                // queued run is later dropped (e.g. freeze kicks in before it executes).
                // irrigation_busy was set inside run_all_zones_cycle_soak_script which
                // was just execute()d; since it runs synchronously until its first yield
                // we check the script directly.
                if (!id(irrigation_busy)) {
                  // Was queued â€” preserve deficit data for when it eventually executes
                  ESP_LOGI("irrigation", "   â„¹ï¸ Smart ET: Run queued â€” deficit preserved (%.1fmm)", id(et_soil_moisture_deficit));
                } else {
                  id(et_soil_moisture_deficit) = 0;
                  { auto _t2b2 = id(homeassistant_time).now(); if (_t2b2.is_valid()) id(et_last_water_time) = _t2b2.timestamp; }
                }
              } else {
                ESP_LOGI("irrigation", "");
                ESP_LOGI("irrigation", "   â° Watering PENDING - waiting for next window to open");
                
                // Find next window that will open
                int next_window_min = 2400; // Sentinel (max valid = 1439 = 23:59, so 2400 is safely impossible)
                std::string next_window_name = "Unknown";
                
                // Check Window 1
                if (id(window1_enabled)) {
                  int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
                  if (start_min > current_time_minutes && start_min < next_window_min) {
                    next_window_min = start_min;
                    next_window_name = "ET Watering Window 1";
                  }
                }
                
                // Check Window 2
                if (id(window2_enabled)) {
                  int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
                  if (start_min > current_time_minutes && start_min < next_window_min) {
                    next_window_min = start_min;
                    next_window_name = "ET Watering Window 2";
                  }
                }
                
                // Check Window 3
                if (id(window3_enabled)) {
                  int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
                  if (start_min > current_time_minutes && start_min < next_window_min) {
                    next_window_min = start_min;
                    next_window_name = "ET Watering Window 3";
                  }
                }
                
                // If no window found today, check tomorrow's first window
                if (next_window_min == 2400) {
                  // Find earliest window for tomorrow
                  int earliest_min = 2400;
                  if (id(window1_enabled)) {
                    int start_min = (id(window1_start_hour) * 60) + id(window1_start_minute);
                    if (start_min < earliest_min) {
                      earliest_min = start_min;
                      next_window_name = "ET Watering Window 1 (tomorrow)";
                    }
                  }
                  if (id(window2_enabled)) {
                    int start_min = (id(window2_start_hour) * 60) + id(window2_start_minute);
                    if (start_min < earliest_min) {
                      earliest_min = start_min;
                      next_window_name = "ET Watering Window 2 (tomorrow)";
                    }
                  }
                  if (id(window3_enabled)) {
                    int start_min = (id(window3_start_hour) * 60) + id(window3_start_minute);
                    if (start_min < earliest_min) {
                      earliest_min = start_min;
                      next_window_name = "ET Watering Window 3 (tomorrow)";
                    }
                  }
                  next_window_min = earliest_min;
                }
                
                // Convert next window time to 12-hour format
                int next_hour_24 = next_window_min / 60;
                int next_min = next_window_min % 60;
                int next_hour_12 = (next_hour_24 == 0 || next_hour_24 == 12) ? 12 : next_hour_24 % 12;
                const char* next_ampm = (next_hour_24 < 12) ? "AM" : "PM";
                
                ESP_LOGI("irrigation", "   Next window: %s at %d:%02d %s", 
                         next_window_name.c_str(), next_hour_12, next_min, next_ampm);
                ESP_LOGI("irrigation", "   Current time: %d:%02d %s", 
                         current_hour > 12 ? current_hour - 12 : (current_hour == 0 ? 12 : current_hour),
                         current_minute,
                         current_hour >= 12 ? "PM" : "AM");
                id(et_pending_irrigation) = true;
              }
              
              // Note: Multiplier will be restored after watering completes
            }
          } else {
            ESP_LOGI("irrigation", "   âœ… Deficit below threshold - no watering needed");
            id(et_pending_irrigation) = false;
            id(et_duration_multiplier) = 1.0;  // Reset when not watering
          }
          
          { auto _t2c = id(homeassistant_time).now(); if (_t2c.is_valid()) id(et_last_calculation_time) = _t2c.timestamp; }
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

  # Request NORMAL mode start: start now if idle, otherwise queue it (queued_type = 3)
  - id: request_normal_start
    mode: restart
    then:
      - lambda: |-
          bool valve_active = id($devicename1).active_valve().has_value();
          bool script_running =
              id(run_zone_with_cycles).is_running() ||
              id(run_program).is_running() ||
              id(run_all_zones_cycle_soak_script).is_running();
          bool soaking = id(cycle_soak_is_soaking);

          if (id(irrigation_busy) || valve_active || script_running || soaking) {
            // one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
            id(queued_type) = 3;  // queue/overwrite a pending normal run
            ESP_LOGI("irrigation", "Queued NORMAL start (will run when system is idle)");
            return;
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // SAFETY CHECKS â€” ALL must pass before relay fires
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          auto _rn_time = id(homeassistant_time).now();
          
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« request_normal_start BLOCKED â€” system disabled");
            return;
          }
          if (id(freeze_protection_active)) {
            ESP_LOGW("irrigation", "â„ï¸ request_normal_start BLOCKED â€” freeze protection active (%.1fÂ°C)", id(outside_temperature).state);
            return;
          }
          if (id(budget_exceeded) && !id(budget_override_active)) {
            ESP_LOGW("irrigation", "ğŸš« request_normal_start BLOCKED â€” monthly budget exceeded (%.0fL / %.0fL)", id(current_month_usage), id(monthly_water_budget));
            return;
          }
          if (_rn_time.is_valid() && id(rain_delay_end_time) > _rn_time.timestamp) {
            int64_t _rd = (id(rain_delay_end_time) - _rn_time.timestamp) / ${seconds_per_day};
            ESP_LOGW("irrigation", "ğŸŒ§ï¸ request_normal_start BLOCKED â€” rain delay active (%lld day(s) remaining)", _rd);
            return;
          }
          if (id(is_blackout_date).state) {
            ESP_LOGW("irrigation", "ğŸš« request_normal_start BLOCKED â€” blackout date active");
            return;
          }
          if (id(is_time_restricted)) {
            ESP_LOGW("irrigation", "â° request_normal_start BLOCKED â€” outside allowed watering window");
            return;
          }
          if (!id(manual_weather_override)) {
            std::string _w = id(weather_forecast_home).state;
            if (!_w.empty() && _w != "unknown" && _w != "unavailable") {
              if (_w == "rainy" || _w == "pouring" || _w == "snowy" || _w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ request_normal_start BLOCKED â€” bad weather: %s", _w.c_str());
                return;
              }
            }
          }

          ESP_LOGI("irrigation", "âœ… All safety checks passed â€” Starting NORMAL immediately");
          id(irrigation_busy) = true;
      - sprinkler.start_full_cycle: $devicename1

  # Wait until system is truly idle, then drain queue
  - id: wait_until_idle_then_drain
    mode: restart
    then:
      - while:
          condition:
            lambda: |-
              bool valve_active = id($devicename1).active_valve().has_value();
              bool script_running =
                  id(run_zone_with_cycles).is_running() ||
                  id(run_program).is_running() ||
                  id(run_all_zones_cycle_soak_script).is_running() ||
                  id(run_all_zones_normal_script).is_running() ||
                  id(continue_cycle_soak_after_resume).is_running();
              bool soaking = id(cycle_soak_is_soaking);

              // Keep waiting while anything is still active or stopping
              return valve_active || script_running || soaking || id(irrigation_busy);
          then:
            - delay: 250ms
      - script.execute: drain_queue

  # Drain queued items from 3-item queue (Hunter Pro-C style)
  - id: drain_queue
    mode: restart
    then:
      - lambda: |-
          // === 3-ITEM QUEUE DRAINING SYSTEM ===
          
          // Check if queue is empty
          if (id(queue_count) == 0) {
            ESP_LOGD("irrigation", "âœ… Queue empty (0/3 items)");
            return;
          }

          // Hold queue if system is paused
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ PAUSED - Holding queue (%d/%d items waiting)",
                     id(queue_count), 3);
            return;
          }

          // Check if system is truly idle
          const bool valve_active = id($devicename1).active_valve().has_value();
          const bool scripts_running =
              id(run_zone_with_cycles).is_running() ||
              id(run_program).is_running() ||
              id(run_all_zones_cycle_soak_script).is_running() ||
              id(run_all_zones_normal_script).is_running() ||
              id(continue_cycle_soak_after_resume).is_running();
          const bool soaking = id(cycle_soak_is_soaking);

          if (valve_active || scripts_running || soaking || id(irrigation_busy)) {
            ESP_LOGI("irrigation", "â³ NOT IDLE - Queue waiting (%d/%d) | valve=%d script=%d soak=%d busy=%d",
                     id(queue_count), 3, valve_active, scripts_running, soaking, id(irrigation_busy));
            id(wait_until_idle_then_drain).execute();
            return;
          }

          // === DRAIN FIRST ITEM FROM QUEUE ===
          int type = id(queue_types)[0];
          int program = id(queue_programs)[0];
          int zone = id(queue_zones)[0];
          int duration = id(queue_durations)[0];
          bool add_delay = id(queue_add_delays)[0];
          std::string trigger_source = id(queue_trigger_sources)[0];
          
          // Build queue contents for logging
          std::string queue_contents = "";
          for (int i = 0; i < id(queue_count) && i < 3; i++) {
            if (i > 0) queue_contents += ", ";
            if (id(queue_types)[i] == 1) {
              queue_contents += "Prg";
              queue_contents += (char)('A' + id(queue_programs)[i] - 1);
            } else if (id(queue_types)[i] == 2) {
              queue_contents += "Z";
              queue_contents += std::to_string(id(queue_zones)[i] + 1);
            } else if (id(queue_types)[i] == 3) {
              queue_contents += "Normal";
            } else if (id(queue_types)[i] == 4) {
              queue_contents += "C&S";
            }
          }
          
          ESP_LOGI("irrigation", "ğŸ“¤ DRAINING queue [%s] â†’ Starting item 1/%d",
                   queue_contents.c_str(), id(queue_count));
          
          // Shift queue forward (remove first item)
          for (int i = 0; i < 2; i++) {
            id(queue_types)[i] = id(queue_types)[i + 1];
            id(queue_programs)[i] = id(queue_programs)[i + 1];
            id(queue_zones)[i] = id(queue_zones)[i + 1];
            id(queue_durations)[i] = id(queue_durations)[i + 1];
            id(queue_add_delays)[i] = id(queue_add_delays)[i + 1];
            id(queue_trigger_sources)[i] = id(queue_trigger_sources)[i + 1];
          }
          
          // Clear last slot
          id(queue_types)[2] = 0;
          id(queue_programs)[2] = 0;
          id(queue_zones)[2] = 0;
          id(queue_durations)[2] = 0;
          id(queue_add_delays)[2] = false;
          id(queue_trigger_sources)[2] = "";
          
          id(queue_count)--;
          
          // â”€â”€ SAFETY RE-CHECK before executing dequeued item â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // All conditions are re-evaluated â€” conditions may have changed while queued.
          // Blocked items are dropped (not re-queued); remaining queue drains next.
          {
            auto _dq_time = id(homeassistant_time).now();
            const char* _dq_reason = nullptr;
            
            if (!id(irrigation_system_enable).state) {
              _dq_reason = "system disabled";
            } else if (id(freeze_protection_active)) {
              _dq_reason = "freeze protection active";
            } else if (id(budget_exceeded) && !id(budget_override_active)) {
              _dq_reason = "monthly budget exceeded";
            } else if (_dq_time.is_valid() && id(rain_delay_end_time) > _dq_time.timestamp) {
              _dq_reason = "rain delay active";
            } else if (id(is_time_restricted)) {
              _dq_reason = "outside watering window";
            } else if (!id(manual_weather_override)) {
              std::string _dqw = id(weather_forecast_home).state;
              if (!_dqw.empty() && _dqw != "unknown" && _dqw != "unavailable") {
                if (_dqw == "rainy" || _dqw == "pouring" || _dqw == "snowy" || _dqw == "snowy-rainy") {
                  _dq_reason = "bad weather";
                }
              }
            }
            // Blackout check is independent of weather override â€” uses is_blackout_date sensor
            // which covers both manual slots AND NZ public holidays.
            if (_dq_reason == nullptr && id(is_blackout_date).state) {
              _dq_reason = "blackout date active";
            }
            
            if (_dq_reason != nullptr) {
              ESP_LOGW("irrigation", "ğŸš« QUEUE: Dropping dequeued item â€” %s", _dq_reason);
              // Item already removed from queue; try remaining items
              if (id(queue_count) > 0) id(drain_queue).execute();
              return;
            }
          }
          
          // Start the appropriate item type
          if (type == 1) {
            // PROGRAM
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Program %d | Queue now: %d/3 items",
                     program, id(queue_count));
            // Set trigger source from queue
            id(watering_trigger_source) = trigger_source;
            ESP_LOGI("irrigation", "ğŸ“ TRIGGER: %s", trigger_source.c_str());
            id(irrigation_busy) = true;
            id(in_program_run) = true;
            id(run_program).execute(program);
            
          } else if (type == 2) {
            // ZONE
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Zone %d (%ds) | Queue now: %d/3 items",
                     zone + 1, duration, id(queue_count));
            // Set trigger source from queue
            id(watering_trigger_source) = trigger_source;
            ESP_LOGI("irrigation", "ğŸ“ TRIGGER: %s", trigger_source.c_str());
            id(irrigation_busy) = true;
            id(in_program_run) = false;
            id(run_zone_with_cycles).execute(zone, duration, add_delay, false);
            
          } else if (type == 3) {
            // FULL CYCLE (Weekly Schedule / Normal Mode)
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Normal Mode | Queue now: %d/3 items",
                     id(queue_count));
            // Set trigger source from queue
            id(watering_trigger_source) = trigger_source;
            ESP_LOGI("irrigation", "ğŸ“ TRIGGER: %s", trigger_source.c_str());
            // BUG #26 FIX: Set irrigation_busy=true BEFORE pending_normal_start so that
            // request_zone_start and request_program_start see the system as busy during
            // the ~500ms window between here and the 500ms interval firing start_full_cycle.
            // Without this, a concurrent button press sees busy=false and starts a
            // second run that conflicts with the pending normal mode start.
            id(irrigation_busy) = true;
            id(pending_normal_start) = true;
            id(normal_start_attempts) = 0;
            id(normal_last_attempt_ms) = 0;
            
          } else if (type == 4) {
            // CYCLE & SOAK MODE
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Cycle & Soak | Queue now: %d/3 items",
                     id(queue_count));
            // Set trigger source from queue
            id(watering_trigger_source) = trigger_source;
            ESP_LOGI("irrigation", "ğŸ“ TRIGGER: %s", trigger_source.c_str());
            // Turn ON cycle and soak mode
            id(cycle_soak_switch).turn_on();
            ESP_LOGI("irrigation", "ğŸ”„ Cycle & Soak Mode: ON");
            // Start the script
            id(run_all_zones_cycle_soak_script).execute();
          }

  # Run all zones in normal mode â€“ production safe
  - id: run_all_zones_normal_script
    mode: single  # Prevent re-pressing button from restarting mid-run
    then:
      - if:
          condition:
            lambda: "return true;"
          then:
            - lambda: |-
                // Reset block flag at start of every run
                id(normal_script_blocked) = false;

                // PAUSE CHECK
                if (id(is_paused)) {
                  ESP_LOGW("irrigation", "â¸ Normal Mode BLOCKED - system is paused");
                  id(normal_script_blocked) = true; return;
                }
                // BLACKOUT DATES CHECK - Block Normal Mode (incl. NZ public holidays)
                if (id(is_blackout_date).state) {
                  ESP_LOGW("irrigation", "\U0001F6AB Blackout active");
                  id(normal_script_blocked) = true; return;
                }
                // SYSTEM ENABLE CHECK
                if (!id(irrigation_system_enable).state) {
                  ESP_LOGW("irrigation", "ğŸš« Normal Mode BLOCKED - irrigation system disabled");
                  id(normal_script_blocked) = true; return;
                }
                // RAIN DELAY CHECK
                auto now = id(homeassistant_time).now();
                if (now.is_valid() && id(rain_delay_end_time) > now.timestamp) {
                  int64_t days = (id(rain_delay_end_time) - now.timestamp) / ${seconds_per_day};
                  ESP_LOGW("irrigation", "ğŸŒ§ï¸ Normal Mode BLOCKED - rain delay active (%lld day(s) remaining)", days);
                  id(normal_script_blocked) = true; return;
                }
                // FREEZE PROTECTION CHECK
                if (id(freeze_protection_active)) {
                  ESP_LOGW("irrigation", "â„ï¸ Normal Mode BLOCKED - freeze protection active (%.1fÂ°C)",
                           id(outside_temperature).state);
                  id(normal_script_blocked) = true; return;
                }
                // WATER BUDGET CHECK
                if (id(budget_exceeded) && !id(budget_override_active)) {
                  ESP_LOGW("irrigation", "ğŸš« Normal Mode BLOCKED - monthly water budget exceeded (%.1fL / %.1fL)",
                           id(current_month_usage), id(monthly_water_budget));
                  id(normal_script_blocked) = true; return;
                }
                // TIME RESTRICTION CHECK
                if (id(is_time_restricted)) {
                  ESP_LOGW("irrigation", "â° Normal Mode BLOCKED - time restriction active (outside allowed window)");
                  id(normal_script_blocked) = true; return;
                }
                // WEATHER CHECK
                if (!id(manual_weather_override)) {
                  std::string _nw = id(weather_forecast_home).state;
                  if (!_nw.empty() && _nw != "unknown" && _nw != "unavailable") {
                    if (_nw == "rainy" || _nw == "pouring" || _nw == "snowy" || _nw == "snowy-rainy") {
                      ESP_LOGW("irrigation", "â›ˆï¸ Normal Mode BLOCKED - bad weather: %s", _nw.c_str());
                      id(normal_script_blocked) = true; return;
                    }
                  }
                }

            - if:
                condition:
                  lambda: 'return !id(normal_script_blocked);'
                then:
                  - logger.log: "â•â•â• STARTING NORMAL MODE â•â•â•"

                  - lambda: |-
                      id(irrigation_busy) = true;
                      id(in_program_run) = false;

                  - sprinkler.start_full_cycle: $devicename1

                  - logger.log: "âœ“ Normal mode started - sprinkler managing sequence"

# Request to start a program: manual blocked while busy; scheduled can queue.
  - id: request_program_start
    mode: queued
    parameters:
      program: int
      allow_queue: bool
      trigger_source: std::string  # e.g. "Scheduled: Program A" or "Manual: Program A"
    then:
      - lambda: |-
          // Check if paused
          auto now = id(homeassistant_time).now();
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ Program %d BLOCKED - system paused", program);
            return;
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // BLACKOUT DATES CHECK - Block ALL irrigation types
          // Blackout check (incl. NZ public holidays via is_blackout_date sensor)
          if (id(is_blackout_date).state) {
            ESP_LOGW("irrigation", "\U0001F6AB Blackout active - blocked");
            return;
          }

          // â”€â”€ SAFETY CHECKS â€” all must pass before queuing or starting â”€â”€â”€â”€â”€â”€â”€â”€â”€
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« request_program_start: Program %d BLOCKED â€” system disabled", program);
            return;
          }
          if (id(freeze_protection_active)) {
            ESP_LOGW("irrigation", "â„ï¸ request_program_start: Program %d BLOCKED â€” freeze protection (%.1fÂ°C)", program, id(outside_temperature).state);
            return;
          }
          if (id(budget_exceeded) && !id(budget_override_active)) {
            ESP_LOGW("irrigation", "ğŸš« request_program_start: Program %d BLOCKED â€” budget exceeded (%.0fL/%.0fL)", program, id(current_month_usage), id(monthly_water_budget));
            return;
          }
          if (now.is_valid() && id(rain_delay_end_time) > now.timestamp) {
            int64_t _rd = (id(rain_delay_end_time) - now.timestamp) / ${seconds_per_day};
            ESP_LOGW("irrigation", "ğŸŒ§ï¸ request_program_start: Program %d BLOCKED â€” rain delay (%lld day(s))", program, _rd);
            return;
          }
          if (id(is_time_restricted)) {
            ESP_LOGW("irrigation", "â° request_program_start: Program %d BLOCKED â€” outside watering window", program);
            return;
          }
          if (!id(manual_weather_override)) {
            std::string _pw = id(weather_forecast_home).state;
            if (!_pw.empty() && _pw != "unknown" && _pw != "unavailable") {
              if (_pw == "rainy" || _pw == "pouring" || _pw == "snowy" || _pw == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ request_program_start: Program %d BLOCKED â€” bad weather: %s", program, _pw.c_str());
                return;
              }
            }
          }
          
          bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
          
          if (busy) {
            if (allow_queue) {
              // === 3-ITEM QUEUE SYSTEM ===
              if (id(queue_count) < 3) {
                int pos = id(queue_count);
                id(queue_types)[pos] = 1;  // 1 = Program
                id(queue_programs)[pos] = program;
                id(queue_zones)[pos] = 0;
                id(queue_durations)[pos] = 0;
                id(queue_add_delays)[pos] = false;
                // Store trigger source from parameter
                id(queue_trigger_sources)[pos] = trigger_source;
                id(queue_count)++;
                
                // Build queue status for logging
                std::string q_status = "";
                for (int i = 0; i < id(queue_count); i++) {
                  if (i > 0) q_status += ", ";
                  if (id(queue_types)[i] == 1) q_status += "Prg" + std::string(1, 'A' + id(queue_programs)[i] - 1);
                  else if (id(queue_types)[i] == 2) q_status += "Z" + std::to_string(id(queue_zones)[i] + 1);
                  else if (id(queue_types)[i] == 3) q_status += "Normal";
                  else if (id(queue_types)[i] == 4) q_status += "C&S";
                }
                
                ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Program %d â†’ Slot %d/3 | Queue: [%s]",
                         program, pos + 1, q_status.c_str());
              } else {
                ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Program %d will NOT run!", program);
              }
            } else {
              ESP_LOGW("irrigation", "ğŸš« BUSY - Manual Program %d blocked", program);
            }
            return;
          }
          
          // System is idle - start immediately
          id(watering_trigger_source) = trigger_source;
          
          ESP_LOGI("irrigation", "â–¶ï¸ STARTING %s immediately (system idle)", trigger_source.c_str());
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: %s", trigger_source.c_str());
          id(irrigation_busy) = true;
          id(in_program_run) = true;
          id(run_program).execute(program);

  # Request to start a zone: manual blocked while busy; scheduled can queue.
  - id: request_zone_start
    mode: queued
    parameters:
      zone: int
      duration: int
      add_delay: bool
      allow_queue: bool
      trigger_source: std::string  # e.g. "Scheduled: Zone 1", "Manual: Zone 1", etc.
    then:
      - lambda: |-
          auto now = id(homeassistant_time).now();
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // ğŸš« BLACKOUT CHECK - HIGHEST PRIORITY
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // Blackout check (incl. NZ public holidays via is_blackout_date sensor)
          if (id(is_blackout_date).state) {
            ESP_LOGW("irrigation", "\U0001F6AB Blackout active - blocked");
            return;
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // PRODUCTION FEATURE CHECKS
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // 1. RAIN DELAY CHECK
          if (now.is_valid() && id(rain_delay_end_time) > now.timestamp) {
            int64_t rd_days = (id(rain_delay_end_time) - now.timestamp) / ${seconds_per_day};
            ESP_LOGW("irrigation", "ğŸŒ§ï¸ Zone %d BLOCKED - Rain delay active (%lld day(s) remaining)", zone + 1, rd_days);
            return;
          }
          
          // 2. FREEZE PROTECTION CHECK
          if (id(freeze_protection_active)) {
            ESP_LOGW("irrigation", "â„ï¸ Zone %d BLOCKED - Freeze protection active (temp: %.1fÂ°C)", 
                     zone + 1, id(outside_temperature).state);
            return;
          }
          
          // 3. WATER BUDGET CHECK
          if (id(budget_exceeded) && !id(budget_override_active)) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d BLOCKED - Monthly water budget exceeded (%.1fL / %.1fL)",
                     zone + 1, id(current_month_usage), id(monthly_water_budget));
            ESP_LOGW("irrigation", "   Activate budget override to force watering");
            return;
          }
          
          // 4. ZONE DAILY RUNTIME LIMIT CHECK
          int zone_runtime = 0;
          switch(zone) {
            case 0: zone_runtime = id(zone1_runtime_today); break;
            case 1: zone_runtime = id(zone2_runtime_today); break;
            case 2: zone_runtime = id(zone3_runtime_today); break;
            case 3: zone_runtime = id(zone4_runtime_today); break;
            case 4: zone_runtime = id(zone5_runtime_today); break;
            case 5: zone_runtime = id(zone6_runtime_today); break;
            case 6: zone_runtime = id(zone7_runtime_today); break;
            case 7: zone_runtime = id(zone8_runtime_today); break;
          }
          
          int max_runtime_seconds = id(max_zone_runtime_daily) * 60;
          int proposed_runtime = duration;
          
          // Safety: treat 0 or negative limit as "no limit" to prevent accidental lockout
          if (max_runtime_seconds <= 0) {
            ESP_LOGD("irrigation", "Daily runtime limit disabled (max=0)");
          } else if ((zone_runtime + proposed_runtime) > max_runtime_seconds) {
            int remaining = max_runtime_seconds - zone_runtime;
            if (remaining <= 0) {
              // Daily limit fully consumed â€” block entirely
              ESP_LOGW("irrigation", "â±ï¸ Zone %d BLOCKED - Daily runtime limit fully consumed (%.1f/%.1f min)",
                       zone + 1, zone_runtime / 60.0, id(max_zone_runtime_daily));
              return;
            } else {
              // Trim duration to remaining budget instead of blocking entirely
              ESP_LOGW("irrigation", "â±ï¸ Zone %d TRIMMED - Daily limit: %.1f min used, %.1f remaining (requested %.1f min)",
                       zone + 1, zone_runtime / 60.0, remaining / 60.0, proposed_runtime / 60.0);
              duration = remaining;  // Run for remaining budget only
            }
          }  // end runtime limit check
          
          // 5. WATERING WINDOW ENFORCEMENT (ONLY for Smart ET)
          // Zone schedules, programs, and manual runs have their own times!
          if (trigger_source.find("Smart ET") != std::string::npos) {
            if (now.is_valid()) {
              int current_hour = now.hour;
              int current_minute = now.minute;
              int current_time_minutes = (current_hour * 60) + current_minute;  // Total minutes since midnight
              bool in_window = false;
              
              // Check window 1
              if (id(window1_enabled)) {
                int start_minutes = (id(window1_start_hour) * 60) + id(window1_start_minute);
                int end_minutes = (id(window1_end_hour) * 60) + id(window1_end_minute);
                if (start_minutes <= current_time_minutes && current_time_minutes < end_minutes) {
                  in_window = true;
                }
              }
              
              // Check window 2
              if (id(window2_enabled)) {
                int start_minutes = (id(window2_start_hour) * 60) + id(window2_start_minute);
                int end_minutes = (id(window2_end_hour) * 60) + id(window2_end_minute);
                if (start_minutes <= current_time_minutes && current_time_minutes < end_minutes) {
                  in_window = true;
                }
              }
              
              // Check window 3
              if (id(window3_enabled)) {
                int start_minutes = (id(window3_start_hour) * 60) + id(window3_start_minute);
                int end_minutes = (id(window3_end_hour) * 60) + id(window3_end_minute);
                if (start_minutes <= current_time_minutes && current_time_minutes < end_minutes) {
                  in_window = true;
                }
              }
              
              // If all windows disabled, allow anytime
              if (!id(window1_enabled) && !id(window2_enabled) && !id(window3_enabled)) {
                in_window = true;
              }
              
              if (!in_window) {
                ESP_LOGW("irrigation", "ğŸ• Smart ET BLOCKED - Outside watering windows (current: %d:%02d)", 
                         current_hour, current_minute);
                ESP_LOGW("irrigation", "   Window 1: %s (%d:%02d-%d:%02d)", 
                         id(window1_enabled) ? "ENABLED" : "disabled",
                         id(window1_start_hour), id(window1_start_minute),
                         id(window1_end_hour), id(window1_end_minute));
                ESP_LOGW("irrigation", "   Window 2: %s (%d:%02d-%d:%02d)",
                         id(window2_enabled) ? "ENABLED" : "disabled", 
                         id(window2_start_hour), id(window2_start_minute),
                         id(window2_end_hour), id(window2_end_minute));
                ESP_LOGW("irrigation", "   Window 3: %s (%d:%02d-%d:%02d)",
                         id(window3_enabled) ? "ENABLED" : "disabled", 
                         id(window3_start_hour), id(window3_start_minute),
                         id(window3_end_hour), id(window3_end_minute));
                return;
              }
            }
          }
          
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // STANDARD CHECKS
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // CRITICAL: Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d BLOCKED - Irrigation system is DISABLED", zone + 1);
            return;
          }
          
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ Paused - cannot start Zone %d", zone + 1);
            return;
          }

          // CRITICAL: Check if zone is enabled
          bool zone_enabled = false;
          switch(zone) {
            case 0: zone_enabled = id(zone1_enable).state; break;
            case 1: zone_enabled = id(zone2_enable).state; break;
            case 2: zone_enabled = id(zone3_enable).state; break;
            case 3: zone_enabled = id(zone4_enable).state; break;
            case 4: zone_enabled = id(zone5_enable).state; break;
            case 5: zone_enabled = id(zone6_enable).state; break;
            case 6: zone_enabled = id(zone7_enable).state; break;
            case 7: zone_enabled = id(zone8_enable).state; break;
          }
          if (!zone_enabled) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d is DISABLED - will not run", zone + 1);
            return;
          }
          ESP_LOGI("irrigation", "âœ“ Zone %d is ENABLED - proceeding", zone + 1);

          // CRITICAL: Check weather for ALL zone requests (unless override active)
          if (!id(manual_weather_override)) {
            std::string weather = id(weather_forecast_home).state;
            if (!weather.empty() && weather != "unknown" && weather != "unavailable") {
              if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone %d BLOCKED - Bad weather: %s (Enable Weather Override to force)", 
                         zone + 1, weather.c_str());
                return;
              }
            }
            ESP_LOGI("irrigation", "â˜€ï¸ Weather check PASSED for Zone %d", zone + 1);
          } else {
            ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Skipping weather check for Zone %d", zone + 1);
          }

          // CRITICAL: Check time restriction (for manual runs only)
          if (!allow_queue) {
            if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "â° Zone %d blocked - time restriction active", zone + 1);
              return;
            }
            ESP_LOGI("irrigation", "âœ“ Time restriction check PASSED for Zone %d", zone + 1);
          }

          if (id(irrigation_busy) || id($devicename1).active_valve().has_value()) {
            if (allow_queue) {
              // 3-item queue
              if (id(queue_count) < 3) {
                int pos = id(queue_count);
                id(queue_types)[pos] = 2;  // 2 = Zone
                id(queue_programs)[pos] = 0;
                id(queue_zones)[pos] = zone;
                id(queue_durations)[pos] = duration;
                id(queue_add_delays)[pos] = add_delay;
                id(queue_trigger_sources)[pos] = trigger_source;
                id(queue_count)++;
                ESP_LOGI("irrigation", "ğŸ“‹ Queued Zone %d in slot %d/3 (%d items queued)",
                         zone + 1, pos + 1, id(queue_count));
              } else {
                // QUEUE OVERFLOW HANDLING (FIXED)
                ESP_LOGE("irrigation", "ğŸš« â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGE("irrigation", "ğŸš« QUEUE OVERFLOW - Zone %d DROPPED!", zone + 1);
                ESP_LOGE("irrigation", "ğŸš« â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGE("irrigation", "ğŸš« Queue is full (3/3 slots occupied)");
                ESP_LOGE("irrigation", "ğŸš« Current queue:");
                for (int i = 0; i < 3; i++) {
                  if (id(queue_types)[i] == 1) {
                    ESP_LOGE("irrigation", "ğŸš«   Slot %d: Program %d", i + 1, id(queue_programs)[i]);
                  } else if (id(queue_types)[i] == 2) {
                    ESP_LOGE("irrigation", "ğŸš«   Slot %d: Zone %d", i + 1, id(queue_zones)[i] + 1);
                  } else if (id(queue_types)[i] == 3) {
                    ESP_LOGE("irrigation", "ğŸš«   Slot %d: Normal Mode", i + 1);
                  } else if (id(queue_types)[i] == 4) {
                    ESP_LOGE("irrigation", "ğŸš«   Slot %d: Cycle & Soak", i + 1);
                  }
                }
                ESP_LOGE("irrigation", "ğŸš« â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
              }
            } else {
              ESP_LOGW("irrigation", "ğŸš« Busy - manual Zone %d start blocked", zone + 1);
            }
            return;
          }

          ESP_LOGI("irrigation", "â–¶ï¸ Starting Zone %d immediately (system idle)", zone + 1);
          ESP_LOGI("irrigation", "   âœ… All safety checks passed");
          
          // Set trigger source from parameter
          id(watering_trigger_source) = trigger_source;
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: %s", trigger_source.c_str());
          
          id(irrigation_busy) = true;
          id(in_program_run) = false;
          id(run_zone_with_cycles).execute(zone, duration, add_delay, false);

  # Handle cycle & soak for a zone with station delay
  - id: run_zone_with_cycles
    mode: single  # CRITICAL: Must be 'single' not 'restart' to prevent soak interruption
    parameters:
      zone: int
      duration: int
      add_delay: bool
      force_normal: bool
    then:
      - lambda: |-
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // PRE-FLIGHT: ALL SAFETY CHECKS BEFORE ANY RELAY FIRES
          // This is the single authoritative gate â€” if anything fails here,
          // the relay never activates. No click-then-off behaviour.
          // 
          // IMPORTANT: We do NOT call id(run_zone_with_cycles).stop() from
          // within this lambda. Calling stop() on the currently-executing
          // script's own coroutine from inside a lambda causes stack
          // corruption and ESP32 crashes. Instead we set zone_run_blocked=true
          // and all subsequent if-blocks check that flag before proceeding.
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // Reset the block flag at the start of every run
          id(zone_run_blocked) = false;
          
          bool _in_prog = id(in_program_run);
          auto _block = [&](const char* reason) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d BLOCKED (pre-relay) â€” %s", zone + 1, reason);
            if (!_in_prog) {
              id(irrigation_busy) = false;
              id(drain_queue).execute();
            }
            // Flag subsequent steps to skip â€” do NOT call .stop() here
            id(zone_run_blocked) = true;
          };
          
          // 1. SYSTEM ENABLE
          if (!id(irrigation_system_enable).state) {
            _block("irrigation system disabled");
            return;
          }
          
          // 2. FREEZE PROTECTION
          if (id(freeze_protection_active)) {
            char _fb[64]; snprintf(_fb, sizeof(_fb), "freeze protection active (%.1fÂ°C)", id(outside_temperature).state);
            _block(_fb); return;
          }
          
          // 3. WATER BUDGET
          if (id(budget_exceeded) && !id(budget_override_active)) {
            char _bb[80]; snprintf(_bb, sizeof(_bb), "monthly budget exceeded (%.0fL / %.0fL)", id(current_month_usage), id(monthly_water_budget));
            _block(_bb); return;
          }
          
          // 4. RAIN DELAY
          {
            auto _rt = id(homeassistant_time).now();
            if (_rt.is_valid() && id(rain_delay_end_time) > _rt.timestamp) {
              int64_t _rd = (id(rain_delay_end_time) - _rt.timestamp) / ${seconds_per_day};
              char _rb[64]; snprintf(_rb, sizeof(_rb), "rain delay active (%lld day(s) remaining)", _rd);
              _block(_rb); return;
            }
          }
          
          // 5. BLACKOUT DATES (incl. NZ public holidays via is_blackout_date sensor)
          if (id(is_blackout_date).state) { _block("blackout date active"); return; }
          
          // 6. TIME RESTRICTION
          if (id(is_time_restricted)) {
            _block("outside allowed watering window"); return;
          }
          
          // 7. WEATHER
          if (!id(manual_weather_override)) {
            std::string _w = id(weather_forecast_home).state;
            if (!_w.empty() && _w != "unknown" && _w != "unavailable") {
              if (_w == "rainy" || _w == "pouring" || _w == "snowy" || _w == "snowy-rainy") {
                char _wb[80]; snprintf(_wb, sizeof(_wb), "bad weather: %s (enable Weather Override to force)", _w.c_str());
                _block(_wb); return;
              }
            }
          }
          
          // 8. ZONE ENABLE
          bool _zone_enabled = false;
          switch(zone) {
            case 0: _zone_enabled = id(zone1_enable).state; break;
            case 1: _zone_enabled = id(zone2_enable).state; break;
            case 2: _zone_enabled = id(zone3_enable).state; break;
            case 3: _zone_enabled = id(zone4_enable).state; break;
            case 4: _zone_enabled = id(zone5_enable).state; break;
            case 5: _zone_enabled = id(zone6_enable).state; break;
            case 6: _zone_enabled = id(zone7_enable).state; break;
            case 7: _zone_enabled = id(zone8_enable).state; break;
          }
          if (!_zone_enabled) {
            _block("zone is disabled"); return;
          }
          
          // âœ… ALL CHECKS PASSED â€” safe to mark busy and activate relay
          id(irrigation_busy) = true;
          ESP_LOGI("irrigation", "ğŸš€ run_zone_with_cycles STARTED - mode should be SINGLE (not restart)");
          
          // Get custom zone name (from runtime text input)
          std::string zone_name = "${dev1_zone1}";  // Default fallback
          switch(zone) {
            case 0: zone_name = id(zone1_name).state; break;
            case 1: zone_name = id(zone2_name).state; break;
            case 2: zone_name = id(zone3_name).state; break;
            case 3: zone_name = id(zone4_name).state; break;
            case 4: zone_name = id(zone5_name).state; break;
            case 5: zone_name = id(zone6_name).state; break;
            case 6: zone_name = id(zone7_name).state; break;
            case 7: zone_name = id(zone8_name).state; break;
          }
          
          // Get multiplier first
          float multiplier = id($devicename1).multiplier();
          
          ESP_LOGI("irrigation", "ğŸŒŠ %s (Zone %d) START | Mode: %s | Duration: %ds | Multiplier: %.2f",
                   zone_name.c_str(), zone + 1,
                   (force_normal || !id(cycle_soak_switch).state) ? "NORMAL" : "CYCLE&SOAK",
                   duration, multiplier);
          
          if (force_normal || !id(cycle_soak_switch).state) {
            // NORMAL MODE
            int adjusted_duration = (int)(duration * multiplier);
            
            ESP_LOGI("irrigation", "==> NORMAL MODE - running %d seconds (base=%d, multiplier=%.2f)",
                     adjusted_duration, duration, multiplier);
            
            id(cycle_soak_total_duration) = 0;
            id(cycle_soak_elapsed_time) = 0;
            id(active_zone_number) = -1;
            id(total_cycles) = 0;
            id(current_cycle) = 0;
            
            // Start valve â€” relay fires here, all checks already passed above
            id($devicename1).start_single_valve(zone, adjusted_duration);
            
          } else {
            // CYCLE & SOAK MODE (no multiplier applied)
            int cycle_seconds = id(cycle_duration_minutes) * 60;
            int soak_seconds = id(soak_duration_minutes) * 60;
            int total_duration = duration;  // Use base duration without multiplier
            int cycles = (total_duration + cycle_seconds - 1) / cycle_seconds;
            int total_time = (cycles * cycle_seconds) + ((cycles - 1) * soak_seconds);
            
            ESP_LOGI("irrigation", "==> CYCLE & SOAK MODE - %d cycles of %d sec (NO multiplier) + %d sec soak",
                     cycles, cycle_seconds, soak_seconds);
            
            id(cycle_soak_total_duration) = total_time;
            id(cycle_soak_elapsed_time) = 0;
            id(active_zone_number) = zone;
            id(total_cycles) = cycles;
            id(current_cycle) = 1;
          }
      
      # NORMAL MODE EXECUTION â€” skipped if pre-flight blocked
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && (force_normal || !id(cycle_soak_switch).state);'
          then:
            - lambda: |-
                int wait_time = (int)(duration * id($devicename1).multiplier());
                ESP_LOGI("irrigation", "Waiting %d seconds for normal mode to complete...", wait_time);
            # +2s safety margin: allows valve to physically close before next zone opens.
            # Must be > valve_open_delay (${default_valve_open_delay_sec}s) to prevent overlap.
            - delay: !lambda 'return (int)(duration * id($devicename1).multiplier() + 2) * 1000;'
            - lambda: |-
                ESP_LOGI("irrigation", "Zone %d COMPLETE (normal mode)", zone);
                
                // â”€â”€ Water accounting handled by on_turn_off (no duplicate here) â”€â”€
                // on_turn_off is the single source for: water_used, zone_water_used,
                // total_water_litres, current_month_usage, runtime_today, last_watering_timestamp
                ESP_LOGI("irrigation", "Zone %d NORMAL MODE complete", zone + 1);
                
                if (!id(in_program_run)) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
      
      # CYCLE & SOAK MODE EXECUTION â€” skipped if pre-flight blocked
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && !force_normal && id(cycle_soak_switch).state;'
          then:
            # Run first cycle (no multiplier in soak mode)
            - sprinkler.start_single_valve:
                id: $devicename1
                valve_number: !lambda "return zone;"
                run_duration: !lambda "return id(cycle_duration_minutes) * 60;"
            - delay: !lambda "return (id(cycle_duration_minutes) * 60 + 2) * 1000;"
            
            # Repeat remaining cycles
            - repeat:
                count: !lambda "return id(total_cycles) - 1;"
                then:
                  # BUG #27 FIX: Check safety conditions before each soak/cycle iteration.
                  # If freeze or budget activates mid-run, stop immediately rather than
                  # completing remaining cycles. Script.stop from stop button also works
                  # (kills at next delay yield) but this provides proactive protection.
                  - if:
                      condition:
                        lambda: |-
                          if (!id(irrigation_busy)) return false;
                          if (!id(irrigation_system_enable).state) {
                            ESP_LOGW("irrigation", "ğŸš« CYCLE ABORT â€” system disabled mid-run");
                            id(zone_run_blocked) = true; return false;
                          }
                          if (id(freeze_protection_active)) {
                            ESP_LOGW("irrigation", "â„ï¸ CYCLE ABORT â€” freeze protection active mid-run");
                            id(zone_run_blocked) = true; return false;
                          }
                          if (id(budget_exceeded) && !id(budget_override_active)) {
                            ESP_LOGW("irrigation", "ğŸš« CYCLE ABORT â€” budget exceeded mid-run");
                            id(zone_run_blocked) = true; return false;
                          }
                          return true;
                      then:
                        # Soak period
                        - lambda: |-
                            id(cycle_soak_is_soaking) = true;
                            int soak_min = id(soak_duration_minutes);
                            int soak_sec = soak_min * 60;
                            int soak_ms = soak_sec * 1000;
                            id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_sec;
                            ESP_LOGI("irrigation", "ğŸŒ§ï¸ SOAK START: soak_duration_minutes=%d, seconds=%d, milliseconds=%d",
                                     soak_min, soak_sec, soak_ms);
                            // Update valve status so HA shows "Soaking" not "Idle" during soak period
                            id(dev1_valve_status).publish_state("Soaking");
                        - delay: !lambda "return id(soak_duration_minutes) * 60 * 1000;"
                        - lambda: |-
                            ESP_LOGI("irrigation", "âœ… SOAK COMPLETED!");
                            ESP_LOGI("irrigation", "   Soak duration: %d minutes", id(soak_duration_minutes));
                            id(cycle_soak_is_soaking) = false;
                            id(cycle_soak_soak_end_time) = 0;
                            id(current_cycle)++;
                            ESP_LOGI("irrigation", "ğŸ”„ CYCLE %d of %d COMPLETE - Starting next cycle",
                                     id(current_cycle) - 1, id(total_cycles));
                            ESP_LOGI("irrigation", "ğŸš€ CYCLE %d of %d STARTING NOW",
                                     id(current_cycle), id(total_cycles));
                        
                        # Next cycle (no multiplier in soak mode)
                        - sprinkler.start_single_valve:
                            id: $devicename1
                            valve_number: !lambda "return zone;"
                            run_duration: !lambda "return id(cycle_duration_minutes) * 60;"
                        - delay: !lambda "return (id(cycle_duration_minutes) * 60 + 2) * 1000;"
            
            # Cleanup
            - lambda: |-
                // â”€â”€ Water accounting handled by on_turn_off per-cycle (no duplicate here) â”€â”€
                // For cycle & soak: each cycle's on_turn_off counted water individually.
                // Total across all cycles is already accumulated in zone_water_used etc.
                ESP_LOGI("irrigation", "Zone %d CYCLE & SOAK complete (%d cycles)", zone + 1, id(total_cycles));
                
                // BUG #25 FIX: Do NOT clear irrigation_busy or call drain_queue if we are
                // running inside run_all_zones_cycle_soak_script. That script manages busy
                // and drains the queue itself after all zones complete.
                bool _from_all_zones = id(run_all_zones_cycle_soak_script).is_running();
                if (!id(in_program_run) && !_from_all_zones) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
                id(active_zone_number) = -1;
                id(current_cycle) = 0;
                id(total_cycles) = 0;
                id(cycle_soak_total_duration) = 0;
                id(cycle_soak_elapsed_time) = 0;
      
      # Station delay â€” skipped if pre-flight blocked
      - if:
          condition:
            lambda: "return !id(zone_run_blocked) && add_delay;"
          then:
            - lambda: |-
                ESP_LOGI("irrigation", "Station delay: %d seconds", id(station_delay_seconds));
            - delay: !lambda "return id(station_delay_seconds) * 1000;"
            
            # Reset after all cycles
            - lambda: |-
                // Get custom zone name (from runtime text input)
                std::string zone_name = "${dev1_zone1}";  // Default fallback
                switch(zone) {
                  case 0: zone_name = id(zone1_name).state; break;
                  case 1: zone_name = id(zone2_name).state; break;
                  case 2: zone_name = id(zone3_name).state; break;
                  case 3: zone_name = id(zone4_name).state; break;
                  case 4: zone_name = id(zone5_name).state; break;
                  case 5: zone_name = id(zone6_name).state; break;
                  case 6: zone_name = id(zone7_name).state; break;
                  case 7: zone_name = id(zone8_name).state; break;
                }
                ESP_LOGI("irrigation", "%s complete (cycle & soak + station delay)", zone_name.c_str());
                // BUG #25 FIX: Same guard as C&S cleanup above â€” don't clear busy
                // or drain queue if we're inside run_all_zones_cycle_soak_script.
                bool _from_all_zones_sd = id(run_all_zones_cycle_soak_script).is_running();
                if (!id(in_program_run) && !_from_all_zones_sd) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
                id(active_zone_number) = -1;
                id(current_cycle) = 0;
                id(total_cycles) = 0;
                id(cycle_soak_total_duration) = 0;
                id(cycle_soak_elapsed_time) = 0;
      
  # Continue cycle & soak after a Pause/Resume
  - id: continue_cycle_soak_after_resume
    mode: restart
    parameters:
      zone: int
      start_cycle: int
      total: int
      was_soaking: bool
      soak_remaining: int
      water_remaining: int
    then:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # PRE-FLIGHT SAFETY CHECKS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # IMPORTANT: Do NOT call .stop() from inside this lambda â€” calling
      # id(continue_cycle_soak_after_resume).stop() from within its own
      # running coroutine corrupts the stack and causes a WDT reset.
      # Instead: set resume_csa_blocked=true and return; every subsequent
      # action block checks the flag before executing, so the script ends
      # cleanly without touching the coroutine's own stack frame.
      - lambda: |-
          // Reset block flag at start of every execution
          id(resume_csa_blocked) = false;

          auto _csa_block = [&](const char* reason) {
            ESP_LOGW("irrigation", "ğŸš« RESUME-CONTINUE BLOCKED â€” %s", reason);
            id(irrigation_busy) = false;
            id(in_program_run) = false;
            id(active_zone_number) = -1;
            id(current_cycle) = 0;
            id(total_cycles) = 0;
            id(cycle_soak_is_soaking) = false;
            id(cycle_soak_soak_end_time) = 0;
            id(watering_trigger_source) = "Idle";
            id(dev1_valve_status).publish_state("Idle");
            id(drain_queue).execute();
            id(resume_csa_blocked) = true;  // Signal all subsequent blocks to skip
          };

          if (!id(irrigation_system_enable).state) {
            _csa_block("system disabled"); return;
          }
          if (id(freeze_protection_active)) {
            char _fb[64]; snprintf(_fb, sizeof(_fb), "freeze protection (%.1fÂ°C)", id(outside_temperature).state);
            _csa_block(_fb); return;
          }
          if (id(budget_exceeded) && !id(budget_override_active)) {
            char _bb[80]; snprintf(_bb, sizeof(_bb), "budget exceeded (%.0fL/%.0fL)", id(current_month_usage), id(monthly_water_budget));
            _csa_block(_bb); return;
          }
          {
            auto _cc_time = id(homeassistant_time).now();
            if (_cc_time.is_valid() && id(rain_delay_end_time) > _cc_time.timestamp) {
              int64_t _rd = (id(rain_delay_end_time) - _cc_time.timestamp) / ${seconds_per_day};
              char _rb[64]; snprintf(_rb, sizeof(_rb), "rain delay active (%lld day(s) remaining)", _rd);
              _csa_block(_rb); return;
            }
          }
          // All checks passed
          ESP_LOGI("irrigation", "âœ… RESUME-CONTINUE pre-flight passed (zone=%d, cycle=%d/%d, was_soaking=%d)",
                   zone, start_cycle, total, (int)was_soaking);

      # If we paused while watering, restart the valve for the remaining time
      # and wait for it to complete before starting the next soak/cycle.
      # IMPORTANT: The valve is fired HERE, not in the resume button.
      # The resume button calls script.execute with no preceding delay, so
      # is_running()=true before any watchdog tick. Firing the valve from
      # the resume button instead creates a gap between the valve call and
      # is_running()=true â€” the watchdog fires in that gap, sees busy+idle,
      # clears irrigation_busy, and the zombie-run lockup repeats.
      - if:
          condition:
            lambda: 'return !id(resume_csa_blocked) && !was_soaking && water_remaining > 0;'
          then:
            - lambda: |-
                ESP_LOGI("irrigation", "â–¶ Resuming mid-cycle: zone=%d, %d sec remaining", zone, water_remaining);
                id(irrigation_busy) = true;
            - sprinkler.start_single_valve:
                id: $devicename1
                valve_number: !lambda 'return zone;'
                run_duration: !lambda 'return water_remaining;'
            - delay: !lambda 'return (water_remaining + 2) * 1000;'

      # If we paused during a soak, resume the remaining soak time,
      # then water the cycle that follows it.
      - if:
          condition:
            lambda: 'return !id(resume_csa_blocked) && was_soaking && soak_remaining > 0;'
          then:
            - lambda: |-
                id(cycle_soak_is_soaking) = true;
                id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_remaining;
                ESP_LOGI("irrigation", "Resuming soak for %d seconds", soak_remaining);
                id(dev1_valve_status).publish_state("Soaking");
            - delay: !lambda 'return soak_remaining * 1000;'
            - lambda: |-
                if (id(resume_csa_blocked)) return;  // Abort cleanly if blocked during delay
                id(cycle_soak_is_soaking) = false;
                id(cycle_soak_soak_end_time) = 0;
                ESP_LOGI("irrigation", "Soak complete - watering cycle %d of %d", id(current_cycle) + 1, total);
            # Water the cycle that follows the now-completed soak
            - if:
                condition:
                  lambda: 'return !id(resume_csa_blocked);'
                then:
                  - sprinkler.start_single_valve:
                      id: $devicename1
                      valve_number: !lambda 'return zone;'
                      run_duration: !lambda 'return id(cycle_duration_minutes) * 60;'
                  - delay: !lambda 'return (id(cycle_duration_minutes) * 60 + 2) * 1000;'
                  - lambda: |-
                      if (id(resume_csa_blocked)) return;
                      id(current_cycle)++;
                      ESP_LOGI("irrigation", "Cycle %d of %d complete (post-soak resume)", id(current_cycle), total);

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # REMAINING CYCLES LOOP
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # For mid-water resume: handles all cycles AFTER the current one.
      # For mid-soak resume:  current_cycle incremented above, loop picks up any further cycles.
      #
      # EXIT CONDITIONS (any of these causes loop to end):
      #   1. resume_csa_blocked=true  (pre-flight failed or stop/pause called)
      #   2. irrigation_busy=false    (stop button cleared it)
      #   3. total_cycles==0          (stop button cleared the global)
      #   4. current_cycle >= total   (all cycles complete â€” normal exit)
      #   5. Safety condition changed (freeze/budget/system)
      - while:
          condition:
            lambda: |-
              // Abort if blocked, stop was pressed, or safety conditions changed
              if (id(resume_csa_blocked)) return false;
              if (!id(irrigation_busy)) return false;
              if (id(total_cycles) == 0) return false;

              // Safety checks â€” clear state and exit if conditions changed mid-run
              if (!id(irrigation_system_enable).state || id(freeze_protection_active) ||
                  (id(budget_exceeded) && !id(budget_override_active))) {
                ESP_LOGW("irrigation", "ğŸš« RESUME LOOP ABORTED â€” safety condition changed");
                id(irrigation_busy) = false; id(in_program_run) = false;
                id(active_zone_number) = -1; id(current_cycle) = 0; id(total_cycles) = 0;
                id(cycle_soak_is_soaking) = false; id(cycle_soak_soak_end_time) = 0;
                id(watering_trigger_source) = "Idle";
                id(dev1_valve_status).publish_state("Idle");
                return false;
              }
              return id(current_cycle) < total;
          then:
            - lambda: |-
                // Soak between cycles
                id(cycle_soak_is_soaking) = true;
                int soak_s = id(soak_duration_minutes) * 60;
                id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_s;
                ESP_LOGI("irrigation", "Soaking for %d seconds (cycle %d/%d)", soak_s, id(current_cycle), total);
                id(dev1_valve_status).publish_state("Soaking");
            - delay: !lambda 'return id(soak_duration_minutes) * 60 * 1000;'
            - lambda: |-
                if (id(resume_csa_blocked) || !id(irrigation_busy)) return;
                id(cycle_soak_is_soaking) = false;
                id(cycle_soak_soak_end_time) = 0;
                id(current_cycle)++;
                ESP_LOGI("irrigation", "Soak complete â€” starting cycle %d of %d", id(current_cycle), total);
            - if:
                condition:
                  lambda: 'return !id(resume_csa_blocked) && id(irrigation_busy);'
                then:
                  - sprinkler.start_single_valve:
                      id: $devicename1
                      valve_number: !lambda 'return zone;'
                      run_duration: !lambda 'return id(cycle_duration_minutes) * 60;'
                  - delay: !lambda 'return (id(cycle_duration_minutes) * 60 + 2) * 1000;'

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # CLEANUP â€” only runs on natural completion (not if blocked/stopped)
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      - lambda: |-
          if (id(resume_csa_blocked)) return;  // Blocked run â€” state already cleared
          
          // Normal completion cleanup
          ESP_LOGI("irrigation", "âœ… RESUME-CONTINUE COMPLETE â€” all cycles done");
          id(active_zone_number) = -1;
          id(current_cycle) = 0;
          id(total_cycles) = 0;
          id(cycle_soak_total_duration) = 0;
          id(cycle_soak_elapsed_time) = 0;
          id(cycle_soak_is_soaking) = false;
          id(cycle_soak_soak_end_time) = 0;
          id(paused_zone) = -1;
          id(paused_cycle) = 0;
          id(time_remaining_when_paused) = 0;
          id(paused_was_soaking) = false;
          id(paused_soak_remaining_seconds) = 0;
          id(paused_total_cycles) = 0;
          id(paused_cycle_soak_total_duration) = 0;
          id(paused_cycle_soak_elapsed_time) = 0;
          if (!id(in_program_run)) {
            id(irrigation_busy) = false;
            id(drain_queue).execute();
          }
          // Restore Auto Advance
          id(dev1_auto_advance).turn_on();
          id(dev1_valve_status).publish_state("Idle");
          ESP_LOGI("irrigation", "Auto Advance restored â€” Cycle & Soak resume complete");

  # Run all zones in cycle & soak mode
  - id: run_all_zones_cycle_soak_script
    mode: single
    then:
      - lambda: |-
          // Reset block flag at start of every run
          id(cycle_soak_script_blocked) = false;
          auto now = id(homeassistant_time).now();
          // BLACKOUT DATES CHECK
          if (id(is_blackout_date).state) {
            ESP_LOGW("irrigation", "\U0001F6AB Blackout active");
            id(cycle_soak_script_blocked) = true; return;
          }
          // SYSTEM ENABLE CHECK
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Cycle & Soak BLOCKED - irrigation system disabled");
            id(cycle_soak_script_blocked) = true; return;
          }
          // RAIN DELAY CHECK
          if (now.is_valid() && id(rain_delay_end_time) > now.timestamp) {
            int64_t days = (id(rain_delay_end_time) - now.timestamp) / ${seconds_per_day};
            ESP_LOGW("irrigation", "ğŸŒ§ï¸ Cycle & Soak BLOCKED - rain delay active (%lld day(s) remaining)", days);
            id(cycle_soak_script_blocked) = true; return;
          }
          // FREEZE PROTECTION CHECK
          if (id(freeze_protection_active)) {
            ESP_LOGW("irrigation", "â„ï¸ Cycle & Soak BLOCKED - freeze protection active (%.1fÂ°C)",
                     id(outside_temperature).state);
            id(cycle_soak_script_blocked) = true; return;
          }
          // WATER BUDGET CHECK
          if (id(budget_exceeded) && !id(budget_override_active)) {
            ESP_LOGW("irrigation", "ğŸš« Cycle & Soak BLOCKED - monthly water budget exceeded (%.1fL / %.1fL)",
                     id(current_month_usage), id(monthly_water_budget));
            id(cycle_soak_script_blocked) = true; return;
          }
          // TIME RESTRICTION CHECK
          if (id(is_time_restricted)) {
            ESP_LOGW("irrigation", "â° Cycle & Soak BLOCKED - time restriction active (outside allowed window)");
            id(cycle_soak_script_blocked) = true; return;
          }
          // WEATHER CHECK
          if (!id(manual_weather_override)) {
            std::string _csw = id(weather_forecast_home).state;
            if (!_csw.empty() && _csw != "unknown" && _csw != "unavailable") {
              if (_csw == "rainy" || _csw == "pouring" || _csw == "snowy" || _csw == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Cycle & Soak BLOCKED - bad weather: %s", _csw.c_str());
                id(cycle_soak_script_blocked) = true; return;
              }
            }
          }
          
          // â”€â”€ ALL CHECKS PASSED â”€â”€
          // (If any check above blocked, it set cycle_soak_script_blocked=true and returned.
          //  The cleanup below runs only on natural completion or after successful start.)

      # BUG #29 FIX: If pre-flight blocked, clear irrigation_busy and drain queue.
      # Callers (button handlers and drain_queue) set irrigation_busy=true BEFORE calling
      # this script. Without this guard, a blocked pre-flight silently leaves the system
      # locked (irrigation_busy=true forever, every subsequent press queues or is blocked).
      - if:
          condition:
            lambda: 'return id(cycle_soak_script_blocked);'
          then:
            - lambda: |-
                ESP_LOGW("irrigation", "ğŸš« Cycle & Soak pre-flight BLOCKED â€” clearing busy and draining queue");
                id(irrigation_busy) = false;
                id(in_program_run) = false;
                id(watering_trigger_source) = "Idle";
                id(dev1_valve_status).publish_state("Idle");
                id(drain_queue).execute();

      # All remaining steps guarded by !cycle_soak_script_blocked
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked);'
          then:
            - logger.log: "Starting all enabled zones - Cycle & Soak mode"
      
      # Turn off Auto Advance for cycle & soak
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked);'
          then:
            - switch.turn_off: dev1_auto_advance
            - logger.log: "Auto Advance OFF for Cycle & Soak"
      
      # Set busy flags
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked);'
          then:
            - lambda: |-
                id(irrigation_busy) = true;
                id(in_program_run) = false;
      
      # Zone 1
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone1_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 0
                duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 2
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone2_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 1
                duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 3
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone3_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 2
                duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 4
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone4_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 3
                duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 5
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone5_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 4
                duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 6
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone6_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 5
                duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 7
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone7_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 6
                duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 8
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked) && id(zone8_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 7
                duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                add_delay: false
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked);'
          then:
            - lambda: |-
                ESP_LOGI("irrigation", "");
                ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGI("irrigation", "âœ… ALL ENABLED ZONES COMPLETE");
                ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGI("irrigation", "   Multiplier used: %.2f", id($devicename1).multiplier());
                ESP_LOGI("irrigation", "   Trigger: %s", id(watering_trigger_source).c_str());
                ESP_LOGI("irrigation", "   Water usage: See individual zone logs above");
                ESP_LOGI("irrigation", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                ESP_LOGI("irrigation", "");
      
      # BUG #31 FIX: Combine cleanup into a single block â€” no delays between clearing
      # irrigation_busy and calling drain_queue. Same pattern as Bug #28 in run_program.
      # Previously: irrigation_busy cleared, then 500ms for auto_advance, then 100ms
      # before drain_queue. During those 600ms a new press saw busy=false and started
      # immediately, then drain_queue fired and also started something â†’ conflict.
      - if:
          condition:
            lambda: 'return !id(cycle_soak_script_blocked);'
          then:
            - switch.turn_off: cycle_soak_switch
            - logger.log: "ğŸ”„ Cycle & Soak Mode: OFF (watering complete)"
            - text_sensor.template.publish:
                id: dev1_valve_status
                state: "Idle"
            - logger.log: "Valve status reset to Idle"
            - switch.turn_on: dev1_auto_advance
            - logger.log: "Auto Advance restored to ON"
            - lambda: |-
                id(irrigation_busy) = false;
                id(in_program_run) = false;
            - script.execute: drain_queue

  # Run a specific program
  - id: run_program
    mode: single
    parameters:
      program: int  # 1=A, 2=B, 3=C
    then:
      - lambda: |-
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // PRE-FLIGHT: ALL SAFETY CHECKS BEFORE RELAY FIRES
          // run_zone_with_cycles also checks per-zone, but this stops the whole
          // program immediately so no zones ever start if conditions are bad.
          //
          // NOTE: Callers (request_program_start, drain_queue) set irrigation_busy=true
          // BEFORE calling this script. If we need to block, we must clear it here.
          // Using a flag (not self-stop) because calling script.stop() from within
          // your own running lambda causes stack corruption and a WDT reset.
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          auto now = id(homeassistant_time).now();

          // Helper: log reason, clear any busy state set by caller, set block flag.
          // Using a local bool so subsequent lambdas in this then: block can skip.
          // (ESPHome lambdas cannot share a local across blocks, so we reuse zone_run_blocked.)
          // We borrow zone_run_blocked here â€” it is always reset at the start of every
          // run_zone_with_cycles call, so there is no cross-contamination.
          auto _prog_block = [&](const char* reason) {
            ESP_LOGW("irrigation", "ğŸš« Program %d BLOCKED â€” %s", program, reason);
            // Callers set irrigation_busy=true before execute() â€” clear it now.
            id(irrigation_busy) = false;
            id(in_program_run) = false;
            id(watering_trigger_source) = "Idle";
            // Signal all subsequent lambdas/actions in this then: block to skip.
            id(zone_run_blocked) = true;
          };

          // Reset block flag
          id(zone_run_blocked) = false;

          // 1. SYSTEM ENABLE
          if (!id(irrigation_system_enable).state) {
            _prog_block("irrigation system disabled"); return;
          }
          // 2. FREEZE PROTECTION
          if (id(freeze_protection_active)) {
            char _fb[64]; snprintf(_fb, sizeof(_fb), "freeze protection active (%.1fÂ°C)", id(outside_temperature).state);
            _prog_block(_fb); return;
          }
          // 3. WATER BUDGET
          if (id(budget_exceeded) && !id(budget_override_active)) {
            char _bb[80]; snprintf(_bb, sizeof(_bb), "monthly budget exceeded (%.0fL / %.0fL)", id(current_month_usage), id(monthly_water_budget));
            _prog_block(_bb); return;
          }
          // 4. RAIN DELAY
          if (now.is_valid() && id(rain_delay_end_time) > now.timestamp) {
            int64_t _rd = (id(rain_delay_end_time) - now.timestamp) / ${seconds_per_day};
            char _rb[64]; snprintf(_rb, sizeof(_rb), "rain delay active (%lld day(s) remaining)", _rd);
            _prog_block(_rb); return;
          }
          // 5. BLACKOUT DATES (incl. NZ public holidays via is_blackout_date sensor)
          if (id(is_blackout_date).state) { _prog_block("blackout date active"); return; }
          // 6. TIME RESTRICTION
          if (id(is_time_restricted)) {
            _prog_block("outside allowed watering window"); return;
          }
          // 7. WEATHER
          if (!id(manual_weather_override)) {
            std::string weather = id(weather_forecast_home).state;
            if (!weather.empty() && weather != "unknown" && weather != "unavailable") {
              if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                char _wb[80]; snprintf(_wb, sizeof(_wb), "bad weather: %s (enable Weather Override to force)", weather.c_str());
                _prog_block(_wb); return;
              }
            }
            ESP_LOGI("irrigation", "â˜€ï¸ Weather check PASSED - Program %d starting", program);
          } else {
            std::string weather = id(weather_forecast_home).state;
            if (!weather.empty() && (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy")) {
              ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Program %d starting despite: %s", program, weather.c_str());
            }
          }

          if (!id(zone_run_blocked)) {
            // âœ… ALL CHECKS PASSED â€” safe to mark program as active
            id(irrigation_busy) = true;
            id(in_program_run) = true;
            ESP_LOGI("irrigation", "ğŸ¯ PROGRAM %d STARTING | Checking zone assignments...", program);
          }
      
      # Log zone count for this program and store active program
      - lambda: |-
          if (id(zone_run_blocked)) return;  // Safety blocked in pre-flight
          int zone_count = 0;
          if (id(zone1_program) == program && id(zone1_enable).state) zone_count++;
          if (id(zone2_program) == program && id(zone2_enable).state) zone_count++;
          if (id(zone3_program) == program && id(zone3_enable).state) zone_count++;
          if (id(zone4_program) == program && id(zone4_enable).state) zone_count++;
          if (id(zone5_program) == program && id(zone5_enable).state) zone_count++;
          if (id(zone6_program) == program && id(zone6_enable).state) zone_count++;
          if (id(zone7_program) == program && id(zone7_enable).state) zone_count++;
          if (id(zone8_program) == program && id(zone8_enable).state) zone_count++;
          ESP_LOGI("irrigation", "Program %d has %d enabled zones", program, zone_count);

      # Run each zone in the program
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone1_program) == program && id(zone1_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 0
                duration: !lambda |-
                  // OPTION 2: Per-Program Zone Duration Override
                  int default_duration = id(Lawn_irrigation_controller_1_duration).state * 60;
                  int override_duration = 0;
                  
                  if (program == 1 && id(zone1_program_a_duration) > 0) {
                    override_duration = id(zone1_program_a_duration) * 60;
                    ESP_LOGI("irrigation", "${dev1_zone1}: Using ${program_a_name} override: %d min", id(zone1_program_a_duration));
                  } else if (program == 2 && id(zone1_program_b_duration) > 0) {
                    override_duration = id(zone1_program_b_duration) * 60;
                    ESP_LOGI("irrigation", "${dev1_zone1}: Using ${program_b_name} override: %d min", id(zone1_program_b_duration));
                  } else if (program == 3 && id(zone1_program_c_duration) > 0) {
                    override_duration = id(zone1_program_c_duration) * 60;
                    ESP_LOGI("irrigation", "${dev1_zone1}: Using ${program_c_name} override: %d min", id(zone1_program_c_duration));
                  }
                  
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone2_program) == program && id(zone2_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 1
                duration: !lambda |-
                  int default_duration = id(Lawn_irrigation_controller_2_duration).state * 60;
                  int override_duration = 0;
                  
                  if (program == 1 && id(zone2_program_a_duration) > 0) {
                    override_duration = id(zone2_program_a_duration) * 60;
                  } else if (program == 2 && id(zone2_program_b_duration) > 0) {
                    override_duration = id(zone2_program_b_duration) * 60;
                  } else if (program == 3 && id(zone2_program_c_duration) > 0) {
                    override_duration = id(zone2_program_c_duration) * 60;
                  }
                  
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone3_program) == program && id(zone3_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 2
                duration: !lambda |-
                  int default_duration = id(Lawn_irrigation_controller_3_duration).state * 60;
                  int override_duration = 0;
                  if (program == 1 && id(zone3_program_a_duration) > 0) {
                    override_duration = id(zone3_program_a_duration) * 60;
                  } else if (program == 2 && id(zone3_program_b_duration) > 0) {
                    override_duration = id(zone3_program_b_duration) * 60;
                  } else if (program == 3 && id(zone3_program_c_duration) > 0) {
                    override_duration = id(zone3_program_c_duration) * 60;
                  }
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone4_program) == program && id(zone4_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 3
                duration: !lambda |-
                  int default_duration = id(Lawn_irrigation_controller_4_duration).state * 60;
                  int override_duration = 0;
                  if (program == 1 && id(zone4_program_a_duration) > 0) { override_duration = id(zone4_program_a_duration) * 60;
                  } else if (program == 2 && id(zone4_program_b_duration) > 0) { override_duration = id(zone4_program_b_duration) * 60;
                  } else if (program == 3 && id(zone4_program_c_duration) > 0) { override_duration = id(zone4_program_c_duration) * 60;
                  }
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone5_program) == program && id(zone5_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 4
                duration: !lambda |-
                  int default_duration = id(Lawn_irrigation_controller_5_duration).state * 60;
                  int override_duration = 0;
                  if (program == 1 && id(zone5_program_a_duration) > 0) { override_duration = id(zone5_program_a_duration) * 60;
                  } else if (program == 2 && id(zone5_program_b_duration) > 0) { override_duration = id(zone5_program_b_duration) * 60;
                  } else if (program == 3 && id(zone5_program_c_duration) > 0) { override_duration = id(zone5_program_c_duration) * 60;
                  }
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone6_program) == program && id(zone6_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 5
                duration: !lambda |-
                  int default_duration = id(Lawn_irrigation_controller_6_duration).state * 60;
                  int override_duration = 0;
                  if (program == 1 && id(zone6_program_a_duration) > 0) { override_duration = id(zone6_program_a_duration) * 60;
                  } else if (program == 2 && id(zone6_program_b_duration) > 0) { override_duration = id(zone6_program_b_duration) * 60;
                  } else if (program == 3 && id(zone6_program_c_duration) > 0) { override_duration = id(zone6_program_c_duration) * 60;
                  }
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone7_program) == program && id(zone7_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 6
                duration: !lambda |-
                  int default_duration = id(Lawn_irrigation_controller_7_duration).state * 60;
                  int override_duration = 0;
                  if (program == 1 && id(zone7_program_a_duration) > 0) { override_duration = id(zone7_program_a_duration) * 60;
                  } else if (program == 2 && id(zone7_program_b_duration) > 0) { override_duration = id(zone7_program_b_duration) * 60;
                  } else if (program == 3 && id(zone7_program_c_duration) > 0) { override_duration = id(zone7_program_c_duration) * 60;
                  }
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked) && id(zone8_program) == program && id(zone8_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 7
                duration: !lambda |-
                  int default_duration = id(Lawn_irrigation_controller_8_duration).state * 60;
                  int override_duration = 0;
                  if (program == 1 && id(zone8_program_a_duration) > 0) { override_duration = id(zone8_program_a_duration) * 60;
                  } else if (program == 2 && id(zone8_program_b_duration) > 0) { override_duration = id(zone8_program_b_duration) * 60;
                  } else if (program == 3 && id(zone8_program_c_duration) > 0) { override_duration = id(zone8_program_c_duration) * 60;
                  }
                  return (override_duration > 0) ? override_duration : default_duration;
                add_delay: false
                force_normal: false
            - script.wait: run_zone_with_cycles

      # Update last run time ONLY for interval-based schedules (type 3)
      - lambda: |-
          if (id(zone_run_blocked)) return;  // Pre-flight blocked â€” skip completion logging
          int64_t now = id(homeassistant_time).now().timestamp;
          
          // Only update last_run for interval schedules (type 3)
          if (program == 1 && id(program_a_schedule_type) == 3) {
            id(program_a_last_run) = now;
            ESP_LOGI("irrigation", "${program_a_name} last run updated for interval scheduling");
          } else if (program == 2 && id(program_b_schedule_type) == 3) {
            id(program_b_last_run) = now;
            ESP_LOGI("irrigation", "${program_b_name} last run updated for interval scheduling");
          } else if (program == 3 && id(program_c_schedule_type) == 3) {
            id(program_c_last_run) = now;
            ESP_LOGI("irrigation", "${program_c_name} last run updated for interval scheduling");
          }
          
          // Get program name from substitutions
          std::string prog_name = "Program ";
          prog_name += std::to_string(program);
          if (program == 1) prog_name = "${program_a_name}";
          else if (program == 2) prog_name = "${program_b_name}";
          else if (program == 3) prog_name = "${program_c_name}";
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ‰ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ‰ %s COMPLETE!", prog_name.c_str());
          ESP_LOGI("irrigation", "ğŸ‰ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "   All zones watered successfully");
          ESP_LOGI("irrigation", "   Total cycle & soak time: See zone logs above");
          ESP_LOGI("irrigation", "   Monthly usage: %.1f / %.1f L (%.1f%%)",
                   id(current_month_usage), id(monthly_water_budget),
                   id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0 : 0.0);
          ESP_LOGI("irrigation", "ğŸ‰ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "");
          
          id(in_program_run) = false;
          id(irrigation_busy) = false;
      
      # Reset valve status, restore Auto Advance, and drain queue
      - if:
          condition:
            lambda: 'return !id(zone_run_blocked);'
          then:
            - text_sensor.template.publish:
                id: dev1_valve_status
                state: "Idle"
            - logger.log: "Valve status reset to Idle"
            # BUG #28 FIX: Auto-advance restore and drain_queue were previously separated
            # by 500ms + 100ms delays. During those 600ms the watchdog could fire its own
            # clean-completion path and call drain_queue concurrently (mode:restart â†’ one
            # cancels the other). Execute both immediately: no yield gap, no race.
            - switch.turn_on: dev1_auto_advance
            - logger.log: "Auto Advance ON"
            - script.execute: drain_queue

  # Check if current time is within the restriction window
  - id: check_time_restriction
    mode: single
    then:
      - lambda: |-
          // Check if time restriction is disabled
          if (!id(time_restriction_switch).state) {
            id(is_time_restricted) = false;
            if (id(last_time_restriction_state) != 3) {
              ESP_LOGD("irrigation", "â° Time restriction DISABLED");
              id(last_time_restriction_state) = 3;
            }
            return;
          }
          
          // Check if manual override is active
          if (id(manual_time_restriction_override).state) {
            id(is_time_restricted) = false;
            if (id(last_time_restriction_state) != 2) {
              ESP_LOGI("irrigation", "â° Time restriction OVERRIDDEN - watering allowed");
              id(last_time_restriction_state) = 2;
            }
            return;
          }
          
          auto now = id(homeassistant_time).now();
          if (!now.is_valid()) {
            // Time not synced â€” default to RESTRICTED to prevent watering
            // outside the allowed window during the boot period
            id(is_time_restricted) = true;
            return;
          }
          
          // Convert 12-hour to 24-hour format
          int sh = id(restrict_start_hour);
          int eh = id(restrict_end_hour);
          int start_hour24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
          int end_hour24   = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
          
          // Calculate time in minutes since midnight
          int now_min = now.hour * 60 + now.minute;
          int start_min = start_hour24 * 60 + id(restrict_start_minute);
          int end_min   = end_hour24 * 60 + id(restrict_end_minute);
          
          // Check if current time is in restricted window
          bool blocked = (start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                                : (now_min >= start_min || now_min < end_min);
          
          id(is_time_restricted) = blocked;


###############################################
# NZ PUBLIC HOLIDAY QUICK SELECT
###############################################
# Select a holiday from dropdown to automatically add to blackout dates
# Dates update automatically each year via Home Assistant automation

select:
  - platform: template
    id: nz_holiday_quick_select
    name: "ğŸ‡³ğŸ‡¿ Holiday Quick Add"
    icon: "mdi:calendar-star"
    optimistic: true
    options:
      - "Select Holiday..."
      - "New Year's Day"
      - "Day after New Year"
      - "Waitangi Day"
      - "Good Friday"
      - "Easter Monday"
      - "ANZAC Day"
      - "Kings Birthday"
      - "Matariki"
      - "Labour Day"
      - "Christmas Day"
      - "Boxing Day"
    initial_option: "Select Holiday..."
    set_action:
      - lambda: |-
          std::string holiday = x;
          
          if (holiday == "Select Holiday...") {
            return; // Do nothing
          }
          
          // Get current year â€” must have valid time before calculating dates
          auto now = id(homeassistant_time).now();
          if (!now.is_valid()) {
            ESP_LOGW("irrigation", "âš ï¸ Holiday Quick Add: time not synced yet â€” try again in a moment");
            return;
          }
          int year = now.year;
          
          // Find first empty blackout slot
          int slot = -1;
          if (id(blackout_date_1) == 0) slot = 1;
          else if (id(blackout_date_2) == 0) slot = 2;
          else if (id(blackout_date_3) == 0) slot = 3;
          else if (id(blackout_date_4) == 0) slot = 4;
          else if (id(blackout_date_5) == 0) slot = 5;
          else if (id(blackout_date_6) == 0) slot = 6;
          else if (id(blackout_date_7) == 0) slot = 7;
          else if (id(blackout_date_8) == 0) slot = 8;
          else if (id(blackout_date_9) == 0) slot = 9;
          else if (id(blackout_date_10) == 0) slot = 10;
          
          if (slot == -1) {
            ESP_LOGW("irrigation", "âš ï¸ All blackout slots full! Clear a slot first.");
            return;
          }
          
          // Set the date based on holiday selection
          struct tm t = {};
          t.tm_year = year - 1900;
          t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
          
          // Fixed date holidays
          if (holiday == "New Year's Day") {
            t.tm_mon = 0; t.tm_mday = 1;
          } else if (holiday == "Day after New Year") {
            t.tm_mon = 0; t.tm_mday = 2;
          } else if (holiday == "Waitangi Day") {
            t.tm_mon = 1; t.tm_mday = 6;
          } else if (holiday == "ANZAC Day") {
            t.tm_mon = 3; t.tm_mday = 25;
          } else if (holiday == "Christmas Day") {
            t.tm_mon = 11; t.tm_mday = 25;
          } else if (holiday == "Boxing Day") {
            t.tm_mon = 11; t.tm_mday = 26;
          }
          // Variable holidays - source timestamp from HA sensor globals
          int64_t var_date = 0;
          if (holiday == "Good Friday")    var_date = id(good_friday_timestamp);
          else if (holiday == "Easter Monday")  var_date = id(easter_monday_timestamp);
          else if (holiday == "Kings Birthday") var_date = id(kings_birthday_timestamp);
          else if (holiday == "Matariki")       var_date = id(matariki_timestamp);
          else if (holiday == "Labour Day")     var_date = id(labour_day_timestamp);
          
          if (var_date > 0) {
            // Assign to correct blackout slot
            switch(slot) {
              case 1:  id(blackout_date_1)  = var_date; id(blackout_desc_1)  = holiday; break;
              case 2:  id(blackout_date_2)  = var_date; id(blackout_desc_2)  = holiday; break;
              case 3:  id(blackout_date_3)  = var_date; id(blackout_desc_3)  = holiday; break;
              case 4:  id(blackout_date_4)  = var_date; id(blackout_desc_4)  = holiday; break;
              case 5:  id(blackout_date_5)  = var_date; id(blackout_desc_5)  = holiday; break;
              case 6:  id(blackout_date_6)  = var_date; id(blackout_desc_6)  = holiday; break;
              case 7:  id(blackout_date_7)  = var_date; id(blackout_desc_7)  = holiday; break;
              case 8:  id(blackout_date_8)  = var_date; id(blackout_desc_8)  = holiday; break;
              case 9:  id(blackout_date_9)  = var_date; id(blackout_desc_9)  = holiday; break;
              case 10: id(blackout_date_10) = var_date; id(blackout_desc_10) = holiday; break;
            }
            // Update display text field (DD-MM-YYYY format)
            time_t ts = (time_t)var_date;
            struct tm* tm_info = localtime(&ts);
            char date_str[50];
            snprintf(date_str, sizeof(date_str), "%02d-%02d-%04d %s",
                    tm_info->tm_mday, tm_info->tm_mon + 1, tm_info->tm_year + 1900, holiday.c_str());
            switch(slot) {
              case 1:  { auto call = id(blackout_date_1_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 2:  { auto call = id(blackout_date_2_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 3:  { auto call = id(blackout_date_3_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 4:  { auto call = id(blackout_date_4_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 5:  { auto call = id(blackout_date_5_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 6:  { auto call = id(blackout_date_6_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 7:  { auto call = id(blackout_date_7_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 8:  { auto call = id(blackout_date_8_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 9:  { auto call = id(blackout_date_9_text).make_call(); call.set_value(date_str); call.perform(); } break;
              case 10: { auto call = id(blackout_date_10_text).make_call(); call.set_value(date_str); call.perform(); } break;
            }
            ESP_LOGI("irrigation", "\u2705 Added %s to Blackout %d", holiday.c_str(), slot);
            // Reset dropdown back to placeholder
            auto rc = id(nz_holiday_quick_select).make_call();
            rc.set_option("Select Holiday...");
            rc.perform();
            return;
          } else if (var_date == 0 && (holiday == "Good Friday" || holiday == "Easter Monday" ||
                     holiday == "Kings Birthday" || holiday == "Matariki" || holiday == "Labour Day")) {
            ESP_LOGW("irrigation", "\u26A0\uFE0F %s timestamp not available - check Home Assistant sensor", holiday.c_str());
            return;
          }
          
          // For fixed date holidays, calculate the timestamp
          time_t timestamp = mktime(&t);
          
          // Set to appropriate blackout slot
          switch(slot) {
            case 1: id(blackout_date_1) = timestamp; id(blackout_desc_1) = holiday; break;
            case 2: id(blackout_date_2) = timestamp; id(blackout_desc_2) = holiday; break;
            case 3: id(blackout_date_3) = timestamp; id(blackout_desc_3) = holiday; break;
            case 4: id(blackout_date_4) = timestamp; id(blackout_desc_4) = holiday; break;
            case 5: id(blackout_date_5) = timestamp; id(blackout_desc_5) = holiday; break;
            case 6: id(blackout_date_6) = timestamp; id(blackout_desc_6) = holiday; break;
            case 7: id(blackout_date_7) = timestamp; id(blackout_desc_7) = holiday; break;
            case 8: id(blackout_date_8) = timestamp; id(blackout_desc_8) = holiday; break;
            case 9: id(blackout_date_9) = timestamp; id(blackout_desc_9) = holiday; break;
            case 10: id(blackout_date_10) = timestamp; id(blackout_desc_10) = holiday; break;
          }
          
          // Update the corresponding text field so it shows in the UI
          char date_str[50];
          snprintf(date_str, sizeof(date_str), "%02d-%02d-%04d %s", t.tm_mday, t.tm_mon + 1, year, holiday.c_str());
          
          switch(slot) {
            case 1:  { auto call = id(blackout_date_1_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 2:  { auto call = id(blackout_date_2_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 3:  { auto call = id(blackout_date_3_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 4:  { auto call = id(blackout_date_4_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 5:  { auto call = id(blackout_date_5_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 6:  { auto call = id(blackout_date_6_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 7:  { auto call = id(blackout_date_7_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 8:  { auto call = id(blackout_date_8_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 9:  { auto call = id(blackout_date_9_text).make_call(); call.set_value(date_str); call.perform(); } break;
            case 10: { auto call = id(blackout_date_10_text).make_call(); call.set_value(date_str); call.perform(); } break;
          }
          
          ESP_LOGI("irrigation", "âœ… Added %s (%d) to Blackout %d", holiday.c_str(), year, slot);

          // Reset dropdown back to placeholder so user can add another
          auto call = id(nz_holiday_quick_select).make_call();
          call.set_option("Select Holiday...");
          call.perform();


###############################################
# Customizable Zone Names (Runtime)
###############################################
# These allow users to customize zone names in Home Assistant
# without reflashing the ESP32. They initialize to the substitution values.

  # AM-PM selector
  - platform: template
    id: schedule_am_pm
    name: "Weekly Schedule AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots

  # Time Restriction AM-PM
  - platform: template
    id: restrict_start_am_pm_select
    name: "Time Restriction Start AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"  # Default: 10:00 AM (Whanganui recommended - restriction starts mid-morning)
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(restrict_start_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: restrict_end_am_pm_select
    name: "Time Restriction End AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"  # Default: 6:00 PM (Whanganui recommended - restriction ends in evening)
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(restrict_end_am_pm) = (x == "AM") ? 0 : 1;

  # Watering Window 1 Start AM-PM
  - platform: template
    id: window1_start_am_pm_select
    name: "$dev1_what Window 1 Start AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(window1_start_am_pm) = (x == "AM") ? 0 : 1;
          ESP_LOGI("irrigation", "ğŸ• Window 1 start AM/PM updated to %s", x.c_str());

  # Watering Window 1 End AM-PM
  - platform: template
    id: window1_end_am_pm_select
    name: "$dev1_what Window 1 End AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(window1_end_am_pm) = (x == "AM") ? 0 : 1;
          ESP_LOGI("irrigation", "ğŸ• Window 1 end AM/PM updated to %s", x.c_str());

  # Watering Window 2 Start AM-PM
  - platform: template
    id: window2_start_am_pm_select
    name: "$dev1_what Window 2 Start AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(window2_start_am_pm) = (x == "AM") ? 0 : 1;
          ESP_LOGI("irrigation", "ğŸ• Window 2 start AM/PM updated to %s", x.c_str());

  # Watering Window 2 End AM-PM
  - platform: template
    id: window2_end_am_pm_select
    name: "$dev1_what Window 2 End AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(window2_end_am_pm) = (x == "AM") ? 0 : 1;
          ESP_LOGI("irrigation", "ğŸ• Window 2 end AM/PM updated to %s", x.c_str());

  # Watering Window 3 Start AM-PM
  - platform: template
    id: window3_start_am_pm_select
    name: "$dev1_what Window 3 Start AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(window3_start_am_pm) = (x == "AM") ? 0 : 1;
          ESP_LOGI("irrigation", "ğŸ• Window 3 start AM/PM updated to %s", x.c_str());

  # Watering Window 3 End AM-PM
  - platform: template
    id: window3_end_am_pm_select
    name: "$dev1_what Window 3 End AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(window3_end_am_pm) = (x == "AM") ? 0 : 1;
          ESP_LOGI("irrigation", "ğŸ• Window 3 end AM/PM updated to %s", x.c_str());

# Program 1 schedule type
  - platform: template
    id: program_a_schedule_type_select
    name: "${program_a_name} Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_a_schedule_type) = 0;
          else if (x == "Odd Days") id(program_a_schedule_type) = 1;
          else if (x == "Even Days") id(program_a_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_a_schedule_type) = 3;

  # Program 1 AM-PM
  - platform: template
    id: program_a_am_pm_select
    name: "${program_a_name} Start #1 - AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(program_a_am_pm) = (x == "AM") ? 0 : 1;

  # Program 2 schedule type
  - platform: template
    id: program_b_schedule_type_select
    name: "${program_b_name} Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_b_schedule_type) = 0;
          else if (x == "Odd Days") id(program_b_schedule_type) = 1;
          else if (x == "Even Days") id(program_b_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_b_schedule_type) = 3;

  # Program 2 AM-PM
  - platform: template
    id: program_b_am_pm_select
    name: "${program_b_name} Start #1 - AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(program_b_am_pm) = (x == "AM") ? 0 : 1;

  # Program 3 schedule type
  - platform: template
    id: program_c_schedule_type_select
    name: "${program_c_name} Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_c_schedule_type) = 0;
          else if (x == "Odd Days") id(program_c_schedule_type) = 1;
          else if (x == "Even Days") id(program_c_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_c_schedule_type) = 3;

  # Program 3 AM-PM
  - platform: template
    id: program_c_am_pm_select
    name: "${program_c_name} Start #1 - AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(program_c_am_pm) = (x == "AM") ? 0 : 1;

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # AM/PM SELECTORS FOR ADDITIONAL START TIMES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    id: program_a_am_pm_select_2
    name: "${program_a_name} Start #2 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_a_am_pm_2) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_a_am_pm_2) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_a_am_pm_select_3
    name: "${program_a_name} Start #3 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_a_am_pm_3) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_a_am_pm_3) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_a_am_pm_select_4
    name: "${program_a_name} Start #4 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_a_am_pm_4) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_a_am_pm_4) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_b_am_pm_select_2
    name: "${program_b_name} Start #2 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_b_am_pm_2) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_b_am_pm_2) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_b_am_pm_select_3
    name: "${program_b_name} Start #3 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_b_am_pm_3) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_b_am_pm_3) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_b_am_pm_select_4
    name: "${program_b_name} Start #4 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_b_am_pm_4) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_b_am_pm_4) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_c_am_pm_select_2
    name: "${program_c_name} Start #2 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_c_am_pm_2) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_c_am_pm_2) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_c_am_pm_select_3
    name: "${program_c_name} Start #3 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_c_am_pm_3) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_c_am_pm_3) = (x == \"AM\") ? 0 : 1;"
  
  - platform: template
    id: program_c_am_pm_select_4
    name: "${program_c_name} Start #4 - AM-PM"
    icon: "mdi:weather-sunny"
    options:
      - "AM"
      - "PM"
    lambda: "return (id(program_c_am_pm_4) == 0) ? std::string(\"AM\") : std::string(\"PM\");"
    set_action:
      - lambda: "id(program_c_am_pm_4) = (x == \"AM\") ? 0 : 1;"


  # Zone Schedule AM-PM Selectors
  - platform: template
    id: zone1_schedule_am_pm
    name: "${dev1_zone1} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone1_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone2_schedule_am_pm
    name: "${dev1_zone2} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone2_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone3_schedule_am_pm
    name: "${dev1_zone3} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone3_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone4_schedule_am_pm
    name: "${dev1_zone4} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone4_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone5_schedule_am_pm
    name: "${dev1_zone5} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone5_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone6_schedule_am_pm
    name: "${dev1_zone6} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone6_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone7_schedule_am_pm
    name: "${dev1_zone7} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone7_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone8_schedule_am_pm
    name: "${dev1_zone8} Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          id(zone8_am_pm) = (x == "AM") ? 0 : 1;

  # Zone program assignment selects
  - platform: template
    id: zone1_program_select
    name: "${dev1_zone1} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone1_program) = 0;
          else if (x == "${program_a_name}") id(zone1_program) = 1;
          else if (x == "${program_b_name}") id(zone1_program) = 2;
          else if (x == "${program_c_name}") id(zone1_program) = 3;

  - platform: template
    id: zone2_program_select
    name: "${dev1_zone2} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone2_program) = 0;
          else if (x == "${program_a_name}") id(zone2_program) = 1;
          else if (x == "${program_b_name}") id(zone2_program) = 2;
          else if (x == "${program_c_name}") id(zone2_program) = 3;

  - platform: template
    id: zone3_program_select
    name: "${dev1_zone3} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone3_program) = 0;
          else if (x == "${program_a_name}") id(zone3_program) = 1;
          else if (x == "${program_b_name}") id(zone3_program) = 2;
          else if (x == "${program_c_name}") id(zone3_program) = 3;

  - platform: template
    id: zone4_program_select
    name: "${dev1_zone4} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone4_program) = 0;
          else if (x == "${program_a_name}") id(zone4_program) = 1;
          else if (x == "${program_b_name}") id(zone4_program) = 2;
          else if (x == "${program_c_name}") id(zone4_program) = 3;

  - platform: template
    id: zone5_program_select
    name: "${dev1_zone5} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone5_program) = 0;
          else if (x == "${program_a_name}") id(zone5_program) = 1;
          else if (x == "${program_b_name}") id(zone5_program) = 2;
          else if (x == "${program_c_name}") id(zone5_program) = 3;

  - platform: template
    id: zone6_program_select
    name: "${dev1_zone6} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone6_program) = 0;
          else if (x == "${program_a_name}") id(zone6_program) = 1;
          else if (x == "${program_b_name}") id(zone6_program) = 2;
          else if (x == "${program_c_name}") id(zone6_program) = 3;

  - platform: template
    id: zone7_program_select
    name: "${dev1_zone7} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone7_program) = 0;
          else if (x == "${program_a_name}") id(zone7_program) = 1;
          else if (x == "${program_b_name}") id(zone7_program) = 2;
          else if (x == "${program_c_name}") id(zone7_program) = 3;

  - platform: template
    id: zone8_program_select
    name: "${dev1_zone8} Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "${program_a_name}"
      - "${program_b_name}"
      - "${program_c_name}"
    initial_option: "${program_a_name}"
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "None") id(zone8_program) = 0;
          else if (x == "${program_a_name}") id(zone8_program) = 1;
          else if (x == "${program_b_name}") id(zone8_program) = 2;
          else if (x == "${program_c_name}") id(zone8_program) = 3;

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SOIL TYPE SELECTOR (Whanganui - Sandy Soil)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    id: soil_type_select
    name: "$dev1_what Soil Type"
    icon: "mdi:sprout"
    optimistic: true
    options:
      - "Sand"
      - "Loam"
      - "Clay"
    initial_option: "Sand"  # Whanganui default
    restore_value: True  # USER SETTING - must persist across reboots
    set_action:
      - lambda: |-
          if (x == "Sand") {
            id(soil_type) = 0;
            // Auto-adjust cycle & soak for sand (fast drainage)
            id(cycle_duration_minutes) = 10;
            id(soak_duration_minutes) = 5;
            ESP_LOGI("irrigation", "ğŸŒ± Soil Type: SAND");
            ESP_LOGI("irrigation", "   ET Factor: 1.15x (drains fast, needs more frequent)");
            ESP_LOGI("irrigation", "   Cycle/Soak: 10min/5min (light, frequent applications)");
          } else if (x == "Loam") {
            id(soil_type) = 1;
            // Standard cycle & soak for loam (balanced)
            id(cycle_duration_minutes) = 15;
            id(soak_duration_minutes) = 10;
            ESP_LOGI("irrigation", "ğŸŒ± Soil Type: LOAM");
            ESP_LOGI("irrigation", "   ET Factor: 1.00x (balanced moisture retention)");
            ESP_LOGI("irrigation", "   Cycle/Soak: 15min/10min (standard applications)");
          } else if (x == "Clay") {
            id(soil_type) = 2;
            // Long soak for clay (slow drainage, prevent runoff)
            id(cycle_duration_minutes) = 10;
            id(soak_duration_minutes) = 15;
            ESP_LOGI("irrigation", "ğŸŒ± Soil Type: CLAY");
            ESP_LOGI("irrigation", "   ET Factor: 0.85x (holds moisture longer)");
            ESP_LOGI("irrigation", "   Cycle/Soak: 10min/15min (prevent runoff)");
          }

text:
  - platform: template
    name: "$dev1_zone1 Name"
    id: zone1_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone1"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots

  - platform: template
    name: "$dev1_zone2 Name"
    id: zone2_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone2"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots


  - platform: template
    name: "$dev1_zone3 Name"
    id: zone3_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone3"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots

  - platform: template
    name: "$dev1_zone4 Name"
    id: zone4_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone4"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots

  - platform: template
    name: "$dev1_zone5 Name"
    id: zone5_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone5"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots

  - platform: template
    name: "$dev1_zone6 Name"
    id: zone6_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone6"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots

  - platform: template
    name: "$dev1_zone7 Name"
    id: zone7_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone7"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots

  - platform: template
    name: "$dev1_zone8 Name"
    id: zone8_name
    icon: "mdi:rename-box"
    optimistic: true
    min_length: 1
    max_length: 20
    initial_value: "$dev1_zone8"
    mode: text
    restore_value: True  # USER SETTING - must persist across reboots

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLACKOUT DATES (Persistent + User-Friendly)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SINGLE FIELD FORMAT: "DD-MM-YYYY Description" (description optional)
  # 
  # âœ… EXAMPLES:
  #   "25-12-2024 Christmas"
  #   "01-01-2025 New Year's Day"
  #   "15-03-2025 Water Main Maintenance"
  #   "25-12-2024" (date only, no description)
  # 
  # ğŸ—‘ï¸ TO CLEAR: Type "clear" or leave empty
  # ğŸ’¾ PERSISTS: All entries saved across reboots
  # ğŸš« EFFECT: NO irrigation will run on blackout dates
  
  - platform: template
    id: blackout_date_1_text
    name: "ğŸš« Blackout 01 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_1) = 0;
              id(blackout_desc_1) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 1 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_1) = (int64_t)mktime(&t);
                  id(blackout_desc_1) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 1 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 1 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_2_text
    name: "ğŸš« Blackout 02 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_2) = 0;
              id(blackout_desc_2) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 2 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_2) = (int64_t)mktime(&t);
                  id(blackout_desc_2) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 2 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 2 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_3_text
    name: "ğŸš« Blackout 03 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_3) = 0;
              id(blackout_desc_3) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 3 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_3) = (int64_t)mktime(&t);
                  id(blackout_desc_3) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 3 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 3 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_4_text
    name: "ğŸš« Blackout 04 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_4) = 0;
              id(blackout_desc_4) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 4 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_4) = (int64_t)mktime(&t);
                  id(blackout_desc_4) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 4 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 4 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_5_text
    name: "ğŸš« Blackout 05 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_5) = 0;
              id(blackout_desc_5) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 5 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_5) = (int64_t)mktime(&t);
                  id(blackout_desc_5) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 5 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 5 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_6_text
    name: "ğŸš« Blackout 06 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_6) = 0;
              id(blackout_desc_6) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 6 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_6) = (int64_t)mktime(&t);
                  id(blackout_desc_6) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 6 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 6 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_7_text
    name: "ğŸš« Blackout 07 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_7) = 0;
              id(blackout_desc_7) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 7 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_7) = (int64_t)mktime(&t);
                  id(blackout_desc_7) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 7 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 7 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_8_text
    name: "ğŸš« Blackout 08 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_8) = 0;
              id(blackout_desc_8) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 8 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_8) = (int64_t)mktime(&t);
                  id(blackout_desc_8) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 8 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 8 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_9_text
    name: "ğŸš« Blackout 09 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_9) = 0;
              id(blackout_desc_9) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 9 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_9) = (int64_t)mktime(&t);
                  id(blackout_desc_9) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 9 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 9 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }
  
  - platform: template
    id: blackout_date_10_text
    name: "ğŸš« Blackout 10 (DD-MM-YYYY|clear)"
    icon: "mdi:calendar-remove"
    optimistic: true
    mode: text
    max_length: 30
    restore_value: true
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Skip during boot restore to prevent clearing timestamps
            if (!id(boot_restore_complete)) return;
            
            std::string input = x;
            
            // Clear if empty or "clear"
            if (input.empty() || input == "clear" || input == "0") {
              id(blackout_date_10) = 0;
              id(blackout_desc_10) = "";
              ESP_LOGI("irrigation", "ğŸ—‘ï¸  Blackout 10 cleared");
              return;
            }
            
            // Parse date and optional description
            // Format: "DD-MM-YYYY" or "DD-MM-YYYY Description"
            if (input.length() >= 10) {
              std::string date_part = input.substr(0, 10);
              std::string desc_part = (input.length() > 11) ? input.substr(11) : "";
              
              if (date_part[2] == '-' && date_part[5] == '-') {
                // Extract and validate day, month, year
                int day = atoi(date_part.substr(0, 2).c_str());
                int month = atoi(date_part.substr(3, 2).c_str());
                int year = atoi(date_part.substr(6, 4).c_str());
                
                // Basic validation
                if (day >= 1 && day <= 31 && month >= 1 && month <= 12 && year >= 2020 && year <= 2099) {
                  struct tm t = {};
                  t.tm_mday = day;
                  t.tm_mon = month - 1;
                  t.tm_year = year - 1900;
                  t.tm_hour = 0; t.tm_min = 0; t.tm_sec = 0; t.tm_isdst = -1;
                  
                  id(blackout_date_10) = (int64_t)mktime(&t);
                  id(blackout_desc_10) = desc_part;
                  
                  if (desc_part.empty()) {
                    ESP_LOGI("irrigation", "âœ… Blackout 10 set: %s", date_part.c_str());
                  } else {
                    ESP_LOGI("irrigation", "âœ… Blackout 10 set: %s (%s)", date_part.c_str(), desc_part.c_str());
                  }
                } else {
                  ESP_LOGW("irrigation", "âš ï¸  Invalid date values. Day: 1-31, Month: 1-12, Year: 2020-2099");
                }
              } else {
                ESP_LOGW("irrigation", "âš ï¸  Invalid date format. Use: DD-MM-YYYY");
              }
            } else {
              ESP_LOGW("irrigation", "âš ï¸  Date too short. Use format: DD-MM-YYYY");
            }


output:
  # â”€â”€ ZONE RELAY GPIO OUTPUTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # GPIO outputs are decoupled from the zone template switches.
  # This means the physical pin only ever goes HIGH when our code explicitly calls
  # output.turn_on â€” not when an ESPHome dashboard user toggles a switch entity.
  # Result: zero relay click on any blocked direct activation.
  - platform: gpio
    id: relay_zone_1_out
    pin:
      number: $zone1_pin
      mode:
        output: true
    inverted: true

  - platform: gpio
    id: relay_zone_2_out
    pin:
      number: $zone2_pin
      mode:
        output: true
    inverted: true

  - platform: gpio
    id: relay_zone_3_out
    pin:
      number: $zone3_pin
      mode:
        output: true
    inverted: true

  - platform: gpio
    id: relay_zone_4_out
    pin:
      number: $zone4_pin
      mode:
        output: true
    inverted: true

  - platform: gpio
    id: relay_zone_5_out
    pin:
      number: $zone5_pin
      mode:
        output: true
    inverted: true

  - platform: gpio
    id: relay_zone_6_out
    pin:
      number: $zone6_pin
      mode:
        output: true
    inverted: true

  - platform: gpio
    id: relay_zone_7_out
    pin:
      number: $zone7_pin
      mode:
        output: true
    inverted: true

  - platform: gpio
    id: relay_zone_8_out
    pin:
      number: $zone8_pin
      mode:
        output: true
    inverted: true


switch:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PROGRAM ENABLE SWITCHES & ADDITIONAL START TIME ENABLES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    id: program_a_enable_switch
    name: "âœ… ${program_a_name} Enabled"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(program_a_enabled);"
    turn_on_action:
      - lambda: "id(program_a_enabled) = true;"
    turn_off_action:

      - lambda: "id(program_a_enabled) = false;"
  
  - platform: template
    id: program_b_enable_switch
    name: "âœ… ${program_b_name} Enabled"
    icon: "mdi:alpha-b-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(program_b_enabled);"
    turn_on_action:
      - lambda: "id(program_b_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_b_enabled) = false;"
  
  - platform: template
    id: program_c_enable_switch
    name: "âœ… ${program_c_name} Enabled"
    icon: "mdi:alpha-c-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(program_c_enabled);"
    turn_on_action:
      - lambda: "id(program_c_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_c_enabled) = false;"
  
  - platform: template
    id: program_a_start_time_2_switch
    name: "â° ${program_a_name} - Enable Start #2"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_a_start_time_2_enabled);"
    turn_on_action:
      - lambda: "id(program_a_start_time_2_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_a_start_time_2_enabled) = false;"
  
  - platform: template
    id: program_a_start_time_3_switch
    name: "â° ${program_a_name} - Enable Start #3"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_a_start_time_3_enabled);"
    turn_on_action:
      - lambda: "id(program_a_start_time_3_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_a_start_time_3_enabled) = false;"
  
  - platform: template
    id: program_a_start_time_4_switch
    name: "â° ${program_a_name} - Enable Start #4"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_a_start_time_4_enabled);"
    turn_on_action:
      - lambda: "id(program_a_start_time_4_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_a_start_time_4_enabled) = false;"
  
  - platform: template
    id: program_b_start_time_2_switch
    name: "â° ${program_b_name} - Enable Start #2"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_b_start_time_2_enabled);"
    turn_on_action:
      - lambda: "id(program_b_start_time_2_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_b_start_time_2_enabled) = false;"
  
  - platform: template
    id: program_b_start_time_3_switch
    name: "â° ${program_b_name} - Enable Start #3"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_b_start_time_3_enabled);"
    turn_on_action:
      - lambda: "id(program_b_start_time_3_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_b_start_time_3_enabled) = false;"
  
  - platform: template
    id: program_b_start_time_4_switch
    name: "â° ${program_b_name} - Enable Start #4"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_b_start_time_4_enabled);"
    turn_on_action:
      - lambda: "id(program_b_start_time_4_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_b_start_time_4_enabled) = false;"
  
  - platform: template
    id: program_c_start_time_2_switch
    name: "â° ${program_c_name} - Enable Start #2"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_c_start_time_2_enabled);"
    turn_on_action:
      - lambda: "id(program_c_start_time_2_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_c_start_time_2_enabled) = false;"
  
  - platform: template
    id: program_c_start_time_3_switch
    name: "â° ${program_c_name} - Enable Start #3"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_c_start_time_3_enabled);"
    turn_on_action:
      - lambda: "id(program_c_start_time_3_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_c_start_time_3_enabled) = false;"
  
  - platform: template
    id: program_c_start_time_4_switch
    name: "â° ${program_c_name} - Enable Start #4"
    icon: "mdi:clock-check"
    optimistic: true
    lambda: "return id(program_c_start_time_4_enabled);"
    turn_on_action:
      - lambda: "id(program_c_start_time_4_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_c_start_time_4_enabled) = false;"


  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PREDICTIVE WATERINGâ„¢ MASTER SWITCH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "$dev1_what Predictive Wateringâ„¢"
    id: predictive_watering_switch
    icon: "mdi:weather-partly-rainy"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - lambda: |-
          id(predictive_watering_enabled) = true;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ’§ PREDICTIVE WATERINGâ„¢ ENABLED");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
      - script.execute: calculate_predictive_watering
    on_turn_off:
      - lambda: |-
          id(predictive_watering_enabled) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ PREDICTIVE WATERINGâ„¢ DISABLED");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ Reverting to standard seasonal multiplier");
          
          // Revert to basic seasonal multiplier
          auto now = id(homeassistant_time).now();
          if (!now.is_valid()) {
            // Time unavailable â€” apply safe 1.0 default, halved for vacation
            float _safe = id(vacation_mode_active) ? 0.5f : 1.0f;
            id($devicename1).set_multiplier(_safe);
            return;
          }
          
          int month = now.month;
          float temp = id(outside_temperature).state;
          if (isnan(temp)) temp = 20.0;
          
          // Use substitution variables â€” keeps values consistent with midnight update logic
          float multiplier = 1.0;
          if (month >= 12 || month <= 2) {           // Summer (NZ)
            multiplier = ${summer_base_multiplier};
            if (temp > ${summer_hot_temp_c}) multiplier = ${summer_hot_multiplier};
            if (temp > ${summer_very_hot_temp_c}) multiplier = ${summer_very_hot_multiplier};
          } else if (month >= 6 && month <= 8) {     // Winter (NZ)
            multiplier = ${winter_base_multiplier};
            if (temp < ${winter_cold_temp_c}) multiplier = ${winter_cold_multiplier};
          } else {                                    // Spring/Autumn
            multiplier = ${spring_autumn_base_multiplier};
            if (temp > ${spring_autumn_warm_temp_c}) multiplier = ${spring_autumn_warm_multiplier};
          }
          
          // Honour vacation mode 50% reduction when reverting to seasonal
          float _final = id(vacation_mode_active) ? multiplier * 0.5f : multiplier;
          id(normal_multiplier) = multiplier;  // Save undiscounted value for vacation exit
          id($devicename1).set_multiplier(_final);
          ESP_LOGI("irrigation", "âœ“ Multiplier set to %.2f (basic seasonal%s)",
                   _final, id(vacation_mode_active) ? ", Ã—0.5 vacation" : "");

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MASTER VALVE ENABLE (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Optional feature - system works fine without master valve
  # When ENABLED: Master valve opens automatically with any zone
  # When DISABLED: Zones work independently (normal operation)
  
  - platform: template
    name: "$dev1_what Enable Master Valve"
    id: master_valve_enable_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF  # Off by default - optional feature
    on_turn_on:
      - lambda: |-
          id(master_valve_enabled) = true;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ MASTER VALVE ENABLED");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ Master valve will open automatically when zones run");
          ESP_LOGI("irrigation", "ğŸ”§ Manual controls are now active");
          ESP_LOGI("irrigation", "");
    on_turn_off:
      - lambda: |-
          id(master_valve_enabled) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ MASTER VALVE DISABLED");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ Zones will operate independently (normal mode)");
          ESP_LOGI("irrigation", "âŒ Master valve manual controls disabled for safety");
          ESP_LOGI("irrigation", "");
          
          // Safety: Turn off master valve if it's currently on
          if (id(master_valve_relay).state) {
            ESP_LOGW("irrigation", "âš ï¸ Master valve was ON - closing for safety");
            id(master_valve_relay).turn_off();
          }

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PER-ZONE MASTER VALVE CONTROL
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Control which zones use the master valve (when globally enabled)
  # Allows zones to bypass master valve for well water, drip systems, etc.
  
  - platform: template
    name: "$dev1_zone1 Use Master Valve"
    id: zone1_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Default ON
    lambda: "return id(zone1_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone1_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone1_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone2 Use Master Valve"
    id: zone2_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone2_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone2_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone2_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone3 Use Master Valve"
    id: zone3_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone3_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone3_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone3_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone4 Use Master Valve"
    id: zone4_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone4_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone4_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone4_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone5 Use Master Valve"
    id: zone5_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone5_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone5_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone5_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone6 Use Master Valve"
    id: zone6_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone6_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone6_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone6_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone7 Use Master Valve"
    id: zone7_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone7_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone7_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone7_master_valve_enabled) = false;"

  - platform: template
    name: "$dev1_zone8 Use Master Valve"
    id: zone8_mv_switch
    icon: "mdi:pipe-valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone8_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone8_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone8_master_valve_enabled) = false;"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SMART ET WATERING MASTER SWITCH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "$dev1_what Smart ET Watering"
    id: smart_et_switch
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - lambda: |-
          id(smart_et_enabled) = true;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸŒ± SMART ET WATERING ENABLED");
          ESP_LOGI("irrigation", "ğŸŒ± â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸŒ± System will automatically water based on ET");
          ESP_LOGI("irrigation", "ğŸŒ± Scheduled watering is OVERRIDDEN");
      - script.execute: calculate_smart_et
    on_turn_off:
      - lambda: |-
          id(smart_et_enabled) = false;
          id(et_pending_irrigation) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ SMART ET WATERING DISABLED");
          ESP_LOGI("irrigation", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "âŒ Reverting to scheduled watering");

  # Manual Master Valve Test Button
  - platform: template
    name: "Weekly Schedule - 1 Monday"
    id: schedule_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Weekly Schedule - 2 Tuesday"
    id: schedule_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Weekly Schedule - 3 Wednesday"
    id: schedule_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Weekly Schedule - 4 Thursday"
    id: schedule_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Weekly Schedule - 5 Friday"
    id: schedule_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Weekly Schedule - 6 Saturday"
    id: schedule_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Weekly Schedule - 7 Sunday"
    id: schedule_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SMART ET SCHEDULE DAYS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # These determine which days Smart ET checks if watering is needed
  # Default: Mon/Wed/Fri (every 2-3 days optimal for ET)
  
  - platform: template
    name: "ET Schedule - 1 Monday"
    id: et_schedule_monday
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Start with Mon/Wed/Fri enabled
  - platform: template
    name: "ET Schedule - 2 Tuesday"
    id: et_schedule_tuesday
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "ET Schedule - 3 Wednesday"
    id: et_schedule_wednesday
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    name: "ET Schedule - 4 Thursday"
    id: et_schedule_thursday
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "ET Schedule - 5 Friday"
    id: et_schedule_friday
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    name: "ET Schedule - 6 Saturday"
    id: et_schedule_saturday
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "ET Schedule - 7 Sunday"
    id: et_schedule_sunday
    icon: "mdi:sprinkler-variant"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Cycle and Soak Enable/Disable
  - platform: template
    name: "Cycle and Soak Mode"
    id: cycle_soak_switch
    icon: "mdi:water-sync"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(cycle_soak_enabled);"
    turn_on_action:
      - lambda: "id(cycle_soak_enabled) = true;"
    turn_off_action:
      - lambda: "id(cycle_soak_enabled) = false;"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATERING WINDOW ENABLE SWITCHES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # ET Watering Window 1 Enable
  - platform: template
    name: "ET Watering Window 1 Enable"
    id: window1_enable_switch
    icon: "mdi:clock-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(window1_enabled);"
    turn_on_action:
      - lambda: |-
          id(window1_enabled) = true;
          ESP_LOGI("irrigation", "ğŸ• ET Watering Window 1 ENABLED");
    turn_off_action:
      - lambda: |-
          id(window1_enabled) = false;
          ESP_LOGI("irrigation", "ğŸ• ET Watering Window 1 DISABLED");

  # ET Watering Window 2 Enable
  - platform: template
    name: "ET Watering Window 2 Enable"
    id: window2_enable_switch
    icon: "mdi:clock-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(window2_enabled);"
    turn_on_action:
      - lambda: |-
          id(window2_enabled) = true;
          ESP_LOGI("irrigation", "ğŸ• ET Watering Window 2 ENABLED");
    turn_off_action:
      - lambda: |-
          id(window2_enabled) = false;
          ESP_LOGI("irrigation", "ğŸ• ET Watering Window 2 DISABLED");

  # ET Watering Window 3 Enable
  - platform: template
    name: "ET Watering Window 3 Enable"
    id: window3_enable_switch
    icon: "mdi:clock-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF  # Disabled by default
    lambda: "return id(window3_enabled);"
    turn_on_action:
      - lambda: |-
          id(window3_enabled) = true;
          ESP_LOGI("irrigation", "ğŸ• ET Watering Window 3 ENABLED");
    turn_off_action:
      - lambda: |-
          id(window3_enabled) = false;
          ESP_LOGI("irrigation", "ğŸ• ET Watering Window 3 DISABLED");

  # Master Valve Enable (Optional - Hunter Pro-C Style)
  # Global enable/disable for entire master valve system
  - platform: template
    name: "Time Restriction Override"
    id: manual_time_restriction_override
    icon: "mdi:shield-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - script.execute: check_time_restriction
      - logger.log: "âš ï¸ Time restriction override ON - immediate check triggered"
    turn_off_action:
      - script.execute: check_time_restriction
      - logger.log: "âœ“ Time restriction override OFF - immediate check triggered"

  # Time of Day Restriction (10am-3pm block)
  - platform: template
    name: "Time Restriction Enable"
    id: time_restriction_switch
    icon: "mdi:clock-alert"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

  # Weekly schedule enable
  - platform: template
    name: "Enable Weekly Schedule"
    id: weekly_schedule_switch
    icon: "mdi:calendar-clock"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Manual Rain Delay Override
  - platform: template
    name: "Disable Auto Rain Delay"
    id: manual_rain_delay_override_switch
    icon: "mdi:cloud-off-outline"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(manual_rain_delay_override);"
    turn_on_action:
      - lambda: |-
          id(manual_rain_delay_override) = true;
          // Clear any active rain delay immediately so it stops blocking runs
          id(rain_delay_end_time) = 0;
          id(rain_delay_days) = 0;
          id(rain_delay_days_input).publish_state(0);
          ESP_LOGI("irrigation", "Manual rain delay override enabled - active rain delay CLEARED");
    turn_off_action:
      - lambda: |-
          id(manual_rain_delay_override) = false;
          ESP_LOGI("irrigation", "Manual rain delay override disabled - checking weather immediately");
          
          // Immediately check current weather and apply rain delay if needed
          std::string weather = id(weather_forecast_home).state;
          if (weather.empty() || weather == "unknown" || weather == "unavailable") {
            ESP_LOGW("irrigation", "Weather state unavailable - rain delay will be set on next weather update");
            return;
          }
          
          if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
            id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (${seconds_per_day} * ${auto_rain_delay_days});
            id(rain_delay_days) = ${auto_rain_delay_days};
            id(rain_delay_days_input).publish_state(${auto_rain_delay_days});
            ESP_LOGI("irrigation", "Auto rain delay IMMEDIATELY activated - weather is %s", weather.c_str());
          } else {
            ESP_LOGI("irrigation", "Weather is %s - no rain delay needed", weather.c_str());
          }

  # Manual Weather Override - Force watering in bad weather
  - platform: template
    name: "Weather Override (Force Watering)"
    id: manual_weather_override_switch
    icon: "mdi:weather-lightning-rainy"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(manual_weather_override);"
    turn_on_action:
      - lambda: |-
          id(manual_weather_override) = true;
      - logger.log:
          format: "âš ï¸ WEATHER OVERRIDE ENABLED - Will water in any weather!"
          level: WARN
    turn_off_action:
      - lambda: |-
          id(manual_weather_override) = false;
      - logger.log:
          format: "âœ“ Weather override disabled - Normal weather checks active"
          level: INFO

# Vacation Mode
  - platform: template
    name: "Vacation Mode"
    id: vacation_mode_switch
    icon: "mdi:airplane"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(vacation_mode_active);"
    turn_on_action:
      - lambda: |-
          id(vacation_mode_active) = true;
          // Save the UNDISCOUNTED multiplier as the base to restore on exit.
          // Use pw_current_multiplier when PW is enabled (it tracks the clean value);
          // otherwise use the sprinkler's current value.
          // This prevents saving an ET-boosted value and restoring to it on exit.
          if (id(predictive_watering_enabled)) {
            id(normal_multiplier) = id(pw_current_multiplier);
          } else {
            id(normal_multiplier) = id($devicename1).multiplier();
          }
          // Reduce watering by 50%
          id($devicename1).set_multiplier(id(normal_multiplier) * 0.5);
          // Save zone schedule states before disabling (so we can restore them on exit)
          id(vacation_saved_zone1_sched) = id(zone1_schedule_enabled);
          id(vacation_saved_zone2_sched) = id(zone2_schedule_enabled);
          id(vacation_saved_zone3_sched) = id(zone3_schedule_enabled);
          id(vacation_saved_zone4_sched) = id(zone4_schedule_enabled);
          id(vacation_saved_zone5_sched) = id(zone5_schedule_enabled);
          id(vacation_saved_zone6_sched) = id(zone6_schedule_enabled);
          id(vacation_saved_zone7_sched) = id(zone7_schedule_enabled);
          id(vacation_saved_zone8_sched) = id(zone8_schedule_enabled);
          // Disable all individual zone schedules
          id(zone1_schedule_enabled) = false;
          id(zone2_schedule_enabled) = false;
          id(zone3_schedule_enabled) = false;
          id(zone4_schedule_enabled) = false;
          id(zone5_schedule_enabled) = false;
          id(zone6_schedule_enabled) = false;
          id(zone7_schedule_enabled) = false;
          id(zone8_schedule_enabled) = false;
          ESP_LOGI("irrigation", "Vacation mode activated - watering reduced to 50%%, individual zone schedules disabled");
    turn_off_action:
      - lambda: |-
          id(vacation_mode_active) = false;
          // Restore normal multiplier
          id($devicename1).set_multiplier(id(normal_multiplier));
          // Restore zone schedule states that were saved when vacation mode activated
          id(zone1_schedule_enabled) = id(vacation_saved_zone1_sched);
          id(zone2_schedule_enabled) = id(vacation_saved_zone2_sched);
          id(zone3_schedule_enabled) = id(vacation_saved_zone3_sched);
          id(zone4_schedule_enabled) = id(vacation_saved_zone4_sched);
          id(zone5_schedule_enabled) = id(vacation_saved_zone5_sched);
          id(zone6_schedule_enabled) = id(vacation_saved_zone6_sched);
          id(zone7_schedule_enabled) = id(vacation_saved_zone7_sched);
          id(zone8_schedule_enabled) = id(vacation_saved_zone8_sched);
          ESP_LOGI("irrigation", "Vacation mode deactivated - multiplier and zone schedules restored");

# System Enable/Disable - Master control
  - platform: template
    name: "Irrigation System Enable"
    id: irrigation_system_enable
    icon: "mdi:water"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Defaults to ON (enabled)
    turn_off_action:
      # Stop everything when disabled
      - sprinkler.shutdown: $devicename1
      - script.stop: run_zone_with_cycles
      - lambda: |-
          id(active_zone_number) = -1;
          id(current_cycle) = 0;
          id(total_cycles) = 0;
          id(cycle_soak_total_duration) = 0;
          id(cycle_soak_elapsed_time) = 0;
          id(is_paused) = false;
          ESP_LOGI("irrigation", "Irrigation system DISABLED");
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "System Disabled"

 # Zone Schedule Enable Switches
  - platform: template
    name: "${dev1_zone1} Schedule Enable"
    id: zone1_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone1_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone1_schedule_enabled) = false;"

  - platform: template
    name: "${dev1_zone2} Schedule Enable"
    id: zone2_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone2_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone2_schedule_enabled) = false;"

  - platform: template
    name: "${dev1_zone3} Schedule Enable"
    id: zone3_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone3_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone3_schedule_enabled) = false;"

  - platform: template
    name: "${dev1_zone4} Schedule Enable"
    id: zone4_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone4_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone4_schedule_enabled) = false;"

  - platform: template
    name: "${dev1_zone5} Schedule Enable"
    id: zone5_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone5_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone5_schedule_enabled) = false;"

  - platform: template
    name: "${dev1_zone6} Schedule Enable"
    id: zone6_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone6_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone6_schedule_enabled) = false;"

  - platform: template
    name: "${dev1_zone7} Schedule Enable"
    id: zone7_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone7_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone7_schedule_enabled) = false;"

  - platform: template
    name: "${dev1_zone8} Schedule Enable"
    id: zone8_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone8_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone8_schedule_enabled) = false;"

# Program 1 day selection (only used when schedule type is "Specific Days")
  - platform: template
    name: "${program_a_name} - 1 Monday"
    id: program_a_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_a_name} - 2 Tuesday"
    id: program_a_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_a_name} - 3 Wednesday"
    id: program_a_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_a_name} - 4 Thursday"
    id: program_a_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_a_name} - 5 Friday"
    id: program_a_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_a_name} - 6 Saturday"
    id: program_a_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_a_name} - 7 Sunday"
    id: program_a_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Program 2 day selection
  - platform: template
    name: "${program_b_name} - 1 Monday"
    id: program_b_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_b_name} - 2 Tuesday"
    id: program_b_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_b_name} - 3 Wednesday"
    id: program_b_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_b_name} - 4 Thursday"
    id: program_b_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_b_name} - 5 Friday"
    id: program_b_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_b_name} - 6 Saturday"
    id: program_b_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_b_name} - 7 Sunday"
    id: program_b_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Program 3 day selection
  - platform: template
    name: "${program_c_name} - 1 Monday"
    id: program_c_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_c_name} - 2 Tuesday"
    id: program_c_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_c_name} - 3 Wednesday"
    id: program_c_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_c_name} - 4 Thursday"
    id: program_c_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_c_name} - 5 Friday"
    id: program_c_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_c_name} - 6 Saturday"
    id: program_c_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "${program_c_name} - 7 Sunday"
    id: program_c_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    internal: true
    id: ${devicename1}_1
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 1 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_1).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone1_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 1 BLOCKED (direct) - zone disabled");
            id(${devicename1}_1).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone1} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(0, (int)(id(Lawn_irrigation_controller_1_duration).state * 60), false, false, std::string("Manual: ${dev1_zone1}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_1_out
    turn_off_action:
      - output.turn_off: relay_zone_1_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone1_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 1 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone1} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone1 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // â”€â”€ on_turn_off: SOLE source of water accounting (no duplicate in run_zone_with_cycles) â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone1_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 1 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone1_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 1 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone1_start_time);
          id(zone1_start_time) = 0;  // Reset for next use


          // â”€â”€ Snapshot and reset flow sensor session (always, even short runs) â”€â”€
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 1 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);

          // â”€â”€ Always record last watered time â”€â”€
          id(zone1_last_watered) = now_ts.timestamp;
          id(zone1_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;

          // â”€â”€ Update runtime today (always, even short runs) â”€â”€
          id(zone1_runtime_today) += (int)duration;

          // Only record water for runs > 5 seconds (filters relay test clicks)
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 1 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone1_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 1 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }

            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone1_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 1 done | %.1fL used | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 1 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 1 short run (%llds < 5s) - water not counted", duration);
          }

  - platform: template
    internal: true
    id: ${devicename1}_2
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 2 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_2).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone2_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 2 BLOCKED (direct) - zone disabled");
            id(${devicename1}_2).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone2} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(1, (int)(id(Lawn_irrigation_controller_2_duration).state * 60), false, false, std::string("Manual: ${dev1_zone2}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_2_out
    turn_off_action:
      - output.turn_off: relay_zone_2_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone2_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 2 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone2} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone2 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // Only record water for runs > 5 seconds (filters relay test clicks)
          // â”€â”€ on_turn_off: SOLE water accounting source â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone2_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 2 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone2_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 2 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone2_start_time);
          id(zone2_start_time) = 0;  // Reset for next use
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 2 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);
          id(zone2_last_watered) = now_ts.timestamp;
          id(zone2_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;
          id(zone2_runtime_today) += (int)duration;
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 2 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone2_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 2 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }
            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone2_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 2 done | %.1fL | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 2 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 2 short run (%llds < 5s) - water not counted", duration);
          }

  - platform: template
    internal: true
    id: ${devicename1}_3
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 3 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_3).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone3_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 3 BLOCKED (direct) - zone disabled");
            id(${devicename1}_3).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone3} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(2, (int)(id(Lawn_irrigation_controller_3_duration).state * 60), false, false, std::string("Manual: ${dev1_zone3}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_3_out
    turn_off_action:
      - output.turn_off: relay_zone_3_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone3_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 3 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone3} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone3 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // Only record water for runs > 5 seconds (filters relay test clicks)
          // â”€â”€ on_turn_off: SOLE water accounting source â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone3_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 3 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone3_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 3 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone3_start_time);
          id(zone3_start_time) = 0;  // Reset for next use
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 3 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);
          id(zone3_last_watered) = now_ts.timestamp;
          id(zone3_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;
          id(zone3_runtime_today) += (int)duration;
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 3 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone3_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 3 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }
            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone3_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 3 done | %.1fL | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 3 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 3 short run (%llds < 5s) - water not counted", duration);
          }

  - platform: template
    internal: true
    id: ${devicename1}_4
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 4 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_4).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone4_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 4 BLOCKED (direct) - zone disabled");
            id(${devicename1}_4).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone4} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(3, (int)(id(Lawn_irrigation_controller_4_duration).state * 60), false, false, std::string("Manual: ${dev1_zone4}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_4_out
    turn_off_action:
      - output.turn_off: relay_zone_4_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone4_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 4 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone4} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone4 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // Only record water for runs > 5 seconds (filters relay test clicks)
          // â”€â”€ on_turn_off: SOLE water accounting source â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone4_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 4 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone4_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 4 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone4_start_time);
          id(zone4_start_time) = 0;  // Reset for next use
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 4 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);
          id(zone4_last_watered) = now_ts.timestamp;
          id(zone4_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;
          id(zone4_runtime_today) += (int)duration;
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 4 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone4_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 4 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }
            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone4_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 4 done | %.1fL | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 4 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 4 short run (%llds < 5s) - water not counted", duration);
          }

  - platform: template
    internal: true
    id: ${devicename1}_5
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 5 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_5).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone5_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 5 BLOCKED (direct) - zone disabled");
            id(${devicename1}_5).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone5} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(4, (int)(id(Lawn_irrigation_controller_5_duration).state * 60), false, false, std::string("Manual: ${dev1_zone5}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_5_out
    turn_off_action:
      - output.turn_off: relay_zone_5_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone5_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 5 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone5} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone5 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // Only record water for runs > 5 seconds (filters relay test clicks)
          // â”€â”€ on_turn_off: SOLE water accounting source â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone5_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 5 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone5_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 5 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone5_start_time);
          id(zone5_start_time) = 0;  // Reset for next use
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 5 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);
          id(zone5_last_watered) = now_ts.timestamp;
          id(zone5_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;
          id(zone5_runtime_today) += (int)duration;
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 5 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone5_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 5 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }
            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone5_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 5 done | %.1fL | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 5 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 5 short run (%llds < 5s) - water not counted", duration);
          }

  - platform: template
    internal: true
    id: ${devicename1}_6
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 6 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_6).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone6_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 6 BLOCKED (direct) - zone disabled");
            id(${devicename1}_6).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone6} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(5, (int)(id(Lawn_irrigation_controller_6_duration).state * 60), false, false, std::string("Manual: ${dev1_zone6}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_6_out
    turn_off_action:
      - output.turn_off: relay_zone_6_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone6_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 6 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone6} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone6 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // Only record water for runs > 5 seconds (filters relay test clicks)
          // â”€â”€ on_turn_off: SOLE water accounting source â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone6_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 6 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone6_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 6 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone6_start_time);
          id(zone6_start_time) = 0;  // Reset for next use
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 6 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);
          id(zone6_last_watered) = now_ts.timestamp;
          id(zone6_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;
          id(zone6_runtime_today) += (int)duration;
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 6 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone6_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 6 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }
            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone6_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 6 done | %.1fL | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 6 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 6 short run (%llds < 5s) - water not counted", duration);
          }

  - platform: template
    internal: true
    id: ${devicename1}_7
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 7 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_7).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone7_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 7 BLOCKED (direct) - zone disabled");
            id(${devicename1}_7).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone7} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(6, (int)(id(Lawn_irrigation_controller_7_duration).state * 60), false, false, std::string("Manual: ${dev1_zone7}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_7_out
    turn_off_action:
      - output.turn_off: relay_zone_7_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone7_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 7 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone7} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone7 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // Only record water for runs > 5 seconds (filters relay test clicks)
          // â”€â”€ on_turn_off: SOLE water accounting source â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone7_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 7 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone7_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 7 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone7_start_time);
          id(zone7_start_time) = 0;  // Reset for next use
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 7 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);
          id(zone7_last_watered) = now_ts.timestamp;
          id(zone7_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;
          id(zone7_runtime_today) += (int)duration;
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 7 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone7_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 7 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }
            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone7_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 7 done | %.1fL | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 7 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 7 short run (%llds < 5s) - water not counted", duration);
          }

  - platform: template
    internal: true
    id: ${devicename1}_8
    optimistic: true
    turn_on_action:
      - lambda: |-
          // â”€â”€ SCRIPTED PATH: checks already done, irrigation_busy already set â”€â”€
          if (id(irrigation_busy) || id(test_mode_active)) {
            return;  // relay fired by output.turn_on: action below
          }
          // â”€â”€ DIRECT SWITCH PATH: consolidated safety check via is_safe_to_water â”€â”€
          // is_safe_to_water evaluates: paused, system enable, freeze, budget, rain delay,
          // time restriction, blackout, weather. Per-condition logging happens in request_zone_start.
          if (!id(is_safe_to_water).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 8 BLOCKED (direct) - system not safe to water (see request_zone_start for details)");
            id(${devicename1}_8).turn_off(); return;
          }
          // Zone-specific: zone enable check
          if (!id(zone8_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 8 BLOCKED (direct) - zone disabled");
            id(${devicename1}_8).turn_off(); return;
          }
          // âœ… All checks passed â€” route through request_zone_start for full duration management.
          // We must NOT fire the relay directly here (no duration tracking, no auto-stop).
          // Instead: cancel THIS raw turn_on so the raw output.turn_on action below won't fire,
          // then call request_zone_start which routes through run_zone_with_cycles â†’
          // sprinkler.start_single_valve â†’ turn_on_action (scripted path) â†’ relay fires with duration.
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: ${dev1_zone8} (direct â†’ routed to request_zone_start)");
          // Turn off switch so the if-condition below sees irrigation_busy=false and skips output.turn_on.
          // The relay will be fired by request_zone_start â†’ sprinkler component â†’ scripted path.
          id(request_zone_start).execute(7, (int)(id(Lawn_irrigation_controller_8_duration).state * 60), false, false, std::string("Manual: ${dev1_zone8}"));
          // DON'T set irrigation_busy here â€” request_zone_start will set it once all checks pass.
      - if:
          condition:
            lambda: 'return id(irrigation_busy) || id(test_mode_active);'
          then:
            - output.turn_on: relay_zone_8_out
    turn_off_action:
      - output.turn_off: relay_zone_8_out
    on_turn_on:
      - lambda: |-
          // All safety checks run in turn_on_action before the relay fired.
          // If blocked, turn_on_action called turn_off() and irrigation_busy is still
          // false â€” skip state recording and let on_turn_off clean up the UI.
          if (!id(irrigation_busy) && !id(test_mode_active)) return;
          
          auto _ts = id(homeassistant_time).now();
          id(zone8_start_time) = _ts.is_valid() ? _ts.timestamp : 0;
          id(flow_zone_start_pulses) = id(flow_pulse_total);
          id(flow_sensor_session_litres) = 0.0f;
          id(zone_flow_active) = true;
          ESP_LOGD("flow", "Zone 8 start: pulse snapshot = %.1f", id(flow_zone_start_pulses));
          ESP_LOGI("irrigation", "ğŸš€ ${dev1_zone8} STARTED - Trigger: %s", id(watering_trigger_source).c_str());
          id(dev1_valve_status).publish_state("$dev1_zone8 Active");
    on_turn_off:
      - lambda: |-
          // Only reset to Idle if NOT mid-soak (between cycles in Cycle & Soak mode).
          // During a soak the valve turns off but the system is still running â€” showing
          // "Idle" here is misleading. Let the soak-complete handler set Idle instead.
          if (!id(irrigation_busy) || !id(cycle_soak_is_soaking)) {
            id(dev1_valve_status).publish_state("Idle");
          }
      - lambda: |-
          // Only record water for runs > 5 seconds (filters relay test clicks)
          // â”€â”€ on_turn_off: SOLE water accounting source â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          // Skip if start_time was never set (zone was blocked before starting)
          if (id(zone8_start_time) == 0) {
            ESP_LOGD("irrigation", "Zone 8 turn_off: start_time=0, skipping water accounting");
            return;
          }
          // If HA time not available, skip â€” we cannot compute a valid duration
          auto now_ts = id(homeassistant_time).now();
          if (!now_ts.is_valid()) {
            id(zone8_start_time) = 0;
            ESP_LOGW("irrigation", "Zone 8 turn_off: time unavailable, run not recorded");
            return;
          }
          int64_t duration = now_ts.timestamp - id(zone8_start_time);
          id(zone8_start_time) = 0;  // Reset for next use
          // Compute session litres from total pulse count delta
          // This is exact: (pulses at zone end) - (pulses at zone start) / PPL
          // No timing sensitivity, no partial ticks, no accumulation drift.
          id(zone_flow_active) = false;
          float end_pulses  = id(flow_pulse_total);
          float zone_pulses = (end_pulses >= id(flow_zone_start_pulses))
                           ? (end_pulses - id(flow_zone_start_pulses)) : 0.0f;
          float sensor_litres = zone_pulses / ${flow_sensor_pulses_per_litre}.0f;
          id(flow_sensor_session_litres) = sensor_litres;
          ESP_LOGI("flow", "Zone 8 end: %.0f pulses -> %.3f L (start=%.0f end=%.0f)",
                   zone_pulses, sensor_litres, id(flow_zone_start_pulses), end_pulses);
          // Publish final accurate value to HA immediately
          id(flow_sensor_session_volume).publish_state(sensor_litres);
          id(zone8_last_watered) = now_ts.timestamp;
          id(zone8_last_trigger) = id(watering_trigger_source);
          id(last_watering_timestamp) = now_ts.timestamp;
          id(zone8_runtime_today) += (int)duration;
          if (duration > 5) {
            float water_used;
            if (sensor_litres > 0.1f) {
              water_used = sensor_litres;
              ESP_LOGI("flow", "ğŸ’§ Zone 8 MEASURED  %.2f L | Duration: %llds", water_used, duration);
            } else {
              water_used = (duration / 60.0f) * id(zone8_flow_rate);
              ESP_LOGI("flow", "ğŸ’§ Zone 8 ESTIMATED %.2f L | Duration: %llds (no sensor data)", water_used, duration);
            }
            // Single guard for all water accounting (prevents start_time=0 bug)
            if (water_used > 0.0f && water_used < 10000.0f) {
              id(zone8_water_litres) += water_used;
              id(total_water_litres) += water_used;
              if (isnan(id(current_month_usage)) || std::isinf(id(current_month_usage)) || id(current_month_usage) < 0.0f) {
                ESP_LOGE("irrigation", "âŒ Corrupted current_month_usage (%.1f) - resetting", id(current_month_usage));
                id(current_month_usage) = 0.0f;
                id(nvs_corruption_detected) = true;
              }
              id(current_month_usage) += water_used;
              if (id(current_month_usage) > 1000000.0f) {
                ESP_LOGE("irrigation", "âŒ Monthly usage exceeded limits - resetting");
                id(current_month_usage) = water_used;
                id(nvs_corruption_detected) = true;
              }
              ESP_LOGI("irrigation", "âœ… Zone 8 done | %.1fL | Monthly: %.1f/%.1f L (%.1f%%)",
                       water_used, id(current_month_usage), id(monthly_water_budget),
                       id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0f : 0.0f);
            } else {
              ESP_LOGW("irrigation", "âš ï¸ Zone 8 invalid water_used (%.1f) - skipped", water_used);
            }
          } else {
            ESP_LOGD("irrigation", "Zone 8 short run (%llds < 5s) - water not counted", duration);
          }

# Master Valve (Optional - like Hunter Pro-C)
# Can be enabled/disabled via "Enable Master Valve" switch
# Automatically opens when any zone is active (if enabled)
  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: master_valve_relay
    name: "Master Valve Relay"
    pin: $master_valve_pin
    inverted: true

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # PRODUCTION FEATURES - WATERING WINDOWS & OVERRIDES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "$dev1_what Budget Override"
    id: budget_override_switch
    icon: "mdi:water-pump-off"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - lambda: |-
          id(budget_override_active) = true;
          ESP_LOGW("irrigation", "");
          ESP_LOGW("irrigation", "âš ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("irrigation", "âš ï¸ WATER BUDGET OVERRIDE ACTIVE");
          ESP_LOGW("irrigation", "âš ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("irrigation", "âš ï¸ Watering will continue even if budget exceeded");
          ESP_LOGW("irrigation", "âš ï¸ Current usage: %.1fL / %.1fL (%.1f%%)", 
                   id(current_month_usage), id(monthly_water_budget),
                   id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0 : 0.0);
          ESP_LOGW("irrigation", "âš ï¸ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("irrigation", "");
    on_turn_off:
      - lambda: |-
          id(budget_override_active) = false;
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âœ… Water budget enforcement RE-ENABLED");
          
          // Immediately re-evaluate budget state so user gets instant feedback
          if (id(monthly_water_budget) > 0) {
            float _bo_pct = (id(current_month_usage) / id(monthly_water_budget)) * 100.0f;
            if (_bo_pct >= 100.0f) {
              // Budget is still exceeded â€” re-set the flag and warn
              id(budget_exceeded) = true;
              ESP_LOGW("irrigation", "âš ï¸ WARNING: Budget still %.0f%% used (%.1fL / %.1fL)", _bo_pct,
                       id(current_month_usage), id(monthly_water_budget));
              ESP_LOGW("irrigation", "âš ï¸ Watering will remain BLOCKED until next month or override is re-enabled");
            } else {
              id(budget_exceeded) = false;
              ESP_LOGI("irrigation", "âœ… Budget usage: %.0f%% â€” watering is allowed", _bo_pct);
            }
          }
          ESP_LOGI("irrigation", "");

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ADVANCED FORECAST SYSTEM CONTROLS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  # Enable/Disable Forecast Integration
  - platform: template
    name: "$dev1_what Enable Forecast Integration"
    icon: "mdi:weather-rainy"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - lambda: |-
          id(forecast_enabled) = true;
          ESP_LOGI("forecast", "");
          ESP_LOGI("forecast", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("forecast", "âœ… FORECAST INTEGRATION ENABLED");
          ESP_LOGI("forecast", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("forecast", "âœ… Smart ET will check 1h forecast before watering");
          ESP_LOGI("forecast", "âœ… Predictive Watering will use 1h forecast");
          ESP_LOGI("forecast", "âœ… Auto rain delay for heavy rain within 1h");
          ESP_LOGI("forecast", "âœ… â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("forecast", "");
    turn_off_action:
      - lambda: |-
          id(forecast_enabled) = false;
          ESP_LOGW("forecast", "");
          ESP_LOGW("forecast", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("forecast", "âŒ FORECAST INTEGRATION DISABLED");
          ESP_LOGW("forecast", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("forecast", "âŒ System will use basic rain sensor only");
          ESP_LOGW("forecast", "âŒ No forecast-based decisions");
          ESP_LOGW("forecast", "âŒ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGW("forecast", "");

sprinkler:
  - id: $devicename1
    main_switch:
      name: "$dev1_what Start-Stop-Resume"
      id: dev1_main_switch
      internal: true
      on_turn_off:
        - lambda: |-

            // Don't stop run_zone_with_cycles during cycle/soak mode with multiple cycles
            // Only stop if we're in normal mode or if it's a manual stop
            bool in_cycle_soak = (id(total_cycles) > 0 && id(current_cycle) > 0);
            
            if (!in_cycle_soak) {
              ESP_LOGI("irrigation", "Main switch OFF - stopping run_zone_with_cycles (normal mode)");
              id(run_zone_with_cycles).stop();
              
              // Reset soak countdown when stopping
              id(cycle_soak_is_soaking) = false;
              id(cycle_soak_soak_end_time) = 0;
              id(soak_countdown_seconds) = 0;
            } else {
              ESP_LOGI("irrigation", "Main switch OFF - NOT stopping script (in cycle/soak, cycle %d/%d)",
                       id(current_cycle), id(total_cycles));
            }
            
            if (id(is_paused)) return;

            // Only clear state if not in active cycle/soak
            if (!in_cycle_soak) {
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;

              // In normal mode, main switch off = run finished: clear busy and drain queue.
              // In cycle/soak mode, the stop button manages irrigation_busy explicitly â€”
              // don't touch it here to avoid racing with the stop button's own cleanup.
              if (id(irrigation_busy) && !id(in_program_run)) {
                id(irrigation_busy) = false;
                id(drain_queue).execute();
              }
            } else {
              ESP_LOGI("irrigation", "Main switch OFF (cycle/soak) â€” irrigation_busy managed by stop button");
            }
            
            // Reset valve status to Idle when main switch turns off
            id(dev1_valve_status).publish_state("Idle");

      on_turn_on:
        - lambda: |-
            // CRITICAL: Check if irrigation system is enabled
            if (!id(irrigation_system_enable).state) {
              ESP_LOGW("irrigation", "ğŸš« BLOCKED - Irrigation system is DISABLED");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            // Check rain delay (is_valid guard: avoids false-block when time not synced)
            {
              auto _msw_time = id(homeassistant_time).now();
              if (_msw_time.is_valid() && id(rain_delay_end_time) > _msw_time.timestamp) {
                ESP_LOGW("irrigation", "â›ˆï¸ BLOCKED - Rain delay is active");
                id(dev1_main_switch).turn_off();
                return;
              }
            }
            
            // Weather check (unless override is active)
            if (!id(manual_weather_override)) {
              std::string w = id(weather_forecast_home).state;
              if (!w.empty() && w != "unknown" && w != "unavailable") {
                if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                  ESP_LOGW("irrigation", "â›ˆï¸ BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                  id(dev1_main_switch).turn_off();
                  return;
                }
              }
            }
            
            // Time restriction check
            if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "â° BLOCKED - Time restriction active");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            // Blackout check (incl. NZ public holidays via is_blackout_date sensor)
            if (id(is_blackout_date).state) {
              ESP_LOGW("irrigation", "ğŸš« BLOCKED - Blackout date active");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            ESP_LOGI("irrigation", "âœ… Main switch turned ON - all checks passed");

    auto_advance_switch:
      name: "$dev1_what Auto Advance"
      id: dev1_auto_advance
      restore_mode: ALWAYS_ON

    valve_open_delay: ${default_valve_open_delay_sec}s
    valves:
      - valve_switch: $dev1_zone1
        enable_switch:
          name: Enable $dev1_zone1
          id: zone1_enable
        run_duration_number:
          id: "${devicename1}_1_duration"
          name: "${dev1_zone1} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_1
        
      - valve_switch: $dev1_zone2
        enable_switch:
          name: Enable $dev1_zone2
          id: zone2_enable
        run_duration_number:
          id: "${devicename1}_2_duration"
          name: "${dev1_zone2} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_2
        
      - valve_switch: $dev1_zone3
        enable_switch:
          name: Enable $dev1_zone3
          id: zone3_enable
        run_duration_number:
          id: "${devicename1}_3_duration"
          name: "${dev1_zone3} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_3
        
      - valve_switch: $dev1_zone4
        enable_switch:
          name: Enable $dev1_zone4
          id: zone4_enable
        run_duration_number:
          id: "${devicename1}_4_duration"
          name: "${dev1_zone4} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_4
        
      - valve_switch: $dev1_zone5
        enable_switch:
          name: Enable $dev1_zone5
          id: zone5_enable
        run_duration_number:
          id: "${devicename1}_5_duration"
          name: "${dev1_zone5} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_5
        
      - valve_switch: $dev1_zone6
        enable_switch:
          name: Enable $dev1_zone6
          id: zone6_enable
        run_duration_number:
          id: "${devicename1}_6_duration"
          name: "${dev1_zone6} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_6
        
      - valve_switch: $dev1_zone7
        enable_switch:
          name: Enable $dev1_zone7
          id: zone7_enable
        run_duration_number:
          id: "${devicename1}_7_duration"
          name: "${dev1_zone7} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_7
        
      - valve_switch: $dev1_zone8
        enable_switch:
          name: Enable $dev1_zone8
          id: zone8_enable
        run_duration_number:
          id: "${devicename1}_8_duration"
          name: "${dev1_zone8} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: True  # USER SETTING - must persist across reboots
        valve_switch_id: ${devicename1}_8


button:

  # Restart button
  - platform: restart
    name: "Restart $esphome_comment"
    icon: "mdi:restart"

  # Manual Predictive Watering calculation trigger
  - platform: template
    name: "$dev1_what Recalculate Predictive Watering"
    icon: "mdi:refresh"
    on_press:
      - script.execute: calculate_predictive_watering

  # Smart ET buttons
  - platform: template
    name: "$dev1_what Recalculate Smart ET"
    icon: "mdi:calculator"
    on_press:
      - script.execute: calculate_smart_et

  - platform: template
    name: "$dev1_what Reset ET Deficit"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          id(et_soil_moisture_deficit) = 0;
          id(et_pending_irrigation) = false;
          ESP_LOGI("irrigation", "ğŸŒ± Smart ET: Deficit manually reset to 0mm");

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # RESET DAILY RUNTIME LIMITS BUTTON
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "$dev1_what Reset Daily Runtime Limits"
    icon: "mdi:restart"
    on_press:
      - lambda: |-
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”„ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”„ RESETTING DAILY RUNTIME LIMITS");
          ESP_LOGI("irrigation", "ğŸ”„ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          // Get current day to check if we need to log
          auto now = id(homeassistant_time).now();
          int current_day = now.day_of_year;
          
          ESP_LOGI("irrigation", "ğŸ“Š Runtime before reset:");
          ESP_LOGI("irrigation", "   Zone 1: %d min (limit: %d min)", 
                   id(zone1_runtime_today) / 60, id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "   Zone 2: %d min (limit: %d min)", 
                   id(zone2_runtime_today) / 60, id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "   Zone 3: %d min (limit: %d min)", 
                   id(zone3_runtime_today) / 60, id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "   Zone 4: %d min (limit: %d min)", 
                   id(zone4_runtime_today) / 60, id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "   Zone 5: %d min (limit: %d min)", 
                   id(zone5_runtime_today) / 60, id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "   Zone 6: %d min (limit: %d min)", 
                   id(zone6_runtime_today) / 60, id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "   Zone 7: %d min (limit: %d min)", 
                   id(zone7_runtime_today) / 60, id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "   Zone 8: %d min (limit: %d min)", 
                   id(zone8_runtime_today) / 60, id(max_zone_runtime_daily));
          
          // Reset all zone runtime counters
          id(zone1_runtime_today) = 0;
          id(zone2_runtime_today) = 0;
          id(zone3_runtime_today) = 0;
          id(zone4_runtime_today) = 0;
          id(zone5_runtime_today) = 0;
          id(zone6_runtime_today) = 0;
          id(zone7_runtime_today) = 0;
          id(zone8_runtime_today) = 0;
          
          // Update the last reset day
          id(last_runtime_reset_day) = current_day;
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âœ… ALL ZONES RESET TO 0 MINUTES");
          ESP_LOGI("irrigation", "âœ… Daily runtime limits cleared");
          ESP_LOGI("irrigation", "âœ… Zones can now run up to %d min each", 
                   id(max_zone_runtime_daily));
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”„ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "");

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MASTER VALVE TEST (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "$dev1_what Test Master Valve"
    icon: "mdi:test-tube"
    on_press:
      - lambda: |-
          if (!id(master_valve_enabled)) {
            ESP_LOGW("irrigation", "âš ï¸ Master Valve is DISABLED in settings - enable it first!");
            return;
          }
          // Enter test mode to prevent watchdog interference
          id(test_mode_active) = true;
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ§ª â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ§ª MASTER VALVE TEST");
          ESP_LOGI("irrigation", "ğŸ§ª â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "Opening master valve for ${test_master_valve_sec} seconds...");
          ESP_LOGI("irrigation", "(Watchdog auto-control disabled during test)");
      
      - lambda: "id(master_valve_relay).turn_on();"
      - delay: ${test_master_valve_sec}s
      - lambda: "ESP_LOGI(\"irrigation\", \"âœ… Master Valve OPEN (${test_master_valve_sec}s complete)\");"
      
      - lambda: "id(master_valve_relay).turn_off();"
      - lambda: |-
          // Exit test mode - re-enable watchdog
          id(test_mode_active) = false;
          
          ESP_LOGI("irrigation", "ğŸ”’ Master Valve CLOSED");
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "âœ… Master Valve test complete!");
          ESP_LOGI("irrigation", "   If you heard/saw water flow, master valve is working!");
          ESP_LOGI("irrigation", "");

  - platform: template
    id: start_all_zones_normal
    name: "$dev1_what Start All Zones (Normal)"
    icon: "mdi:play-circle-outline"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸŸ¢ BUTTON PRESSED: Start All Zones (NORMAL)");
        - if:
            condition:
              lambda: |-
                // ğŸš« BLACKOUT CHECK â€” silent, no debug logging
                auto now = id(homeassistant_time).now();
                if (!now.is_valid()) return false;
                
                int today_day = now.day_of_year;
                int today_year = now.year;
                
                for (int slot = 1; slot <= 10; slot++) {
                  int64_t blackout_timestamp = 0;
                  std::string blackout_desc = "";
                  switch(slot) {
                    case 1:  blackout_timestamp = id(blackout_date_1);  blackout_desc = id(blackout_desc_1);  break;
                    case 2:  blackout_timestamp = id(blackout_date_2);  blackout_desc = id(blackout_desc_2);  break;
                    case 3:  blackout_timestamp = id(blackout_date_3);  blackout_desc = id(blackout_desc_3);  break;
                    case 4:  blackout_timestamp = id(blackout_date_4);  blackout_desc = id(blackout_desc_4);  break;
                    case 5:  blackout_timestamp = id(blackout_date_5);  blackout_desc = id(blackout_desc_5);  break;
                    case 6:  blackout_timestamp = id(blackout_date_6);  blackout_desc = id(blackout_desc_6);  break;
                    case 7:  blackout_timestamp = id(blackout_date_7);  blackout_desc = id(blackout_desc_7);  break;
                    case 8:  blackout_timestamp = id(blackout_date_8);  blackout_desc = id(blackout_desc_8);  break;
                    case 9:  blackout_timestamp = id(blackout_date_9);  blackout_desc = id(blackout_desc_9);  break;
                    case 10: blackout_timestamp = id(blackout_date_10); blackout_desc = id(blackout_desc_10); break;
                  }
                  if (blackout_timestamp > 0) {
                    ESPTime blackout_time = ESPTime::from_epoch_local(blackout_timestamp);
                    if (blackout_time.year == today_year && blackout_time.day_of_year == today_day) {
                      std::string desc = blackout_desc.empty() ? "No description" : blackout_desc;
                      ESP_LOGW("irrigation", "ğŸš« BLOCKED: Normal Mode - Blackout date %d active: %s", slot, desc.c_str());
                      return true;
                    }
                  }
                }
                return false;
            then:
              - logger.log:
                  format: "ğŸš« Normal Mode will NOT start - blackout date active"
                  level: ERROR
            else:
              - if:
                  condition:
                    switch.is_off: irrigation_system_enable
                  then:
                    - logger.log:
                        format: "âŒ BLOCKED: Irrigation system is DISABLED"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: |-
                            // Check rain delay (unless manual override is active)
                            if (!id(manual_rain_delay_override)) {
                              return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;
                            }
                            return false;  // Override active, don't block
                        then:
                          - logger.log:
                              format: "â›ˆï¸ BLOCKED: Rain delay is active (Disable Auto Rain Delay to override)"
                              level: WARN
                        else:
                          - if:
                              condition:
                                lambda: |-
                                  // Time restriction check
                                  return id(is_time_restricted);
                              then:
                                - logger.log:
                                    format: "â° BLOCKED: Time restriction active (outside allowed hours)"
                                    level: WARN
                              else:
                                - if:
                                    condition:
                                      lambda: |-
                                        // Weather check (unless override is active)
                                        if (!id(manual_weather_override)) {
                                          std::string w = id(weather_forecast_home).state;
                                          if (!w.empty() && w != "unknown" && w != "unavailable") {
                                            if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                                              return true;  // Bad weather - block
                                            }
                                          }
                                        }
                                        return false;  // Weather OK or override active
                                    then:
                                      - logger.log:
                                          format: "â›ˆï¸ BLOCKED: Bad weather (Enable Weather Override to force)"
                                          level: WARN
                                    else:
                                      - lambda: |-
                                          std::string w = id(weather_forecast_home).state;
                                          if (id(manual_weather_override)) {
                                            ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                                          } else {
                                            ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                                          }
                                          
                                          // Check if system is busy
                                          bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
                                          
                                          if (busy) {
                                            // System is busy - queue the request
                                            if (id(queue_count) < 3) {
                                              int pos = id(queue_count);
                                              id(queue_types)[pos] = 3;  // 3 = Normal mode
                                              id(queue_programs)[pos] = 0;
                                              id(queue_zones)[pos] = 0;
                                              id(queue_durations)[pos] = 0;
                                              id(queue_add_delays)[pos] = false;
                                              id(queue_trigger_sources)[pos] = "Manual: All Zones (Normal)";
                                              id(queue_count)++;
                                              
                                              ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Normal Mode â†’ Slot %d/3 | Queue now: %d items",
                                                       pos + 1, id(queue_count));
                                            } else {
                                              ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Normal Mode will NOT run!");
                                            }
                                          } else {
                                            // System is idle - start immediately
                                            id(watering_trigger_source) = "Manual: All Zones (Normal)";
                                            ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: All Zones (Normal)");
                                            // BUG #30 FIX: Set irrigation_busy before pending_normal_start
                                            id(irrigation_busy) = true;
                                            id(pending_normal_start) = true;
                                            id(normal_start_attempts) = 0;
                                            id(normal_last_attempt_ms) = 0;
                                            ESP_LOGI("irrigation", "â–¶ï¸ STARTING Normal Mode immediately (system idle)");
                                          }

# Manual program run buttons
  - platform: template
    name: "Run ${program_a_name} Now"
    icon: "mdi:alpha-a-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run ${program_a_name}");
        
        - if:
            condition:
              lambda: |-
                // ğŸš« BLACKOUT CHECK (incl. NZ public holidays via is_blackout_date sensor)
                return id(is_blackout_date).state;
            then:
              - logger.log:
                  format: "ğŸš« ${program_a_name} will NOT run - blackout date active"
                  level: ERROR
            else:
              - if:
                  condition:
                    switch.is_off: irrigation_system_enable
                  then:
                    - logger.log:
                        format: "âŒ BLOCKED: Irrigation system is DISABLED"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: 'return id(homeassistant_time).now().is_valid() && id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                        then:
                          - logger.log: "Rain delay active"
                        else:
                          - script.execute:
                              id: request_program_start
                              program: 1
                              allow_queue: true
                              trigger_source: "Manual: ${program_a_name}"
                        
  - platform: template
    name: "Run ${program_b_name} Now"
    icon: "mdi:alpha-b-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run ${program_b_name}");
        
        - if:
            condition:
              lambda: |-
                // ğŸš« BLACKOUT CHECK (incl. NZ public holidays via is_blackout_date sensor)
                return id(is_blackout_date).state;
            then:
              - logger.log:
                  format: "ğŸš« ${program_b_name} will NOT run - blackout date active"
                  level: ERROR
            else:
              - if:
                  condition:
                    switch.is_off: irrigation_system_enable
                  then:
                    - logger.log:
                        format: "âŒ BLOCKED: Irrigation system is DISABLED"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: 'return id(homeassistant_time).now().is_valid() && id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                        then:
                          - logger.log: "Rain delay active"
                        else:
                          - script.execute:
                              id: request_program_start
                              program: 2
                              allow_queue: true
                              trigger_source: "Manual: ${program_b_name}"

  - platform: template
    name: "Run ${program_c_name} Now"
    icon: "mdi:alpha-c-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run ${program_c_name}");
        
        - if:
            condition:
              lambda: |-
                // ğŸš« BLACKOUT CHECK (incl. NZ public holidays via is_blackout_date sensor)
                return id(is_blackout_date).state;
            then:
              - logger.log:
                  format: "ğŸš« ${program_c_name} will NOT run - blackout date active"
                  level: ERROR
            else:
              - if:
                  condition:
                    switch.is_off: irrigation_system_enable
                  then:
                    - logger.log:
                        format: "âŒ BLOCKED: Irrigation system is DISABLED"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: 'return id(homeassistant_time).now().is_valid() && id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                        then:
                          - logger.log: "Rain delay active"
                        else:
                          - script.execute:
                              id: request_program_start
                              program: 3
                              allow_queue: true
                              trigger_source: "Manual: ${program_c_name}"

# Pause button - Actually stops the valve
  - platform: template
    id: dev1_sprinkler_pause
    name: "$dev1_what Pause"
    icon: "mdi:pause"
    on_press:
      then:
        - lambda: |-
            // Save current state if a valve is active
            if (id($devicename1).active_valve().has_value()) {
              id(paused_zone) = id($devicename1).active_valve().value();
              id(paused_cycle) = id(current_cycle);
              id(time_remaining_when_paused) = id($devicename1).time_remaining_active_valve().value_or(0);
              id(is_paused) = true;

              // Snapshot cycle/soak state for resume
              id(paused_total_cycles) = id(total_cycles);
              id(paused_cycle_soak_total_duration) = id(cycle_soak_total_duration);
              id(paused_cycle_soak_elapsed_time) = id(cycle_soak_elapsed_time);
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              
              ESP_LOGI("irrigation", "Paused: Zone %d, Cycle %d/%d, Time remaining: %d sec, Elapsed: %d/%d sec",
                       id(paused_zone), id(paused_cycle), id(total_cycles),
                       id(time_remaining_when_paused),
                       id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
              
              ESP_LOGI("irrigation", "Progress tracking paused â€” elapsed time frozen at %d seconds",
                       id(cycle_soak_elapsed_time));
              
            } else if (id(cycle_soak_is_soaking) && id(active_zone_number) >= 0 && id(total_cycles) > 0) {
              id(paused_zone) = id(active_zone_number);
              id(paused_cycle) = id(current_cycle);
              int64_t now = id(homeassistant_time).now().timestamp;
              int64_t rem = id(cycle_soak_soak_end_time) - now;
              if (rem < 0) rem = 0;
              id(paused_soak_remaining_seconds) = (int) rem;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = true;
              id(is_paused) = true;
              id(paused_total_cycles) = id(total_cycles);
              id(paused_cycle_soak_total_duration) = id(cycle_soak_total_duration);
              id(paused_cycle_soak_elapsed_time) = id(cycle_soak_elapsed_time);
              
              ESP_LOGI("irrigation", "Paused during soak: Zone %d, Cycle %d/%d, Soak remaining: %d sec, Elapsed: %d/%d sec",
                       id(paused_zone), id(paused_cycle), id(paused_total_cycles),
                       id(paused_soak_remaining_seconds),
                       id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
              
              ESP_LOGI("irrigation", "Progress tracking paused during soak â€” elapsed time frozen at %d seconds",
                       id(cycle_soak_elapsed_time));
            } else {
              // Nothing active to pause â€” but irrigation_busy may still be true
              // (e.g. zone was started and pause pressed during the 1-second valve open delay,
              // before active_valve() was populated). Clear state so system is not stuck.
              ESP_LOGI("irrigation", "Nothing active to pause â€” checking for stale busy state");
              if (id(irrigation_busy)) {
                ESP_LOGW("irrigation", "âš ï¸ Pause-on-nothing: clearing stale irrigation_busy flag (quick-start race)");
                id(irrigation_busy) = false;
                id(in_program_run) = false;
                id(active_zone_number) = -1;
                id(current_cycle) = 0;
                id(total_cycles) = 0;
                id(cycle_soak_is_soaking) = false;
                id(cycle_soak_soak_end_time) = 0;
                id(watering_trigger_source) = "Idle";
              }
            }
        - sprinkler.shutdown: $devicename1
        - script.stop: run_zone_with_cycles
        - script.stop: run_all_zones_cycle_soak_script
        - script.stop: run_program
        - script.stop: run_all_zones_normal_script
        - script.stop: continue_cycle_soak_after_resume
        - text_sensor.template.publish:
            id: dev1_valve_status
            state: "Paused"

# Resume button - Restarts from saved position
  - platform: template
    id: dev1_sprinkler_resume
    name: "$dev1_what Resume"
    icon: "mdi:play"
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(is_paused) && id(paused_zone) >= 0;'
            then:
              - lambda: |-
                  // Restore cycle/soak snapshot BEFORE mode checks
                  id(total_cycles) = id(paused_total_cycles);
                  id(cycle_soak_total_duration) = id(paused_cycle_soak_total_duration);
                  id(cycle_soak_elapsed_time) = id(paused_cycle_soak_elapsed_time);

                  ESP_LOGI("irrigation", "Resuming: Zone %d, Cycle %d/%d, Elapsed restored to: %d/%d sec",
                           id(paused_zone), id(paused_cycle), id(total_cycles),
                           id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
                  
                  ESP_LOGI("irrigation", "Progress tracking will resume from %d seconds",
                           id(cycle_soak_elapsed_time));

                  id(is_paused) = false;
                  id(active_zone_number) = id(paused_zone);
                  id(current_cycle) = id(paused_cycle);

              # Critical safety check before re-activating relay
              # (Freeze / budget / system may have changed while paused)
              - lambda: |-
                  if (!id(irrigation_system_enable).state) {
                    ESP_LOGW("irrigation", "ğŸš« RESUME BLOCKED â€” irrigation system is disabled");
                    id(is_paused) = false;
                    id(irrigation_busy) = false;
                    id(in_program_run) = false;
                    id(active_zone_number) = -1;
                    id(watering_trigger_source) = "Idle";
                    // Clear paused state so downstream if-blocks cannot fire the valve
                    id(paused_zone) = -1;
                    id(time_remaining_when_paused) = 0;
                    id(paused_was_soaking) = false;
                    id(drain_queue).execute();
                    id(dev1_valve_status).publish_state("Idle");
                    return;
                  }
                  if (id(freeze_protection_active)) {
                    ESP_LOGW("irrigation", "â„ï¸ RESUME BLOCKED â€” freeze protection active (%.1fÂ°C)", id(outside_temperature).state);
                    id(is_paused) = false;
                    id(irrigation_busy) = false;
                    id(in_program_run) = false;
                    id(active_zone_number) = -1;
                    id(watering_trigger_source) = "Idle";
                    // Clear paused state so downstream if-blocks cannot fire the valve
                    id(paused_zone) = -1;
                    id(time_remaining_when_paused) = 0;
                    id(paused_was_soaking) = false;
                    id(drain_queue).execute();
                    id(dev1_valve_status).publish_state("Idle");
                    return;
                  }
                  if (id(budget_exceeded) && !id(budget_override_active)) {
                    ESP_LOGW("irrigation", "ğŸš« RESUME BLOCKED â€” monthly budget exceeded (%.0fL/%.0fL)", id(current_month_usage), id(monthly_water_budget));
                    id(is_paused) = false;
                    id(irrigation_busy) = false;
                    id(in_program_run) = false;
                    id(active_zone_number) = -1;
                    id(watering_trigger_source) = "Idle";
                    // Clear paused state so downstream if-blocks cannot fire the valve
                    id(paused_zone) = -1;
                    id(time_remaining_when_paused) = 0;
                    id(paused_was_soaking) = false;
                    id(drain_queue).execute();
                    id(dev1_valve_status).publish_state("Idle");
                    return;
                  }
                  // RAIN DELAY CHECK
                  {
                    auto _res_time = id(homeassistant_time).now();
                    if (_res_time.is_valid() && id(rain_delay_end_time) > _res_time.timestamp) {
                      int64_t _rd = (id(rain_delay_end_time) - _res_time.timestamp) / ${seconds_per_day};
                      ESP_LOGW("irrigation", "ğŸŒ§ï¸ RESUME BLOCKED â€” rain delay active (%lld day(s) remaining)", _rd);
                      id(is_paused) = false;
                      id(irrigation_busy) = false;
                      id(in_program_run) = false;
                      id(active_zone_number) = -1;
                      id(watering_trigger_source) = "Idle";
                        // Clear paused state so downstream if-blocks cannot fire the valve
                      id(paused_zone) = -1;
                      id(time_remaining_when_paused) = 0;
                      id(paused_was_soaking) = false;
                      id(drain_queue).execute();
                      id(dev1_valve_status).publish_state("Idle");
                      return;
                    }
                    // BLACKOUT DATE CHECK (incl. NZ public holidays via is_blackout_date sensor)
                    if (id(is_blackout_date).state) {
                      ESP_LOGW("irrigation", "ğŸš« RESUME BLOCKED â€” blackout date active");
                      id(is_paused) = false;
                      id(irrigation_busy) = false;
                      id(in_program_run) = false;
                      id(active_zone_number) = -1;
                      id(watering_trigger_source) = "Idle";
                      // Clear paused state so downstream if-blocks cannot fire the valve
                      id(paused_zone) = -1;
                      id(time_remaining_when_paused) = 0;
                      id(paused_was_soaking) = false;
                      id(drain_queue).execute();
                      id(dev1_valve_status).publish_state("Idle");
                      return;
                    }
                  }
                  // WEATHER CHECK
                  if (!id(manual_weather_override)) {
                    std::string _rw = id(weather_forecast_home).state;
                    if (!_rw.empty() && _rw != "unknown" && _rw != "unavailable") {
                      if (_rw == "rainy" || _rw == "pouring" || _rw == "snowy" || _rw == "snowy-rainy") {
                        ESP_LOGW("irrigation", "â›ˆï¸ RESUME BLOCKED â€” bad weather: %s (enable Weather Override to force)", _rw.c_str());
                        id(is_paused) = false;
                        id(irrigation_busy) = false;
                        id(in_program_run) = false;
                        id(active_zone_number) = -1;
                        id(watering_trigger_source) = "Idle";
                            // Clear paused state so downstream if-blocks cannot fire the valve
                        id(paused_zone) = -1;
                        id(time_remaining_when_paused) = 0;
                        id(paused_was_soaking) = false;
                        id(drain_queue).execute();
                        id(dev1_valve_status).publish_state("Idle");
                        return;
                      }
                    }
                  }
                  ESP_LOGI("irrigation", "âœ… Resume safety check passed â€” restarting valve");

              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # RESUME ROUTING â€” WATCHDOG RACE FIX (both normal and cycle/soak)
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # ROOT CAUSE: any delay between is_paused=false and a script
              # starting creates a window where the watchdog sees:
              #   irrigation_busy=true + no script running + no valve active
              # â†’ "Run finished cleanly" â†’ irrigation_busy=false
              # â†’ valve opens with busy=false â†’ direct-switch path fires
              # â†’ run_zone_with_cycles with FULL zone duration (zombie run)
              # â†’ irrigation_busy=true for full duration â†’ every button queues
              # â†’ queue fills â†’ system locked until zone completes.
              #
              # FIX: No delays before script.execute. Both modes route through
              # a script immediately. script.execute is synchronous â€” is_running()
              # is true before the next ESPHome event-loop tick, so the watchdog
              # never sees a window without an active script.
              #
              # NORMAL MODE: run_zone_with_cycles with force_normal=true.
              # CYCLE & SOAK: continue_cycle_soak_after_resume fires the valve
              #   internally (moved from here) so no gap between resume button
              #   and script.is_running()=true.
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              - if:
                  condition:
                    lambda: 'return id(total_cycles) > 0;'
                  then:
                    # â”€â”€ CYCLE & SOAK RESUME â”€â”€
                    # Mark busy here (before any yield). The script will keep it
                    # true via is_running() check in the watchdog.
                    - lambda: 'id(irrigation_busy) = true; id(cycle_soak_switch).turn_on();'
                    - switch.turn_off: dev1_auto_advance
                    - logger.log: "Auto Advance forced OFF (Cycle & Soak mode)"
                    # Execute IMMEDIATELY â€” no delay. Script starts synchronously so
                    # watchdog sees continue_cycle_soak_after_resume.is_running()=true
                    # before any potential preemption. The valve is fired from INSIDE
                    # the script (water_remaining param), not here, so there is no gap.
                    - script.execute:
                        id: continue_cycle_soak_after_resume
                        zone: !lambda 'return id(paused_zone);'
                        start_cycle: !lambda 'return id(current_cycle);'
                        total: !lambda 'return id(total_cycles);'
                        was_soaking: !lambda 'return id(paused_was_soaking);'
                        soak_remaining: !lambda 'return id(paused_soak_remaining_seconds);'
                        water_remaining: !lambda 'return id(time_remaining_when_paused);'
                  else:
                    # â”€â”€ NORMAL MODE RESUME â”€â”€
                    # Route through run_zone_with_cycles so watchdog sees script_running=true.
                    # Do NOT set irrigation_busy here â€” run_zone_with_cycles sets it in its
                    # own pre-flight lambda (before its first yield), so the watchdog can
                    # never see a gap between is_paused=false and a script running.
                    # NOTE: time_remaining_when_paused already has the multiplier baked in.
                    # run_zone_with_cycles re-applies multiplier, so divide it out first.
                    - switch.turn_on: dev1_auto_advance
                    - logger.log: "Auto Advance ON (Normal mode) â€” routing through run_zone_with_cycles"
                    - lambda: |-
                        int saved_zone = id(paused_zone);
                        int saved_remaining = id(time_remaining_when_paused);
                        // Clear pause globals â€” run_zone_with_cycles manages its own state
                        id(paused_zone) = -1;
                        id(paused_cycle) = 0;
                        id(time_remaining_when_paused) = 0;
                        id(paused_was_soaking) = false;
                        id(paused_soak_remaining_seconds) = 0;
                        id(paused_total_cycles) = 0;
                        id(paused_cycle_soak_total_duration) = 0;
                        id(paused_cycle_soak_elapsed_time) = 0;
                        // Divide out multiplier so run_zone_with_cycles produces saved_remaining
                        float m = id($devicename1).multiplier();
                        int base_duration = (m > 0.01f) ? (int)((float)saved_remaining / m) : saved_remaining;
                        ESP_LOGI("irrigation", "Normal resume: zone=%d remaining=%ds base_duration=%ds (mult=%.2f)",
                                 saved_zone, saved_remaining, base_duration, m);
                        id(resume_zone_param) = saved_zone;
                        id(resume_duration_param) = base_duration;
                    - script.execute:
                        id: run_zone_with_cycles
                        zone: !lambda 'return id(resume_zone_param);'
                        duration: !lambda 'return id(resume_duration_param);'
                        add_delay: false
                        force_normal: true

              - text_sensor.template.publish:
                  id: dev1_valve_status
                  state: "Resumed"

              # Pause globals for cycle/soak are cleared by continue_cycle_soak_after_resume on completion.
              # Normal mode pause globals already cleared in lambda above.


            else:
              - logger.log: "Nothing to resume - not paused or no saved state"

  - platform: template
    id: dev1_sprinkler_stop
    name: "$dev1_what Stop"
    icon: "mdi:stop"
    on_press:
      then:
        - logger.log: "â•â•â• STOP BUTTON PRESSED â•â•â•"

        # Cancel pending normal-mode retry worker (but preserve queued programs/zones)
        - lambda: |-
            id(pending_normal_start) = false;
            id(normal_start_attempts) = 0;
            id(normal_last_attempt_ms) = 0;

            // Clear ONLY queued NORMAL start (type 3). Preserve Program (1) and Zone (2).
            if (id(queued_type) == 3) {
              ESP_LOGI("irrigation", "Clearing queued NORMAL request (type 3) on STOP");
              id(queued_type) = 0;
            }

            ESP_LOGI(
              "irrigation",
              "â¹ STOPPING: Zone=%d, Cycle=%d/%d, queued_type=%d",
              id(active_zone_number),
              id(current_cycle),
              id(total_cycles),
              id(queued_type)
            );

            // Keep busy flag SET during shutdown/cleanup
            id(irrigation_busy) = true;

        # Stop sprinkler controller (shutdown respects internal stop delays)
        - sprinkler.shutdown: $devicename1

        # Stop ALL helper scripts â€” including continue_cycle_soak_after_resume which
        # runs after resume and would restart irrigation if not stopped here.
        - script.stop: run_zone_with_cycles
        - script.stop: run_all_zones_cycle_soak_script
        - script.stop: run_program
        - script.stop: run_all_zones_normal_script
        - script.stop: continue_cycle_soak_after_resume
        - script.stop: wait_until_idle_then_drain

        # Clear ALL run-state variables including soak/pause state
        - lambda: |-
            ESP_LOGI("irrigation", "ğŸ§¹ Clearing run state variables");
            id(active_zone_number) = -1;
            id(current_cycle) = 0;
            id(total_cycles) = 0;
            id(cycle_soak_total_duration) = 0;
            id(cycle_soak_elapsed_time) = 0;
            id(cycle_soak_is_soaking) = false;
            id(cycle_soak_soak_end_time) = 0;
            id(soak_countdown_seconds) = 0;
            id(is_paused) = false;
            id(paused_zone) = -1;
            id(paused_cycle) = 0;
            id(time_remaining_when_paused) = 0;
            id(paused_was_soaking) = false;
            id(paused_soak_remaining_seconds) = 0;
            id(paused_total_cycles) = 0;
            id(paused_cycle_soak_total_duration) = 0;
            id(paused_cycle_soak_elapsed_time) = 0;
            id(in_program_run) = false;
            id(resume_csa_blocked) = false;

        # Turn OFF Cycle & Soak when stopping
        - switch.turn_off: cycle_soak_switch
        - logger.log: "ğŸ”„ Cycle & Soak Mode: OFF (stopped)"
        # BUG #35 FIX: Always restore Auto Advance after a stop.
        # C&S turns it OFF at start; if stopped mid-run it stays OFF, breaking
        # all future normal-mode runs (they need auto-advance to step through zones).
        - switch.turn_on: dev1_auto_advance
        - logger.log: "Auto Advance restored to ON (stop cleanup)"

        - text_sensor.template.publish:
            id: dev1_valve_status
            state: "Stopped"

        # Mark idle. continue_cycle_soak_after_resume was explicitly stopped above,
        # so the only things that could still be active are: a new run started during
        # the tiny window between sprinkler.shutdown and script.stop calls, or
        # pending_normal_start. Check all to be safe.
        - lambda: |-
            // cycle_soak_is_soaking and continue_cycle_soak_after_resume are now explicitly
            // stopped and cleared, so they can't be true here unless a new run started.
            bool new_run_active = id($devicename1).active_valve().has_value() ||
                                  id(pending_normal_start) ||
                                  id(run_zone_with_cycles).is_running() ||
                                  id(run_all_zones_cycle_soak_script).is_running() ||
                                  id(run_program).is_running() ||
                                  id(run_all_zones_normal_script).is_running() ||
                                  id(continue_cycle_soak_after_resume).is_running();
            if (new_run_active) {
              ESP_LOGI("irrigation", "âœ“ Stop cleanup: new run started â€” preserving state");
            } else {
              ESP_LOGI("irrigation", "âœ“ Stop cleanup complete (idle)");
              id(irrigation_busy) = false;
              id(watering_trigger_source) = "Idle";
            }

        # If a Program (type 1), Zone (type 2), or Cycle & Soak (type 4) is queued,
        # run it now â€” but only if no run is already active (drain_queue checks this).
        - if:
            condition:
              lambda: |-
                return id(queue_count) > 0 &&
                       !id($devicename1).active_valve().has_value() &&
                       !id(pending_normal_start) &&
                       !id(run_zone_with_cycles).is_running() &&
                       !id(run_all_zones_cycle_soak_script).is_running() &&
                       !id(run_program).is_running() &&
                       !id(continue_cycle_soak_after_resume).is_running() &&
                       !id(cycle_soak_is_soaking);
            then:
              - logger.log: "â–¶ Starting queued request after STOP"
              - script.execute: drain_queue

# Start All Zones - CYCLE & SOAK MODE
  - platform: template
    id: start_all_zones_cycle_soak
    name: "$dev1_what Start All Zones (Cycle & Soak)"
    icon: "mdi:water-sync"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Start All Zones (CYCLE & SOAK)");
        
        - if:
            condition:
              lambda: |-
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // ğŸš« BLACKOUT CHECK - Direct check of all 10 slots
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                auto now = id(homeassistant_time).now();
                // Blackout check (incl. NZ public holidays via is_blackout_date sensor)
                if (id(is_blackout_date).state) {
                  ESP_LOGW("irrigation", "\U0001F6AB BLOCKED: Cycle & Soak Mode - Blackout date active");
                  return true;
                }
                return false;
            then:
              - logger.log:
                  format: "ğŸš« Cycle & Soak Mode will NOT start - blackout date active"
                  level: ERROR
            else:
              - if:
                  condition:
                    switch.is_off: irrigation_system_enable
                  then:
                    - logger.log:
                        format: "âŒ BLOCKED: Irrigation system is DISABLED"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: 'return id(homeassistant_time).now().is_valid() && id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                        then:
                          - logger.log:
                              format: "â›ˆï¸ BLOCKED: Rain delay is active"
                              level: WARN
                        else:
                          - if:
                              condition:
                                lambda: |-
                                  // Time restriction check
                                  return id(is_time_restricted);
                              then:
                                - logger.log:
                                    format: "â° BLOCKED: Time restriction active (outside allowed hours)"
                                    level: WARN
                              else:
                                - if:
                                    condition:
                                      lambda: |-
                                        // Weather check (unless override is active)
                                        if (!id(manual_weather_override)) {
                                          std::string w = id(weather_forecast_home).state;
                                          if (!w.empty() && w != "unknown" && w != "unavailable") {
                                            if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                                              return true;  // Bad weather - block
                                            }
                                          }
                                        }
                                        return false;  // Weather OK or override active
                                    then:
                                      - logger.log:
                                          format: "â›ˆï¸ BLOCKED: Bad weather (Enable Weather Override to force)"
                                          level: WARN
                                    else:
                                      - lambda: |-
                                          std::string w = id(weather_forecast_home).state;
                                          if (id(manual_weather_override)) {
                                            ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                                          } else {
                                            ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                                          }
                                          
                                          // Check if system is busy
                                          bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
                                          
                                          if (busy) {
                                            // System is busy - queue the request
                                            if (id(queue_count) < 3) {
                                              int pos = id(queue_count);
                                              id(queue_types)[pos] = 4;  // 4 = Cycle & Soak mode
                                              id(queue_programs)[pos] = 0;
                                              id(queue_zones)[pos] = 0;
                                              id(queue_durations)[pos] = 0;
                                              id(queue_add_delays)[pos] = false;
                                              // Store trigger (preserve if Smart ET)
                                              if (id(watering_trigger_source).find("Smart ET") != std::string::npos) {
                                                id(queue_trigger_sources)[pos] = id(watering_trigger_source);
                                              } else {
                                                id(queue_trigger_sources)[pos] = "Manual: Cycle & Soak All Zones";
                                              }
                                              id(queue_count)++;
                                              
                                              ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Cycle & Soak â†’ Slot %d/3 | Queue now: %d items",
                                                       pos + 1, id(queue_count));
                                            } else {
                                              ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Cycle & Soak will NOT run!");
                                            }
                                          } else {
                                            // System is idle - start immediately
                                            // Set trigger only if not called by Smart ET
                                            if (id(watering_trigger_source).find("Smart ET") != std::string::npos) {
                                              ESP_LOGI("irrigation", "ğŸ“ TRIGGER PRESERVED: %s (called by Smart ET)", id(watering_trigger_source).c_str());
                                            } else {
                                              id(watering_trigger_source) = "Manual: Cycle & Soak All Zones";
                                              ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Manual: Cycle & Soak All Zones");
                                            }
                                            ESP_LOGI("irrigation", "â–¶ï¸ STARTING Cycle & Soak immediately (system idle)");
                                            // Turn ON cycle and soak mode
                                            id(cycle_soak_switch).turn_on();
                                            id(run_all_zones_cycle_soak_script).execute();
                                          }

  - platform: template
    name: "$dev1_zone1 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 0
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone1}"

  - platform: template
    name: "$dev1_zone2 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 1
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone2}"
  - platform: template
    name: "$dev1_zone3 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 2
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone3}"
  - platform: template
    name: "$dev1_zone4 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 3
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone4}"
  - platform: template
    name: "$dev1_zone5 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 4
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone5}"
  - platform: template
    name: "$dev1_zone6 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 5
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone6}"
  - platform: template
    name: "$dev1_zone7 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 6
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone7}"
  - platform: template
    name: "$dev1_zone8 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 7
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
            trigger_source: "Manual: ${dev1_zone8}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WATER USAGE RESET BUTTONS (Hunter Pro-C Style)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - platform: template
    name: "$dev1_what Reset All Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ’§ RESETTING ALL WATER USAGE COUNTERS");
          ESP_LOGI("irrigation", "ğŸ’§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "Previous Total: %.1f L", id(total_water_litres));
          ESP_LOGI("irrigation", "Previous Monthly: %.1f L", id(current_month_usage));
          
          // Reset all zone counters
          id(zone1_water_litres) = 0;
          id(zone2_water_litres) = 0;
          id(zone3_water_litres) = 0;
          id(zone4_water_litres) = 0;
          id(zone5_water_litres) = 0;
          id(zone6_water_litres) = 0;
          id(zone7_water_litres) = 0;
          id(zone8_water_litres) = 0;
          
          // Reset total
          id(total_water_litres) = 0;
          
          // Reset monthly usage counter
          id(current_month_usage) = 0;
          
          // Set reset timestamp
          id(water_reset_timestamp) = id(homeassistant_time).now().timestamp;
          
          ESP_LOGI("irrigation", "âœ… All water usage counters reset to 0 L");
          ESP_LOGI("irrigation", "âœ… Monthly usage counter reset to 0 L");
          ESP_LOGI("irrigation", "ğŸ“Š Water Budget: 0.0L / %.1fL (0.0%%)", id(monthly_water_budget));
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ’¾ Saving to flash memory... (please wait 3 seconds)");
      
      # Give time for flash write to complete
      - delay: 3s
      
      - lambda: |-
          ESP_LOGI("irrigation", "âœ… Reset complete - safe to reboot now");
          ESP_LOGI("irrigation", "");

  - platform: template
    name: "$dev1_zone1 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone1_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone1_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 1 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));

  - platform: template
    name: "$dev1_zone2 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone2_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone2_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 2 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));

  - platform: template
    name: "$dev1_zone3 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone3_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone3_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 3 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));

  - platform: template
    name: "$dev1_zone4 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone4_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone4_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 4 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));

  - platform: template
    name: "$dev1_zone5 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone5_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone5_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 5 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));

  - platform: template
    name: "$dev1_zone6 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone6_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone6_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 6 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));

  - platform: template
    name: "$dev1_zone7 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone7_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone7_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 7 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));

  - platform: template
    name: "$dev1_zone8 Reset Water Usage"
    icon: "mdi:water-off"
    on_press:
      - lambda: |-
          float previous = id(zone8_water_litres);
          id(total_water_litres) -= previous;
          id(current_month_usage) = std::max(0.0f, id(current_month_usage) - previous);
          id(zone8_water_litres) = 0;
          ESP_LOGI("irrigation", "ğŸ’§ Zone 8 water usage reset (was %.1f L) - Total: %.1f L, Monthly: %.1f L", previous, id(total_water_litres), id(current_month_usage));
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYSTEM DIAGNOSTICS (Production Feature)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  - platform: template
    name: "$dev1_what Run System Diagnostics"
    icon: "mdi:doctor"
    on_press:
      - lambda: |-
          // Set trigger for tracking
          id(watering_trigger_source) = "Diagnostics";
          
          // Enter test mode to prevent watchdog interference
          id(test_mode_active) = true;
          
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ SYSTEM DIAGNOSTICS STARTED");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ“ TRIGGER: Diagnostics");
          ESP_LOGI("irrigation", "ğŸ”“ ALL RESTRICTIONS BYPASSED:");
          ESP_LOGI("irrigation", "   - Watchdog auto-control: DISABLED");
          ESP_LOGI("irrigation", "   - Weather checks: BYPASSED");
          ESP_LOGI("irrigation", "   - Rain delay: BYPASSED");
          ESP_LOGI("irrigation", "   - Freeze protection: BYPASSED");
          ESP_LOGI("irrigation", "   - Water budget: BYPASSED");
          ESP_LOGI("irrigation", "   - Runtime limits: BYPASSED");
          ESP_LOGI("irrigation", "   - Watering windows: BYPASSED");
          ESP_LOGI("irrigation", "   - System enable: BYPASSED");
          ESP_LOGI("irrigation", "ğŸ”“ Diagnostics run UNRESTRICTED for hardware testing");
          ESP_LOGI("irrigation", "");
          
          // Update status to show diagnostics running
          id(dev1_valve_status).publish_state("Running Diagnostics");
          
          int tests_passed = 0;
          int tests_failed = 0;
          int warnings = 0;
          
          // TEST 1: Time Synchronization
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 1: Time Synchronization");
          auto now = id(homeassistant_time).now();
          if (now.is_valid()) {
            ESP_LOGI("irrigation", "   âœ… PASS - Time synced: %d/%d/%d %d:%02d", 
                     now.day_of_month, now.month, now.year, now.hour, now.minute);
            tests_passed++;
          } else {
            ESP_LOGE("irrigation", "   âŒ FAIL - Time not synchronized");
            tests_failed++;
          }
          
          // TEST 2: Weather Sensors
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 2: Weather Sensors");
          float temp = id(outside_temperature).state;
          float humidity = id(outside_humidity).state;
          float wind = id(wind_speed).state;
          
          int sensor_failures = 0;
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "   âš ï¸ Temperature sensor unavailable");
            sensor_failures++;
          } else {
            ESP_LOGI("irrigation", "   âœ… Temperature: %.1fÂ°C", temp);
          }
          
          if (isnan(humidity)) {
            ESP_LOGW("irrigation", "   âš ï¸ Humidity sensor unavailable");
            sensor_failures++;
          } else {
            ESP_LOGI("irrigation", "   âœ… Humidity: %.1f%%", humidity);
          }
          
          if (isnan(wind)) {
            ESP_LOGW("irrigation", "   âš ï¸ Wind sensor unavailable");
            sensor_failures++;
          } else {
            ESP_LOGI("irrigation", "   âœ… Wind: %.1f km/h", wind);
          }
          
          if (sensor_failures == 0) {
            ESP_LOGI("irrigation", "   âœ… PASS - All weather sensors operational");
            tests_passed++;
          } else if (sensor_failures < 3) {
            ESP_LOGW("irrigation", "   âš ï¸ PARTIAL - %d/3 sensors unavailable", sensor_failures);
            tests_passed++;
            warnings++;
          } else {
            ESP_LOGE("irrigation", "   âŒ FAIL - All weather sensors offline");
            tests_failed++;
          }
          
          // TEST 3: Master Valve (if enabled)
          // Direct hardware control - bypasses all restrictions
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 3: Master Valve");
          if (!id(master_valve_enabled)) {
            ESP_LOGI("irrigation", "   â„¹ï¸ SKIP - Master valve not enabled");
          } else {
            ESP_LOGI("irrigation", "   Direct hardware test (${test_zone_sec} seconds)...");
            
            // Open valve (UNRESTRICTED - diagnostic mode)
            id(master_valve_relay).turn_on();
            ESP_LOGI("irrigation", "   â†’ Valve opened");
            
            // Wait ${test_zone_sec} seconds (non-blocking)
            for (int i = 0; i < (${test_zone_sec} * 10); i++) {
              delay(100);
              App.feed_wdt();
            }
            
            // Close valve
            id(master_valve_relay).turn_off();
            ESP_LOGI("irrigation", "   â†’ Valve closed");
            
            ESP_LOGI("irrigation", "   âœ… PASS - Master valve test complete");
            tests_passed++;
          }
          
          // TEST 4: Zone Valve Hardware Tests (3 sec each)
          // BYPASSES: Weather, rain delay, freeze protection, budget, runtime limits, windows, system enable
          // ONLY checks zone enable (no point testing disabled zones)
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 4: Zone Valve Hardware Tests");
          ESP_LOGI("irrigation", "   Direct GPIO control - ALL restrictions bypassed");
          ESP_LOGI("irrigation", "   Testing enabled zones only (${test_zone_sec} seconds each)...");
          ESP_LOGI("irrigation", "");
          
          int zones_tested = 0;
          for (int zone = 0; zone < 8; zone++) {
            bool enabled = false;
            switch(zone) {
              case 0: enabled = id(zone1_enable).state; break;
              case 1: enabled = id(zone2_enable).state; break;
              case 2: enabled = id(zone3_enable).state; break;
              case 3: enabled = id(zone4_enable).state; break;
              case 4: enabled = id(zone5_enable).state; break;
              case 5: enabled = id(zone6_enable).state; break;
              case 6: enabled = id(zone7_enable).state; break;
              case 7: enabled = id(zone8_enable).state; break;
            }
            
            if (enabled) {
              // Get custom zone name (from runtime text input)
              std::string zone_name = "${dev1_zone1}";  // Default fallback
              switch(zone) {
                case 0: zone_name = id(zone1_name).state; break;
                case 1: zone_name = id(zone2_name).state; break;
                case 2: zone_name = id(zone3_name).state; break;
                case 3: zone_name = id(zone4_name).state; break;
                case 4: zone_name = id(zone5_name).state; break;
                case 5: zone_name = id(zone6_name).state; break;
                case 6: zone_name = id(zone7_name).state; break;
                case 7: zone_name = id(zone8_name).state; break;
              }
              
              ESP_LOGI("irrigation", "   â†’ Testing %s (Zone %d)...", zone_name.c_str(), zone + 1);
              
              // Open master valve if enabled and zone requires it
              bool zone_needs_mv = false;
              switch(zone) {
                case 0: zone_needs_mv = id(zone1_master_valve_enabled); break;
                case 1: zone_needs_mv = id(zone2_master_valve_enabled); break;
                case 2: zone_needs_mv = id(zone3_master_valve_enabled); break;
                case 3: zone_needs_mv = id(zone4_master_valve_enabled); break;
                case 4: zone_needs_mv = id(zone5_master_valve_enabled); break;
                case 5: zone_needs_mv = id(zone6_master_valve_enabled); break;
                case 6: zone_needs_mv = id(zone7_master_valve_enabled); break;
                case 7: zone_needs_mv = id(zone8_master_valve_enabled); break;
              }
              
              if (id(master_valve_enabled) && zone_needs_mv) {
                id(master_valve_relay).turn_on();
              }
              
              // Turn on zone valve DIRECTLY at GPIO level (bypass sprinkler logic)
              switch(zone) {
                case 0: id(${devicename1}_1).turn_on(); break;
                case 1: id(${devicename1}_2).turn_on(); break;
                case 2: id(${devicename1}_3).turn_on(); break;
                case 3: id(${devicename1}_4).turn_on(); break;
                case 4: id(${devicename1}_5).turn_on(); break;
                case 5: id(${devicename1}_6).turn_on(); break;
                case 6: id(${devicename1}_7).turn_on(); break;
                case 7: id(${devicename1}_8).turn_on(); break;
              }
              
              // Wait ${test_zone_sec} seconds for water flow (non-blocking to prevent ESP32 freeze)
              for (int i = 0; i < (${test_zone_sec} * 10); i++) {
                delay(100);  // 100ms Ã— (${test_zone_sec}*10) = ${test_zone_sec}s total
                App.feed_wdt();  // Feed watchdog to prevent timeout
              }
              
              // Turn off zone valve
              switch(zone) {
                case 0: id(${devicename1}_1).turn_off(); break;
                case 1: id(${devicename1}_2).turn_off(); break;
                case 2: id(${devicename1}_3).turn_off(); break;
                case 3: id(${devicename1}_4).turn_off(); break;
                case 4: id(${devicename1}_5).turn_off(); break;
                case 5: id(${devicename1}_6).turn_off(); break;
                case 6: id(${devicename1}_7).turn_off(); break;
                case 7: id(${devicename1}_8).turn_off(); break;
              }
              
              // Close master valve
              if (id(master_valve_enabled) && zone_needs_mv) {
                id(master_valve_relay).turn_off();
              }
              
              ESP_LOGI("irrigation", "   âœ… %s test complete", zone_name.c_str());
              zones_tested++;
            }
          }
          
          if (zones_tested == 0) {
            ESP_LOGW("irrigation", "   âš ï¸ WARNING: No zones enabled to test!");
            warnings++;
          } else {
            ESP_LOGI("irrigation", "   âœ… PASS - %d zones tested successfully", zones_tested);
            tests_passed++;
          }
          
          // TEST 5: System Configuration
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 5: System Configuration");
          ESP_LOGI("irrigation", "   Predictive Watering: %s", id(predictive_watering_enabled) ? "ENABLED" : "Disabled");
          ESP_LOGI("irrigation", "   Smart ET: %s", id(smart_et_enabled) ? "ENABLED" : "Disabled");
          ESP_LOGI("irrigation", "   Freeze Protection: %s (threshold: %.1fÂ°C)", 
                   id(freeze_protection_active) ? "ACTIVE" : "Inactive", id(freeze_threshold));
          ESP_LOGI("irrigation", "   Water Budget: %.1f / %.1f L (%.1f%%)",
                   id(current_month_usage), id(monthly_water_budget),
                   id(monthly_water_budget) > 0 ? (id(current_month_usage) / id(monthly_water_budget)) * 100.0 : 0.0);
          ESP_LOGI("irrigation", "   âœ… PASS - Configuration valid");
          tests_passed++;
          
          // TEST 6: Memory & Performance
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ“‹ TEST 6: System Resources");
          ESP_LOGI("irrigation", "   Queue: %d/3 slots used", id(queue_count));
          ESP_LOGI("irrigation", "   Network: %s", id(network_offline_mode) ? "OFFLINE MODE" : "Online");
          ESP_LOGI("irrigation", "   âœ… PASS - Resources normal");
          tests_passed++;
          
          // FINAL REPORT
          ESP_LOGI("irrigation", "");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ”§ DIAGNOSTICS COMPLETE");
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "ğŸ“Š Results:");
          ESP_LOGI("irrigation", "   Tests Passed: %d", tests_passed);
          ESP_LOGI("irrigation", "   Tests Failed: %d", tests_failed);
          ESP_LOGI("irrigation", "   Warnings: %d", warnings);
          
          if (tests_failed == 0 && warnings == 0) {
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "   âœ…âœ…âœ… ALL SYSTEMS OPERATIONAL âœ…âœ…âœ…");
          } else if (tests_failed == 0) {
            ESP_LOGW("irrigation", "");
            ESP_LOGW("irrigation", "   âš ï¸ OPERATIONAL WITH WARNINGS");
          } else {
            ESP_LOGE("irrigation", "");
            ESP_LOGE("irrigation", "   âŒ CRITICAL ISSUES DETECTED");
          }
          
          ESP_LOGI("irrigation", "ğŸ”§ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("irrigation", "");
          
          // Exit test mode - re-enable watchdog
          id(test_mode_active) = false;
          
          // Reset status to Idle
          id(dev1_valve_status).publish_state("Idle");
