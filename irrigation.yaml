substitutions:
  dev1_what: Lawn
  devicename1: ${dev1_what}_irrigation_controller
  upper_devicename1: "${dev1_what} Irrigation Controller"
  dev1_zone1: Lawn Zone1
  dev1_zone2: Lawn Zone2
  dev1_zone3: Lawn Zone3
  dev1_zone4: Lawn Zone4
  dev1_zone5: Lawn Zone5
  dev1_zone6: Lawn Zone6
  dev1_zone7: Lawn Zone7
  dev1_zone8: Lawn Zone8
  master_valve_pin: GPIO27  # Master valve control (like Hunter Pro-C) - optional
  software_revision: V2.1
  date_revision: 2025 01 23
  sensor_update_frequency: 1s
  log_level: info # Enable levels logging https://esphome.io/components/logger.html
  # none, error, warn, info, debug (default), verbose, very_verbose

###################################
#  CHANGE BELOW LINES IF NEEDED ###
###################################
  esphome_name: "irrigation"
  esphome_board: esp32dev
  esp32_board: "esp32dev"
  esphome_comment: Irrigation Control System
  esphome_project_name: AG.Irrigation Control System
  esphome_project_version: ICS, $software_revision
  uom: Min # this overrides the uom in sprinkler -> run_duration

#Define Project Details and ESP Board Type
esphome:
  name: $esphome_name
  comment: $esphome_comment
  friendly_name: Irrigation Controller
  project:
    name: $esphome_project_name
    version: $esphome_project_version
  on_boot:
    priority: -100
    then:
      # Set default state for Valve Status
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      # reset multiplier at reboot
      - lambda: |-
          // === 3-ITEM QUEUE SYSTEM INITIALIZATION ===
            id(irrigation_busy) = false;
            id(in_program_run) = false;
            
            // Initialize queue arrays
            id(queue_count) = 0;
            for (int i = 0; i < 3; i++) {
              id(queue_types)[i] = 0;
              id(queue_programs)[i] = 0;
              id(queue_zones)[i] = 0;
              id(queue_durations)[i] = 0;
              id(queue_add_delays)[i] = false;
            }
            ESP_LOGI("irrigation", "ğŸ”„ BOOT: 3-slot queue initialized (Hunter Pro-C style)");

      - sprinkler.set_multiplier:
          id: $devicename1
          multiplier: 1
# Set smart multiplier on boot based on temperature and season
      - lambda: |-
          auto time = id(homeassistant_time).now();
          if (!time.is_valid()) {
            ESP_LOGW("irrigation", "Time not synchronized yet - will retry in 30 seconds");
            return;
          }
          
          int month = time.month;
          float temp = id(outside_temperature).state;
          if (isnan(temp)) {
            ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
            temp = 20.0;
          }
          
          float multiplier = 1.0;
          
          // Base seasonal multiplier
          if (month >= 12 || month <= 2) {
            multiplier = 1.3;  // Summer base
            // Hot days need more water
            if (temp > 25) multiplier = 1.6;
            if (temp > 30) multiplier = 1.8;
          } else if (month >= 6 && month <= 8) {
            multiplier = 0.5;  // Winter base
            // Cold days need less
            if (temp < 10) multiplier = 0.3;
          } else {
            // Spring/Autumn
            multiplier = 0.8;
            if (temp > 20) multiplier = 1.0;
          }
          
          id($devicename1).set_multiplier(multiplier);
          ESP_LOGI("irrigation", "Boot multiplier set to %.1f (temp: %.1fÂ°C)", multiplier, temp);
      
      # Retry multiplier setup if time wasn't synced on first attempt
      - delay: 30s
      - lambda: |-
          // Only retry if multiplier is still at default 1.0
          if (id($devicename1).multiplier() == 1.0) {
            auto time = id(homeassistant_time).now();
            if (!time.is_valid()) {
              ESP_LOGW("irrigation", "Time still not synchronized after 30s - will retry at midnight");
              return;
            }
            
            int month = time.month;
            float temp = id(outside_temperature).state;
            if (isnan(temp)) {
              ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
              temp = 20.0;
            }
            
            float multiplier = 1.0;
            
            // Base seasonal multiplier
            if (month >= 12 || month <= 2) {
              multiplier = 1.3;  // Summer base
              // Hot days need more water
              if (temp > 25) multiplier = 1.6;
              if (temp > 30) multiplier = 1.8;
            } else if (month >= 6 && month <= 8) {
              multiplier = 0.5;  // Winter base
              // Cold days need less
              if (temp < 10) multiplier = 0.3;
            } else {
              // Spring/Autumn
              multiplier = 0.8;
              if (temp > 20) multiplier = 1.0;
            }
            
            id($devicename1).set_multiplier(multiplier);
            ESP_LOGI("irrigation", "RETRY: Boot multiplier set to %.1f (temp: %.1fÂ°C)", multiplier, temp);
          } else {
            ESP_LOGI("irrigation", "Multiplier already set to %.1f - no retry needed", id($devicename1).multiplier());
          }
      
      # Initialize time restriction check
      - delay: 2s
      - script.execute: check_time_restriction
esp32:
  board: $esphome_board
  framework:
    type: esp-idf

api:
  encryption:
    key: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

ota:
  - platform: esphome
    password: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Irrigation-Controller"
    password: "uaRTa8vRL7uc"

captive_portal:

logger:
  level: ${log_level}
  logs:
    text_sensor: WARN

# Enable Web server
web_server:
  port: 80

globals:
  - id: rain_delay_days
    type: int
    restore_value: True
    initial_value: '0'
  - id: rain_delay_end_time
    type: long
    restore_value: True
    initial_value: '0'
  - id: master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'false'  # Optional feature, off by default
  - id: cycle_soak_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: cycle_duration_minutes
    type: int
    restore_value: True
    initial_value: '10'
  - id: soak_duration_minutes
    type: int
    restore_value: True
    initial_value: '10'
  - id: current_cycle
    type: int
    restore_value: False
    initial_value: '0'
  - id: total_cycles
    type: int
    restore_value: False
    initial_value: '0'
  - id: active_zone_number
    type: int
    restore_value: False
    initial_value: '-1'
  - id: zone_total_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: station_delay_seconds
    type: int
    restore_value: True
    initial_value: '5'  # Default 5 seconds between zones

  # Zone-specific schedule times
  - id: zone1_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone1_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone1_am_pm
    type: int
    restore_value: True
    initial_value: '0'  # 0=AM, 1=PM
  
  - id: zone2_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone2_start_minute
    type: int
    restore_value: True
    initial_value: '15'
  - id: zone2_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone3_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone3_start_minute
    type: int
    restore_value: True
    initial_value: '30'
  - id: zone3_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone4_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: zone4_start_minute
    type: int
    restore_value: True
    initial_value: '45'
  - id: zone4_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone5_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone5_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: zone5_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone6_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone6_start_minute
    type: int
    restore_value: True
    initial_value: '15'
  - id: zone6_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone7_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone7_start_minute
    type: int
    restore_value: True
    initial_value: '30'
  - id: zone7_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  
  - id: zone8_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: zone8_start_minute
    type: int
    restore_value: True
    initial_value: '45'
  - id: zone8_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  # Zone schedule enable flags
  - id: zone1_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone2_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone3_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone4_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone5_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone6_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone7_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: zone8_schedule_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
    
  # Master Valve per-zone enable (Hunter Pro-C style)
  - id: zone1_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'  # Default ON for all zones
  - id: zone2_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone3_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone4_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone5_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone6_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone7_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: zone8_master_valve_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
    
  - id: manual_rain_delay_override
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: manual_weather_override
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: last_weather_log_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: last_time_restriction_log
    type: long
    restore_value: False
    initial_value: '0'
  - id: vacation_mode_active
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: normal_multiplier
    type: float
    restore_value: True
    initial_value: '1.0'
# Last watered timestamps for each zone
  - id: zone1_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone2_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone3_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone4_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone5_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone6_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone7_last_watered
    type: long
    restore_value: True
    initial_value: '0'
  - id: zone8_last_watered
    type: long
    restore_value: True
    initial_value: '0'
# Zone start times (for duration tracking)
  - id: zone1_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone2_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone3_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone4_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone5_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone6_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone7_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: zone8_start_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: cycle_soak_total_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: cycle_soak_elapsed_time
    type: int
    restore_value: False
    initial_value: '0'
  - id: is_paused
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: paused_zone
    type: int
    restore_value: False
    initial_value: '-1'
  - id: paused_cycle
    type: int
    restore_value: False
    initial_value: '0'
  - id: time_remaining_when_paused
    type: int
    restore_value: False
    initial_value: '0'

  # --- Preserve cycle/soak state across Pause/Resume ---
  - id: paused_total_cycles
    type: int
    restore_value: False
    initial_value: '0'
  - id: paused_cycle_soak_total_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: paused_cycle_soak_elapsed_time
    type: int
    restore_value: False
    initial_value: '0'

  # --- Track soak phase for true pause/resume ---
  - id: cycle_soak_is_soaking
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: cycle_soak_soak_end_time
    type: long
    restore_value: False
    initial_value: '0'
  - id: paused_was_soaking
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: paused_soak_remaining_seconds
    type: int
    restore_value: False
    initial_value: '0'
  - id: soak_countdown_seconds
    type: int
    restore_value: False
    initial_value: '0'

  # --- Configurable Time Restriction Window (12-hour + AM-PM) ---
  - id: restrict_start_hour
    type: int
    restore_value: True
    initial_value: '10'   # 10 AM
  - id: restrict_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: restrict_start_am_pm
    type: int
    restore_value: True
    initial_value: '1'    # 0=AM, 1=PM

  - id: restrict_end_hour
    type: int
    restore_value: True
    initial_value: '3'    # 3.30 PM
  - id: restrict_end_minute
    type: int
    restore_value: True
    initial_value: '30'
  - id: restrict_end_am_pm
    type: int
    restore_value: True
    initial_value: '1'    # PM

  # --- Run lock / queue (prevents overlapping starts) ---
  - id: irrigation_busy
    type: bool
    restore_value: False
    initial_value: 'false'

  # True while run_program is executing
  - id: watchdog_last_activity
    type: long
    restore_value: False
    initial_value: '0'
  - id: in_program_run
    type: bool
    restore_value: False
    initial_value: 'false'

  # one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
  # Queue system - supports up to 3 items (Hunter-style)
  - id: queue_types
    type: int[3]
    restore_value: False
  - id: queue_programs
    type: int[3]
    restore_value: False
  - id: queue_zones
    type: int[3]
    restore_value: False
  - id: queue_durations
    type: int[3]
    restore_value: False
  - id: queue_add_delays
    type: bool[3]
    restore_value: False
  - id: queue_count
    type: int
    restore_value: False
    initial_value: '0'
  
  # Legacy queue variables (kept for backward compatibility during transition)
  - id: queued_type
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_program
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_zone
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_zone_duration
    type: int
    restore_value: False
    initial_value: '0'
  - id: queued_zone_add_delay
    type: bool
    restore_value: False
    initial_value: 'false'

# Program management
  - id: active_program
    type: int
    restore_value: False
    initial_value: '0'  # 0=A, 1=B, 2=C
    
  # Program A settings
  - id: program_a_enabled
    type: bool
    restore_value: True
    initial_value: 'true'
  - id: program_a_start_hour
    type: int
    restore_value: True
    initial_value: '6'
  - id: program_a_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_a_am_pm
    type: int
    restore_value: True
    initial_value: '0'  # 0=AM, 1=PM
  - id: program_a_schedule_type
    type: int
    restore_value: True
    initial_value: '0'  # 0=specific days, 1=odd days, 2=even days, 3=interval
  - id: program_a_interval_days
    type: int
    restore_value: True
    initial_value: '3'
  - id: program_a_last_run
    type: long
    restore_value: True
    initial_value: '0'
    
  # Program B settings
  - id: program_b_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: program_b_start_hour
    type: int
    restore_value: True
    initial_value: '7'
  - id: program_b_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_b_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_b_schedule_type
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_b_interval_days
    type: int
    restore_value: True
    initial_value: '3'
  - id: program_b_last_run
    type: long
    restore_value: True
    initial_value: '0'
    
  # Program C settings
  - id: program_c_enabled
    type: bool
    restore_value: True
    initial_value: 'false'
  - id: program_c_start_hour
    type: int
    restore_value: True
    initial_value: '8'
  - id: program_c_start_minute
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_c_am_pm
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_c_schedule_type
    type: int
    restore_value: True
    initial_value: '0'
  - id: program_c_interval_days
    type: int
    restore_value: True
    initial_value: '3'
  - id: program_c_last_run
    type: long
    restore_value: True
    initial_value: '0'
    
  # Zone assignment to programs (0=none, 1=A, 2=B, 3=C)
  - id: zone1_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone2_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone3_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone4_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone5_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone6_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone7_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: zone8_program
    type: int
    restore_value: True
    initial_value: '1'
  - id: is_time_restricted
    type: bool
    restore_value: False
    initial_value: 'false'
  - id: auto_advance_enabled
    type: bool
    restore_value: true
    initial_value: 'true'

  - id: stop_cooldown
    type: bool
    restore_value: false
    initial_value: "false"
  # Adjust this if your shutdown window is longer/shorter
  - id: stop_restart_delay_seconds
    type: int
    restore_value: true
    initial_value: "8"
  - id: pending_normal_start
    type: bool
    restore_value: false
    initial_value: "false"
  - id: normal_start_attempts
    type: int
    restore_value: false
    initial_value: "0"
  - id: normal_last_attempt_ms
    type: uint32_t
    restore_value: false
    initial_value: "0"
   
# Sync time with Home Assistant
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      # Check weather every 4 hours and set/clear rain delay
      - seconds: 0
        minutes: 0
        hours: /4  # Runs at 0:00, 4:00, 8:00, 12:00, 16:00, 20:00
        then:
          - lambda: |-
              // Only auto-manage rain delay if manual override is OFF
              if (!id(manual_rain_delay_override)) {
                std::string weather = id(weather_forecast_home).state;
                if (weather.empty() || weather == "unknown" || weather == "unavailable") {
                  ESP_LOGW("irrigation", "Weather state unavailable - skipping scheduled rain delay update");
                  return;
                }
                
                // Set rain delay if it's raining
                if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                  id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (86400 * 2); // 2 day delay
                  id(rain_delay_days) = 2;
                  id(rain_delay_days_input).publish_state(2);
                  ESP_LOGI("irrigation", "Auto rain delay activated - weather is %s", weather.c_str());
                }
                // Clear rain delay if weather is good
                else if (weather == "sunny" || weather == "clear" || weather == "partlycloudy" || weather == "cloudy") {
                  if (id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
                    id(rain_delay_end_time) = 0;
                    id(rain_delay_days) = 0;
                    id(rain_delay_days_input).publish_state(0);
                    ESP_LOGI("irrigation", "Auto rain delay cleared - weather is %s", weather.c_str());
                  }
                }
              }
      
# Check every minute if it's time to start programs
      - seconds: 0
        # NO minutes filter - check EVERY minute!
        then:
          # Check Program A
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_a_enabled)) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping Program A check");
                    return false;
                  }
                  
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        // Only log once per hour to reduce spam
                        long now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= 3600) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction check
                  if (id(is_time_restricted)) {
                    // Only log once per hour to reduce spam
                    long now = id(homeassistant_time).now().timestamp;
                    if (now - id(last_time_restriction_log) >= 3600) {
                      ESP_LOGW("irrigation", "â° SCHEDULES BLOCKED - Time restriction active (outside allowed hours)");
                      id(last_time_restriction_log) = now;
                    }
                    return false;
                  }
                  
                  // Convert 12-hour to 24-hour
                  int start_hour = id(program_a_start_hour);
                  if (id(program_a_am_pm) == 1) {  // PM
                    start_hour = (start_hour == 12) ? 12 : start_hour + 12;
                  } else {  // AM
                    start_hour = (start_hour == 12) ? 0 : start_hour;
                  }
                  
                  // Check if it's the right time
                  if (time.hour != start_hour || time.minute != id(program_a_start_minute)) return false;
                  
                  // Check schedule type
                  int schedule_type = id(program_a_schedule_type);
                  int day_of_month = time.day_of_month;
                  int day_of_week = time.day_of_week;  // 1=Sun, 2=Mon, 3=Tue, 4=Wed, 5=Thu, 6=Fri, 7=Sat
                  
                  if (schedule_type == 0) {  // Specific days
                    return (day_of_week == 2 && id(program_a_monday).state) ||
                           (day_of_week == 3 && id(program_a_tuesday).state) ||
                           (day_of_week == 4 && id(program_a_wednesday).state) ||
                           (day_of_week == 5 && id(program_a_thursday).state) ||
                           (day_of_week == 6 && id(program_a_friday).state) ||
                           (day_of_week == 7 && id(program_a_saturday).state) ||
                           (day_of_week == 1 && id(program_a_sunday).state);
                  } else if (schedule_type == 1) {  // Odd days
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {  // Even days
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {  // Interval
                    if (id(program_a_last_run) == 0) return true;  // Never run before
                    long days_since = (time.timestamp - id(program_a_last_run)) / 86400;
                    return (days_since >= id(program_a_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    
                    // Count zones in Program A
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 1 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 1 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 1 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 1 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 1 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 1 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 1 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 1 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM A TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 1
                    allow_queue: true  # Changed to true so programs can queue
          # Check Program B
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_b_enabled)) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping Program B check");
                    return false;
                  }
                  
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        // Only log once per hour to reduce spam
                        long now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= 3600) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  int current_hour = time.hour;
                  int start_hour = id(program_b_start_hour);
                  if (id(program_b_am_pm) == 1) {
                    start_hour = (start_hour == 12) ? 12 : start_hour + 12;
                  } else {
                    start_hour = (start_hour == 12) ? 0 : start_hour;
                  }
                  
                  if (current_hour != start_hour || time.minute != id(program_b_start_minute)) return false;
                  
                  int schedule_type = id(program_b_schedule_type);
                  int day_of_month = time.day_of_month;
                  int day_of_week = time.day_of_week;  // 1=Sun, 2=Mon, 3=Tue, 4=Wed, 5=Thu, 6=Fri, 7=Sat
                  
                  if (schedule_type == 0) {  // Specific Days
                    return (day_of_week == 2 && id(program_b_monday).state) ||
                           (day_of_week == 3 && id(program_b_tuesday).state) ||
                           (day_of_week == 4 && id(program_b_wednesday).state) ||
                           (day_of_week == 5 && id(program_b_thursday).state) ||
                           (day_of_week == 6 && id(program_b_friday).state) ||
                           (day_of_week == 7 && id(program_b_saturday).state) ||
                           (day_of_week == 1 && id(program_b_sunday).state);
                  } else if (schedule_type == 1) {  // Odd days
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {
                    if (id(program_b_last_run) == 0) return true;
                    long days_since = (time.timestamp - id(program_b_last_run)) / 86400;
                    return (days_since >= id(program_b_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    
                    // Count zones in Program B
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 2 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 2 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 2 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 2 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 2 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 2 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 2 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 2 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM B TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 2
                    allow_queue: true  # Changed to true so programs can queue
          # Check Program C
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  if (!id(program_c_enabled)) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Time not synchronized - skipping Program C check");
                    return false;
                  }
                  
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        // Only log once per hour to reduce spam
                        long now = id(homeassistant_time).now().timestamp;
                        if (now - id(last_weather_log_time) >= 3600) {
                          ESP_LOGW("irrigation", "â›ˆï¸ SCHEDULES BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                          id(last_weather_log_time) = now;
                        }
                        return false;
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  int current_hour = time.hour;
                  int start_hour = id(program_c_start_hour);
                  if (id(program_c_am_pm) == 1) {
                    start_hour = (start_hour == 12) ? 12 : start_hour + 12;
                  } else {
                    start_hour = (start_hour == 12) ? 0 : start_hour;
                  }
                  
                  if (current_hour != start_hour || time.minute != id(program_c_start_minute)) return false;
                  
                  int schedule_type = id(program_c_schedule_type);
                  int day_of_month = time.day_of_month;
                  int day_of_week = time.day_of_week;  // 1=Sun, 2=Mon, 3=Tue, 4=Wed, 5=Thu, 6=Fri, 7=Sat
                  
                  if (schedule_type == 0) {  // Specific Days
                    return (day_of_week == 2 && id(program_c_monday).state) ||
                           (day_of_week == 3 && id(program_c_tuesday).state) ||
                           (day_of_week == 4 && id(program_c_wednesday).state) ||
                           (day_of_week == 5 && id(program_c_thursday).state) ||
                           (day_of_week == 6 && id(program_c_friday).state) ||
                           (day_of_week == 7 && id(program_c_saturday).state) ||
                           (day_of_week == 1 && id(program_c_sunday).state);
                  } else if (schedule_type == 1) {  // Odd days
                    return (day_of_month % 2 == 1);
                  } else if (schedule_type == 2) {
                    return (day_of_month % 2 == 0);
                  } else if (schedule_type == 3) {
                    if (id(program_c_last_run) == 0) return true;
                    long days_since = (time.timestamp - id(program_c_last_run)) / 86400;
                    return (days_since >= id(program_c_interval_days));
                  }
                  return false;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    
                    // Count zones in Program C
                    int zone_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_program) == 3 && id(zone1_enable).state) { zone_count++; zones_list += "Z1 "; }
                    if (id(zone2_program) == 3 && id(zone2_enable).state) { zone_count++; zones_list += "Z2 "; }
                    if (id(zone3_program) == 3 && id(zone3_enable).state) { zone_count++; zones_list += "Z3 "; }
                    if (id(zone4_program) == 3 && id(zone4_enable).state) { zone_count++; zones_list += "Z4 "; }
                    if (id(zone5_program) == 3 && id(zone5_enable).state) { zone_count++; zones_list += "Z5 "; }
                    if (id(zone6_program) == 3 && id(zone6_enable).state) { zone_count++; zones_list += "Z6 "; }
                    if (id(zone7_program) == 3 && id(zone7_enable).state) { zone_count++; zones_list += "Z7 "; }
                    if (id(zone8_program) == 3 && id(zone8_enable).state) { zone_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  â° PROGRAM C TRIGGERED                                    â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Time: %02d:%02d                                             â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                  â•‘",
                             zone_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                - script.execute:
                    id: request_program_start
                    program: 3
                    allow_queue: true  # Changed to true so programs can queue

      # Update smart multiplier at midnight based on temperature and season
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: |-
              auto time = id(homeassistant_time).now();
              if (!time.is_valid()) {
                ESP_LOGW("irrigation", "Time not synchronized - skipping multiplier update");
                return;
              }
              
              int month = time.month;
              float temp = id(outside_temperature).state;
              if (isnan(temp)) {
                ESP_LOGW("irrigation", "Temperature unavailable, using default 20Â°C");
                temp = 20.0;
              }
              
              float multiplier = 1.0;
              
              // Base seasonal multiplier
              if (month >= 12 || month <= 2) {
                multiplier = 1.3;  // Summer base
                // Hot days need more water
                if (temp > 25) multiplier = 1.6;
                if (temp > 30) multiplier = 1.8;
              } else if (month >= 6 && month <= 8) {
                multiplier = 0.5;  // Winter base
                // Cold days need less
                if (temp < 10) multiplier = 0.3;
              } else {
                // Spring/Autumn
                multiplier = 0.8;
                if (temp > 20) multiplier = 1.0;
              }
              
              id($devicename1).set_multiplier(multiplier);
              ESP_LOGI("irrigation", "Multiplier set to %.1f (temp: %.1fÂ°C)", multiplier, temp);

# Check every minute for individual zone schedules
      - seconds: 0
        # NO minutes filter - check EVERY minute!
        then:
          # Zone 1 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone1_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;
                  
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone1_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone1_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  // Debug logging every minute when zone schedule is enabled
                  if (id(zone1_schedule_enabled)) {
                    ESP_LOGD("irrigation", "Zone 1 Check: Now=%02d:%02d, Set=%d:%02d %s (24h=%02d:%02d), Match=%d",
                             time.hour, time.minute,
                             hour_12, id(zone1_start_minute), id(zone1_am_pm) == 0 ? "AM" : "PM",
                             hour_24, id(zone1_start_minute),
                             (time.hour == hour_24 && time.minute == id(zone1_start_minute)) ? 1 : 0);
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone1_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_1_duration).state;
                    int hour_12 = id(zone1_start_hour);
                    int minute = id(zone1_start_minute);
                    const char* ampm = (id(zone1_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 1 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 0
                    duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                    add_delay: true
                    allow_queue: true

          # Zone 2 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone2_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }
                  
                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone2_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone2_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone2_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_2_duration).state;
                    int hour_12 = id(zone2_start_hour);
                    int minute = id(zone2_start_minute);
                    const char* ampm = (id(zone2_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 2 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 1
                    duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 3 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone3_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone3_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone3_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone3_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_3_duration).state;
                    int hour_12 = id(zone3_start_hour);
                    int minute = id(zone3_start_minute);
                    const char* ampm = (id(zone3_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 3 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 2
                    duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 4 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone4_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;
                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone4_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone4_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone4_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_4_duration).state;
                    int hour_12 = id(zone4_start_hour);
                    int minute = id(zone4_start_minute);
                    const char* ampm = (id(zone4_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 4 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 3
                    duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 5 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone5_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone5_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone5_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone5_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_5_duration).state;
                    int hour_12 = id(zone5_start_hour);
                    int minute = id(zone5_start_minute);
                    const char* ampm = (id(zone5_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 5 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 4
                    duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 6 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone6_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone6_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone6_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone6_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_6_duration).state;
                    int hour_12 = id(zone6_start_hour);
                    int minute = id(zone6_start_minute);
                    const char* ampm = (id(zone6_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 6 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 5
                    duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 7 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;


                  if (!id(zone7_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) return false;
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone7_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone7_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone7_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_7_duration).state;
                    int hour_12 = id(zone7_start_hour);
                    int minute = id(zone7_start_minute);
                    const char* ampm = (id(zone7_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 7 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 6
                    duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                    add_delay: true
                    allow_queue: true
          # Zone 8 Schedule
          - if:
              condition:
                lambda: |-
                  if (!id(irrigation_system_enable).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) return false;

                  if (!id(zone8_schedule_enabled)) return false;
                  if (id(rain_delay_end_time) > time.timestamp) return false;

                  // Weather check - only block if we KNOW it's bad weather (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Schedule will run despite weather: %s", w.c_str());
                    }
                    }
                  }

                  // Time restriction window (12h + AM-PM) with manual override
                  if (id(is_time_restricted)) return false;
                  
                  // Convert 12-hour + AM/PM to 24-hour for comparison
                  int hour_12 = id(zone8_start_hour);
                  int hour_24 = hour_12;
                  if (id(zone8_am_pm) == 1) {  // PM
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  return time.hour == hour_24 && time.minute == id(zone8_start_minute);
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    int duration_min = (int)id(Lawn_irrigation_controller_8_duration).state;
                    int hour_12 = id(zone8_start_hour);
                    int minute = id(zone8_start_minute);
                    const char* ampm = (id(zone8_am_pm) == 0) ? "AM" : "PM";
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ’§ ZONE 8 SCHEDULE TRIGGERED                            â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Scheduled: %d:%02d %s                                    â•‘",
                             hour_12, minute, ampm);
                    ESP_LOGI("irrigation", "â•‘  Started: %02d:%02d                                          â•‘",
                             time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Duration: %d minutes                                      â•‘",
                             duration_min);
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                - script.execute:
                    id: request_zone_start
                    zone: 7
                    duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                    add_delay: true
                    allow_queue: true

          # Weekly Schedule (Schedule 1-7: Monday-Sunday)
          # Like Hunter Pro-C: Runs ALL enabled zones at set time on selected days
          - if:
              condition:
                lambda: |-
                  // Must have irrigation system enabled
                  if (!id(irrigation_system_enable).state) return false;
                  
                  // Must have weekly schedule enabled
                  if (!id(weekly_schedule_switch).state) return false;
                  
                  auto time = id(homeassistant_time).now();
                  if (!time.is_valid()) {
                    ESP_LOGW("irrigation", "Weekly schedule: Time not synchronized");
                    return false;
                  }
                  
                  // Check rain delay
                  if (id(rain_delay_end_time) > time.timestamp) {
                    ESP_LOGD("irrigation", "Weekly schedule blocked - rain delay active");
                    return false;
                  }
                  
                  // Weather check (unless override active)
                  if (!id(manual_weather_override)) {
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                        return false;  // Block silently, logged once per hour by programs
                      }
                    }
                  } else {
                    // Weather override is active - log and continue
                    std::string w = id(weather_forecast_home).state;
                    if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Weekly schedule will run despite weather: %s", w.c_str());
                    }
                  }
                  
                  // Time restriction check
                  if (id(is_time_restricted)) {
                    return false;  // Block silently, logged once per hour by programs
                  }
                  
                  // Get scheduled time
                  int hour_12 = (int)id(schedule_start_hour).state;
                  int minute = (int)id(schedule_start_minute).state;
                  int hour_24 = hour_12;
                  
                  // Convert 12-hour + AM/PM to 24-hour
                  std::string am_pm = id(schedule_am_pm).current_option();
                  if (am_pm == "PM") {
                    hour_24 = (hour_12 == 12) ? 12 : hour_12 + 12;
                  } else {  // AM
                    hour_24 = (hour_12 == 12) ? 0 : hour_12;
                  }
                  
                  // Check if current time matches scheduled time
                  if (time.hour != hour_24 || time.minute != minute) return false;
                  
                  // Check if today is a scheduled day
                  // ESPHome day_of_week: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday
                  int day_of_week = time.day_of_week;
                  
                  bool day_enabled = (day_of_week == 2 && id(schedule_monday).state) ||
                                     (day_of_week == 3 && id(schedule_tuesday).state) ||
                                     (day_of_week == 4 && id(schedule_wednesday).state) ||
                                     (day_of_week == 5 && id(schedule_thursday).state) ||
                                     (day_of_week == 6 && id(schedule_friday).state) ||
                                     (day_of_week == 7 && id(schedule_saturday).state) ||
                                     (day_of_week == 1 && id(schedule_sunday).state);
                  
                  if (!day_enabled) {
                    ESP_LOGD("irrigation", "Weekly schedule: Today not scheduled (day_of_week=%d)", day_of_week);
                  }
                  
                  return day_enabled;
              then:
                - lambda: |-
                    auto time = id(homeassistant_time).now();
                    const char* day_names[] = {"", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
                    int dow = time.day_of_week;
                    
                    // Count enabled zones
                    int enabled_count = 0;
                    std::string zones_list = "";
                    if (id(zone1_enable).state) { enabled_count++; zones_list += "Z1 "; }
                    if (id(zone2_enable).state) { enabled_count++; zones_list += "Z2 "; }
                    if (id(zone3_enable).state) { enabled_count++; zones_list += "Z3 "; }
                    if (id(zone4_enable).state) { enabled_count++; zones_list += "Z4 "; }
                    if (id(zone5_enable).state) { enabled_count++; zones_list += "Z5 "; }
                    if (id(zone6_enable).state) { enabled_count++; zones_list += "Z6 "; }
                    if (id(zone7_enable).state) { enabled_count++; zones_list += "Z7 "; }
                    if (id(zone8_enable).state) { enabled_count++; zones_list += "Z8 "; }
                    
                    ESP_LOGI("irrigation", "");
                    ESP_LOGI("irrigation", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                    ESP_LOGI("irrigation", "â•‘  ğŸ”” WEEKLY SCHEDULE TRIGGERED                              â•‘");
                    ESP_LOGI("irrigation", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                    ESP_LOGI("irrigation", "â•‘  Day: %-20s @ %02d:%02d                       â•‘",
                             day_names[dow], time.hour, time.minute);
                    ESP_LOGI("irrigation", "â•‘  Zones: %d (%s)                                        â•‘",
                             enabled_count, zones_list.c_str());
                    ESP_LOGI("irrigation", "â•‘  Mode: Hunter Pro-C (full cycle with auto-advance)        â•‘");
                    ESP_LOGI("irrigation", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                    ESP_LOGI("irrigation", "");
                    
                    // Log weather check status
                    std::string w = id(weather_forecast_home).state;
                    if (id(manual_weather_override)) {
                      if (!w.empty() && (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy")) {
                        ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                      }
                    } else {
                      if (!w.empty() && w != "unknown" && w != "unavailable") {
                        ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                      }
                    }
                    
                    // Check if system is busy
                    bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
                    
                    if (busy) {
                      // Queue as type 3 (full cycle)
                      if (id(queue_count) < 3) {
                        int pos = id(queue_count);
                        id(queue_types)[pos] = 3;  // 3 = Full Cycle (Weekly Schedule)
                        id(queue_programs)[pos] = 0;
                        id(queue_zones)[pos] = 0;
                        id(queue_durations)[pos] = 0;
                        id(queue_add_delays)[pos] = false;
                        id(queue_count)++;
                        
                        ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Weekly Schedule â†’ Slot %d/3 (%d zones will run when idle)",
                                 pos + 1, enabled_count);
                      } else {
                        ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Weekly Schedule will NOT run!");
                      }
                    } else {
                      ESP_LOGI("irrigation", "â–¶ï¸ STARTING Weekly Schedule immediately (system idle)");
                      // Start immediately
                      id(pending_normal_start) = true;
                      id(normal_start_attempts) = 0;
                      id(normal_last_attempt_ms) = 0;
                    }

interval:
  - interval: 500ms
    then:
      - if:
          condition:
            lambda: |-
              // Only act if a normal run is pending
              return id(pending_normal_start);
          then:
            - lambda: |-
                // If paused, don't attempt to start
                if (id(is_paused)) return;

                // If a valve is already active, we succeeded - clear pending
                if (id($devicename1).active_valve().has_value()) {
                  ESP_LOGI("irrigation", "âœ… Normal start succeeded (valve active) - clearing pending flag");
                  id(pending_normal_start) = false;
                  id(normal_start_attempts) = 0;
                  return;
                }

                // Throttle attempts to 1/sec max
                uint32_t now = millis();
                if (now - id(normal_last_attempt_ms) < 1000) return;
                id(normal_last_attempt_ms) = now;

                // Safety: stop retrying after 30 attempts (~30s)
                if (id(normal_start_attempts) >= 30) {
                  ESP_LOGE("irrigation", "âŒ Normal start failed after 30 attempts - giving up");
                  id(pending_normal_start) = false;
                  id(normal_start_attempts) = 0;
                  return;
                }

                id(normal_start_attempts)++;
                ESP_LOGI("irrigation", "â–¶ Attempting Normal start (attempt %d)", id(normal_start_attempts));

            # Try to start full cycle; if it's still stopping, next interval will retry
            - sprinkler.start_full_cycle: $devicename1

  # Update cycle & soak progress every 2 seconds
  - interval: 2s
    then:
      - lambda: |-
          // ====================================================================
          // MASTER VALVE CONTROL (Hunter Pro-C Style)
          // ====================================================================
          // Master valve opens ONLY if:
          // 1. Master valve system is enabled globally
          // 2. A zone is currently active
          // 3. That specific zone has MV enabled for it
          
          if (id(master_valve_enabled)) {
            auto active_valve = id($devicename1).active_valve();
            bool any_zone_active = active_valve.has_value();
            bool master_should_be_on = false;
            
            if (any_zone_active) {
              int zone = active_valve.value();  // 0-7
              
              // Check if this specific zone has master valve enabled
              bool zone_mv_enabled = false;
              switch(zone) {
                case 0: zone_mv_enabled = id(zone1_master_valve_enabled); break;
                case 1: zone_mv_enabled = id(zone2_master_valve_enabled); break;
                case 2: zone_mv_enabled = id(zone3_master_valve_enabled); break;
                case 3: zone_mv_enabled = id(zone4_master_valve_enabled); break;
                case 4: zone_mv_enabled = id(zone5_master_valve_enabled); break;
                case 5: zone_mv_enabled = id(zone6_master_valve_enabled); break;
                case 6: zone_mv_enabled = id(zone7_master_valve_enabled); break;
                case 7: zone_mv_enabled = id(zone8_master_valve_enabled); break;
              }
              
              master_should_be_on = zone_mv_enabled;
              
              // Log zone MV status (debug level to avoid spam)
              static int last_logged_zone = -1;
              static bool last_logged_mv_state = false;
              if (zone != last_logged_zone || zone_mv_enabled != last_logged_mv_state) {
                ESP_LOGD("irrigation", "Zone %d active - MV for this zone: %s",
                         zone + 1, zone_mv_enabled ? "ENABLED" : "DISABLED");
                last_logged_zone = zone;
                last_logged_mv_state = zone_mv_enabled;
              }
            }
            
            bool master_is_on = id(master_valve_relay).state;
            
            // Control master valve based on zone requirements
            if (master_should_be_on && !master_is_on) {
              id(master_valve_relay).turn_on();
              if (any_zone_active) {
                auto active = id($devicename1).active_valve();
                ESP_LOGI("irrigation", "âœ… Master Valve OPENED (Zone %d active, MV enabled for this zone)",
                         active.value() + 1);
              }
            } else if (!master_should_be_on && master_is_on) {
              id(master_valve_relay).turn_off();
              ESP_LOGI("irrigation", "ğŸ”’ Master Valve CLOSED (no zones active or zone MV disabled)");
            }
          } else {
            // Master valve system disabled - ensure it's off
            if (id(master_valve_relay).state) {
              id(master_valve_relay).turn_off();
              ESP_LOGD("irrigation", "Master valve turned off (system disabled)");
            }
          }
          
          // Update soak countdown if currently soaking
          if (id(cycle_soak_is_soaking) && id(cycle_soak_soak_end_time) > 0) {
            long now = id(homeassistant_time).now().timestamp;
            int remaining = id(cycle_soak_soak_end_time) - now;
            if (remaining < 0) remaining = 0;
            id(soak_countdown_seconds) = remaining;
          } else {
            id(soak_countdown_seconds) = 0;
          }
          
          // Only increment if ALL conditions are met:
          // 1. Cycle & soak is active (total_duration > 0)
          // 2. Not finished yet (elapsed < total)
          // 3. NOT paused
          if (id(cycle_soak_total_duration) > 0 &&
              id(cycle_soak_elapsed_time) < id(cycle_soak_total_duration) &&
              !id(is_paused)) {
            
            bool valve_active = id($devicename1).active_valve().has_value();
            bool is_soaking = id(cycle_soak_is_soaking);
            
            // Increment if we're in an active cycle/soak session
            // (either watering OR soaking, but not idle between operations)
            if (valve_active || is_soaking) {
              id(cycle_soak_elapsed_time) += 2;  // Increment by 2 (interval is 2s)
              
              // Cap at total duration
              if (id(cycle_soak_elapsed_time) > id(cycle_soak_total_duration)) {
                id(cycle_soak_elapsed_time) = id(cycle_soak_total_duration);
              }
              
              // Debug logging every 10 seconds
              static int log_counter = 0;
              log_counter++;
              if (log_counter >= 5) {  // Every 10 seconds (5 * 2s intervals)
                ESP_LOGD("irrigation", "Progress: %d/%d sec (valve=%d, soaking=%d)",
                         id(cycle_soak_elapsed_time), id(cycle_soak_total_duration),
                         valve_active, is_soaking);
                log_counter = 0;
              }
            }
          }
  
# Watchdog - Check for stuck states every 30 seconds
  - interval: 30s
    then:
      - lambda: |-
          long now = id(homeassistant_time).now().timestamp;
          if (now == 0) return;  // Time not synced yet

          // --------------------------------------------------
          // PAUSE STATE WATCHDOG (24h safety)
          // --------------------------------------------------
          if (id(is_paused)) {
            static long pause_start_time = 0;
            if (pause_start_time == 0) {
              pause_start_time = now;
            }

            long paused_duration = now - pause_start_time;

            if (paused_duration > 86400) {
              ESP_LOGE("irrigation",
                "WATCHDOG: Paused for >24 hours (%ld sec) - auto-clearing abandoned pause",
                paused_duration);

              id(is_paused) = false;
              id(irrigation_busy) = false;
              id(in_program_run) = false;

              id(paused_zone) = -1;
              id(paused_cycle) = 0;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              id(paused_total_cycles) = 0;
              id(paused_cycle_soak_total_duration) = 0;
              id(paused_cycle_soak_elapsed_time) = 0;

              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;

              pause_start_time = 0;
              id(drain_queue).execute();
            }
            else if (paused_duration > 3600) {
              if ((paused_duration % 3600) < 30) {
                ESP_LOGW("irrigation",
                  "WATCHDOG: System paused for %ld hours",
                  paused_duration / 3600);
              }
            }

            return;
          }
          else {
            static long pause_start_time = 0;
            pause_start_time = 0;
          }

          // --------------------------------------------------
          // ACTIVE STATE CHECK
          // --------------------------------------------------
          bool valve_active = id($devicename1).active_valve().has_value();
          bool script_running =
            id(run_zone_with_cycles).is_running() ||
            id(run_program).is_running() ||
            id(run_all_zones_cycle_soak_script).is_running();
          bool soaking = id(cycle_soak_is_soaking);

          if (valve_active || script_running || soaking) {
            id(watchdog_last_activity) = now;
            return;
          }

          // --------------------------------------------------
          // SIMPLE FIX: CLEAN COMPLETION AUTO-CLEAR
          // --------------------------------------------------
          if (id(irrigation_busy) &&
              !valve_active &&
              !script_running &&
              !soaking &&
              !id(is_paused)) {

            ESP_LOGI("irrigation",
              "Run finished cleanly â€” auto-clearing busy flag");

            id(irrigation_busy) = false;
            id(in_program_run) = false;
            id(active_zone_number) = -1;
            id(current_cycle) = 0;
            id(total_cycles) = 0;

            id(drain_queue).execute();
            return;
          }

          // --------------------------------------------------
          // WATCHDOG ESCALATION (REAL STUCK STATES)
          // --------------------------------------------------
          if (id(irrigation_busy)) {
            long last = id(watchdog_last_activity);
            if (last == 0) last = now;
            long idle_seconds = now - last;

            if (idle_seconds >= 60) {
              ESP_LOGE("irrigation",
                "WATCHDOG: System stuck for %ld seconds - clearing busy flag",
                idle_seconds);
              ESP_LOGE("irrigation",
                "  valve_active=%d, script_running=%d, soaking=%d, busy=%d",
                valve_active, script_running, soaking, id(irrigation_busy));

              id(irrigation_busy) = false;
              id(in_program_run) = false;
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;

              id(drain_queue).execute();
            }
            else if (idle_seconds >= 30) {
              ESP_LOGW("irrigation",
                "WATCHDOG: System idle for %ld seconds (busy=%d)",
                idle_seconds, id(irrigation_busy));
            }
          }

          // --------------------------------------------------
          // QUEUE SAFETY CHECK
          // --------------------------------------------------
          if (id(queued_type) != 0 &&
              !id(irrigation_busy) &&
              !id(is_paused) &&
              !valve_active &&
              !script_running &&
              !soaking) {

            ESP_LOGI("irrigation",
              "WATCHDOG: Queue has items but system is idle - draining");
            id(drain_queue).execute();
          }

  # Update time restriction status every minute
  - interval: 60s
    then:
      - script.execute: check_time_restriction

###############################################
# Text sensors with general information
###############################################
text_sensor:
  - platform: version
    name: $esphome_name ESPHome Version
    hide_timestamp: false
    internal: true

# Current Time and Day Display
  - platform: template
    id: current_time_display
    name: "Current Time"
    icon: "mdi:clock-digital"
    update_interval: 1s
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) return {"Time not synced"};
      
      int hour_12 = time.hour;
      std::string am_pm = "AM";
      
      if (hour_12 >= 12) {
        am_pm = "PM";
        if (hour_12 > 12) hour_12 -= 12;
      }
      if (hour_12 == 0) hour_12 = 12;
      
      char buffer[20];
      sprintf(buffer, "%d:%02d %s", hour_12, time.minute, am_pm.c_str());
      return {std::string(buffer)};

  - platform: template
    id: current_day_display
    name: "Current Day"
    icon: "mdi:calendar-today"
    update_interval: 60s
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) return {"Day unknown"};
      
      const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
      // ESPHome: 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday
      int day_index = time.day_of_week - 1;
      if (day_index < 0 || day_index > 6) return {"Error"};
      
      return {std::string(days[day_index])};

  - platform: template
    id: current_datetime_display
    name: "Current Date & Time"
    icon: "mdi:calendar-clock"
    update_interval: 1s
    lambda: |-
      auto time = id(homeassistant_time).now();
      if (!time.is_valid()) return {"Not synced"};
      
      const char* days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
      int day_index = time.day_of_week - 1;
      
      int hour_12 = time.hour;
      std::string am_pm = "AM";
      if (hour_12 >= 12) {
        am_pm = "PM";
        if (hour_12 > 12) hour_12 -= 12;
      }
      if (hour_12 == 0) hour_12 = 12;
      
      char buffer[50];
      sprintf(buffer, "%s %d/%d/%d %d:%02d %s",
              days[day_index], time.day_of_month, time.month, time.year,
              hour_12, time.minute, am_pm.c_str());
      return {std::string(buffer)};

# Master Valve Status Display (Hunter Pro-C Style)
  - platform: template
    id: master_valve_status
    name: "Master Valve Status"
    icon: "mdi:valve"
    update_interval: 2s
    lambda: |-
      if (!id(master_valve_enabled)) {
        return {"System Disabled"};
      }
      
      bool mv_is_on = id(master_valve_relay).state;
      auto active_valve = id($devicename1).active_valve();
      
      if (!active_valve.has_value()) {
        if (mv_is_on) {
          return std::string("âš ï¸ ON (no zone active)");
        } else {
          return std::string("Closed (Standby)");
        }
      }
      
      int zone = active_valve.value();
      bool zone_mv_enabled = false;
      
      switch(zone) {
        case 0: zone_mv_enabled = id(zone1_master_valve_enabled); break;
        case 1: zone_mv_enabled = id(zone2_master_valve_enabled); break;
        case 2: zone_mv_enabled = id(zone3_master_valve_enabled); break;
        case 3: zone_mv_enabled = id(zone4_master_valve_enabled); break;
        case 4: zone_mv_enabled = id(zone5_master_valve_enabled); break;
        case 5: zone_mv_enabled = id(zone6_master_valve_enabled); break;
        case 6: zone_mv_enabled = id(zone7_master_valve_enabled); break;
        case 7: zone_mv_enabled = id(zone8_master_valve_enabled); break;
      }
      
      char buffer[80];
      if (zone_mv_enabled) {
        sprintf(buffer, "âœ… OPEN - Zone %d (MV Enabled)", zone + 1);
      } else {
        sprintf(buffer, "ğŸ”’ Closed - Zone %d (MV Disabled)", zone + 1);
      }
      return {std::string(buffer)};

# Weekly Schedule Status (Hunter Pro-C Style)
  - platform: template
    id: weekly_schedule_status
    name: "Weekly Schedule Status"
    icon: "mdi:calendar-clock"
    update_interval: 30s
    lambda: |-
      if (!id(weekly_schedule_switch).state) {
        return {"Disabled"};
      }
      
      // Build list of enabled days
      std::string days = "";
      if (id(schedule_monday).state) days += "Mon ";
      if (id(schedule_tuesday).state) days += "Tue ";
      if (id(schedule_wednesday).state) days += "Wed ";
      if (id(schedule_thursday).state) days += "Thu ";
      if (id(schedule_friday).state) days += "Fri ";
      if (id(schedule_saturday).state) days += "Sat ";
      if (id(schedule_sunday).state) days += "Sun ";
      
      if (days.empty()) {
        return {"Enabled - No days selected!"};
      }
      
      // Remove trailing space
      if (!days.empty()) days.pop_back();
      
      // Get scheduled time
      int hour = (int)id(schedule_start_hour).state;
      int minute = (int)id(schedule_start_minute).state;
      std::string am_pm = id(schedule_am_pm).current_option();
      
      char buffer[150];
      sprintf(buffer, "âœ“ Active: %s @ %d:%02d %s (All enabled zones)",
              days.c_str(), hour, minute, am_pm.c_str());
      return {std::string(buffer)};

# Program status sensors
  - platform: template
    id: program_a_status
    name: "Program A Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_a_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_a_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_a_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_a_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_a_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_a_interval_days)) + " days";
      
      int hour = id(program_a_start_hour);
      std::string am_pm = (id(program_a_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_a_start_minute) < 10 ? "0" : "") + std::to_string(id(program_a_start_minute)) + " " + am_pm};

  - platform: template
    id: program_b_status
    name: "Program B Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_b_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_b_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_b_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_b_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_b_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_b_interval_days)) + " days";
      
      int hour = id(program_b_start_hour);
      std::string am_pm = (id(program_b_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_b_start_minute) < 10 ? "0" : "") + std::to_string(id(program_b_start_minute)) + " " + am_pm};

  - platform: template
    id: program_c_status
    name: "Program C Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (!id(program_c_enabled)) return {"Disabled"};
      
      std::string schedule = "";
      if (id(program_c_schedule_type) == 0) schedule = "Specific Days";
      else if (id(program_c_schedule_type) == 1) schedule = "Odd Days";
      else if (id(program_c_schedule_type) == 2) schedule = "Even Days";
      else if (id(program_c_schedule_type) == 3) schedule = "Every " + std::to_string(id(program_c_interval_days)) + " days";
      
      int hour = id(program_c_start_hour);
      std::string am_pm = (id(program_c_am_pm) == 0) ? "AM" : "PM";
      
      return {"Enabled - " + schedule + " at " + std::to_string(hour) + ":" +
              (id(program_c_start_minute) < 10 ? "0" : "") + std::to_string(id(program_c_start_minute)) + " " + am_pm};

# Vacation Mode Status
  - platform: template
    id: vacation_mode_status
    name: "Vacation Mode Status"
    icon: "mdi:information"
    update_interval: 60s
    lambda: |-
      if (id(vacation_mode_active)) {
        float current_mult = id($devicename1).multiplier();
        return {"Active - Watering at " + std::to_string((int)(current_mult * 100)) + "%"};
      }
      return {"Inactive"};

  # Expose Time Remaining as a sensor
  - platform: template
    id: dev1_time_remaining
    name: $upper_devicename1 Time Remaining
    update_interval: $sensor_update_frequency
    icon: "mdi:timer-sand"
    lambda: |-
      int seconds = round(id($devicename1).time_remaining_active_valve().value_or(0));
      int days = seconds / (24 * 3600);
      seconds = seconds % (24 * 3600);
      int hours = seconds / 3600;
      seconds = seconds % 3600;
      int minutes = seconds /  60;
      seconds = seconds % 60;
      std::string result = "";
      if (days) result += std::to_string(days) + "d ";
      if (hours) result += std::to_string(hours) + "h ";
      if (minutes) result += std::to_string(minutes) + "m ";
      result += std::to_string(seconds) + "s";
      return result;
          
# Expose Progress Percent as a sensor
  - platform: template
    id: dev1_progress_percent
    name: $upper_devicename1 Progress %
    update_interval: $sensor_update_frequency
    icon: "mdi:progress-clock"
    lambda: |-
      // Check if a valve is active
      if (!id($devicename1).active_valve().has_value()) {
        return {"0%"};
      }
      
      auto valve_num = id($devicename1).active_valve().value();
      auto remaining = id($devicename1).time_remaining_active_valve().value_or(0);
      auto duration = id($devicename1).valve_run_duration_adjusted(valve_num);
      
      if (duration <= 0 || remaining < 0) {
        return {"0%"};
      }
      
      float elapsed = duration - remaining;
      int progress = (int)((elapsed / duration) * 100.0);
      
      if (progress < 0) progress = 0;
      if (progress > 100) progress = 100;
      
      return {std::to_string(progress) + "%"};
      
  # Expose Valve Status as a sensor
  - platform: template
    id: dev1_valve_status
    name: $upper_devicename1 Status
    update_interval: never
    icon: "mdi:information-variant"
    
  - platform: template
    id: espboard_type
    icon: "mdi:developer-board"
    name: $esphome_name ESPBoard
    update_interval: 3600s
    internal: true
    lambda: |-
      return {"${esp32_board}"};

# Weather state from Home Assistant
  - platform: homeassistant
    id: weather_forecast_home
    entity_id: weather.forecast_home
    internal: true
    on_value:
      then:
        # Immediately react to weather changes
        - lambda: |-
            // Only auto-manage rain delay if manual override is OFF
            if (!id(manual_rain_delay_override)) {
              std::string weather = x;
              if (weather.empty() || weather == "unknown" || weather == "unavailable") {
                ESP_LOGW("irrigation", "Weather state unavailable - skipping auto rain delay update");
                return;
              }
              
              // Set rain delay if it starts raining
              if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (86400 * 2); // 2 day delay
                id(rain_delay_days) = 2;
                id(rain_delay_days_input).publish_state(2);
                ESP_LOGI("irrigation", "Auto rain delay activated immediately - weather changed to %s", weather.c_str());
              }
              // Clear rain delay if weather improves
              else if (weather == "sunny" || weather == "clear" || weather == "partlycloudy" || weather == "cloudy") {
                if (id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
                  id(rain_delay_end_time) = 0;
                  id(rain_delay_days) = 0;
                  id(rain_delay_days_input).publish_state(0);
                  ESP_LOGI("irrigation", "Auto rain delay cleared immediately - weather changed to %s", weather.c_str());
                }
              }
            }


  # Time Restriction Status (live)
  - platform: template
    id: time_restriction_status
    name: "Time Restriction Status"
    icon: "mdi:clock-alert"
    update_interval: 30s
    lambda: |-
      auto t = id(homeassistant_time).now();
      int sh = id(restrict_start_hour);
      int eh = id(restrict_end_hour);
      int s24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
      int e24 = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
      int now_min = t.hour * 60 + t.minute;
      int start_min = s24 * 60 + id(restrict_start_minute);
      int end_min   = e24 * 60 + id(restrict_end_minute);
      bool enabled = id(time_restriction_switch).state && !id(manual_time_restriction_override).state;
      bool blocked = enabled && ((start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                                       : (now_min >= start_min || now_min < end_min));
      char buf[96];
      snprintf(buf, sizeof(buf), "%s (%d:%02d %s - %d:%02d %s)",
               blocked ? "Restricted" : (enabled ? "Allowed" : "Disabled"),
               id(restrict_start_hour), id(restrict_start_minute), (id(restrict_start_am_pm) == 0 ? "AM" : "PM"),
               id(restrict_end_hour), id(restrict_end_minute), (id(restrict_end_am_pm) == 0 ? "AM" : "PM"));
      return {buf};

  - platform: template
    id: time_restriction_next_allowed
    name: "Time Restriction Next Allowed"
    icon: "mdi:calendar-clock"
    update_interval: 30s
    lambda: |-
      auto t = id(homeassistant_time).now();
      int sh = id(restrict_start_hour);
      int eh = id(restrict_end_hour);
      int s24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
      int e24 = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
      int now_min = t.hour * 60 + t.minute;
      int start_min = s24 * 60 + id(restrict_start_minute);
      int end_min   = e24 * 60 + id(restrict_end_minute);
      bool enabled = id(time_restriction_switch).state && !id(manual_time_restriction_override).state;
      if (!enabled) return {"Now"};
      bool blocked = (start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                           : (now_min >= start_min || now_min < end_min);
      if (!blocked) return {"Now"};
      int next_min = end_min;
      int h24 = next_min / 60;
      int mm = next_min % 60;
      int ampm = (h24 >= 12) ? 1 : 0;
      int h12 = h24 % 12;
      if (h12 == 0) h12 = 12;
      char buf[32];
      snprintf(buf, sizeof(buf), "%d:%02d %s", h12, mm, (ampm == 0 ? "AM" : "PM"));
      return {buf};

# Weather condition display
  - platform: template
    id: weather_condition
    name: "Weather Condition"
    icon: "mdi:weather-partly-cloudy"
    lambda: |-
      if (id(weather_forecast_home).state.empty() || id(weather_forecast_home).state == "unknown" || id(weather_forecast_home).state == "unavailable") {
        return {"clear"};  // Default to clear if no data
      }
      return id(weather_forecast_home).state;


# Next scheduled watering day
  - platform: template
    id: next_watering_day
    name: "Next Watering Day"
    icon: "mdi:calendar-clock"
    update_interval: 300s
    lambda: |-
      auto time = id(homeassistant_time).now();
      int current_day = time.day_of_week;
      
      const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
      
      // Check next 7 days
      for (int i = 1; i <= 7; i++) {
        int check_day = (current_day + i) % 7;
        if ((check_day == 1 && id(schedule_monday).state) ||
            (check_day == 2 && id(schedule_tuesday).state) ||
            (check_day == 3 && id(schedule_wednesday).state) ||
            (check_day == 4 && id(schedule_thursday).state) ||
            (check_day == 5 && id(schedule_friday).state) ||
            (check_day == 6 && id(schedule_saturday).state) ||
            (check_day == 0 && id(schedule_sunday).state)) {
          return {days[check_day]};
        }
      }
      return {"None scheduled"};

# Cycle & Soak detailed status
  - platform: template
    id: cycle_soak_detailed_status
    name: "Cycle & Soak Detailed Status"
    icon: "mdi:water-sync"
    update_interval: 1s  # Changed from 2s to 1s for faster updates
    lambda: |-
      // Check if we're in cycle & soak mode with active tracking
      if (id(cycle_soak_total_duration) > 0 && id(active_zone_number) >= 0) {
        // Check if a valve is currently watering
        if (id($devicename1).active_valve().has_value()) {
          int valve = id($devicename1).active_valve().value();
          return {"Zone " + std::to_string(valve + 1) + " - Cycle " +
                  std::to_string(id(current_cycle)) + "/" +
                  std::to_string(id(total_cycles)) + " - Watering"};
        } else {
          // No valve active but we're tracking - must be soaking
          if (id(current_cycle) <= id(total_cycles) && id(current_cycle) > 0) {
            int countdown_sec = id(soak_countdown_seconds);
            int countdown_min = countdown_sec / 60;
            int countdown_sec_remaining = countdown_sec % 60;
            
            return {"Zone " + std::to_string(id(active_zone_number) + 1) +
                    " - Soaking (" + std::to_string(countdown_min) + "m " +
                    std::to_string(countdown_sec_remaining) + "s remaining)"};
          }
        }
      }
      
      // Check if any valve is active in normal mode
      if (id($devicename1).active_valve().has_value()) {
        int valve = id($devicename1).active_valve().value();
        return {"Zone " + std::to_string(valve + 1) + " - Active"};
      }
      
      return {"Idle"};

# Zone 1 Last Watered
  - platform: template
    id: zone1_last_watered_text
    name: "Zone 1 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone1_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone1_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 2 Last Watered
  - platform: template
    id: zone2_last_watered_text
    name: "Zone 2 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone2_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone2_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 3 Last Watered
  - platform: template
    id: zone3_last_watered_text
    name: "Zone 3 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone3_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone3_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 4 Last Watered
  - platform: template
    id: zone4_last_watered_text
    name: "Zone 4 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone4_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone4_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 5 Last Watered
  - platform: template
    id: zone5_last_watered_text
    name: "Zone 5 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone5_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone5_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 6 Last Watered
  - platform: template
    id: zone6_last_watered_text
    name: "Zone 6 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone6_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone6_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 7 Last Watered
  - platform: template
    id: zone7_last_watered_text
    name: "Zone 7 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone7_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone7_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Zone 8 Last Watered
  - platform: template
    id: zone8_last_watered_text
    name: "Zone 8 Last Watered"
    icon: "mdi:clock-outline"
    update_interval: 300s
    lambda: |-
      if (id(zone8_last_watered) == 0) {
        return {"Never"};
      }
      long seconds_ago = id(homeassistant_time).now().timestamp - id(zone8_last_watered);
      long days = seconds_ago / 86400;
      long hours = (seconds_ago % 86400) / 3600;
      
      if (days > 0) {
        return {std::to_string(days) + " days ago"};
      } else if (hours > 0) {
        return {std::to_string(hours) + " hours ago"};
      } else {
        long minutes = (seconds_ago % 3600) / 60;
        return {std::to_string(minutes) + " minutes ago"};
      }

  # Queue Status Display (Hunter Pro-C style)
  - platform: template
    id: queue_status_display
    name: "Queue Status"
    icon: "mdi:format-list-numbered"
    update_interval: 2s
    lambda: |-
      if (id(queue_count) == 0) {
        return {"Empty (0/3)"};
      }
      
      std::string result = std::to_string(id(queue_count)) + "/3: ";
      for (int i = 0; i < id(queue_count) && i < 3; i++) {
        if (i > 0) result += ", ";
        int type = id(queue_types)[i];
        if (type == 1) {
          // Program
          result += "Prg " + std::string(1, 'A' + id(queue_programs)[i] - 1);
        } else if (type == 2) {
          // Zone
          result += "Zone " + std::to_string(id(queue_zones)[i] + 1);
        }
      }
      return {result};

sensor:
  # Uptime sensor
  - platform: uptime
    name: $upper_devicename1 Uptime
    internal: true

  # Internal sensors from Home Assistant (no template.publish here)
  - platform: homeassistant
    id: ha_temperature
    entity_id: weather.forecast_home
    attribute: temperature
    internal: true

  - platform: homeassistant
    id: ha_humidity
    entity_id: weather.forecast_home
    attribute: humidity
    internal: true

  # Template sensors for display + fallback values
  - platform: template
    id: outside_temperature
    name: "Outside Temperature"
    icon: "mdi:thermometer"
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1
    lambda: |-
      if (isnan(id(ha_temperature).state)) {
        return 20.0;  // Default fallback temperature
      }
      return id(ha_temperature).state;

  - platform: template
    id: outside_humidity
    name: "Outside Humidity"
    icon: "mdi:water-percent"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    lambda: |-
      if (isnan(id(ha_humidity).state)) {
        return 70.0;  // Default fallback humidity
      }
      return id(ha_humidity).state;
    
  # Rain delay countdown
  - platform: template
    id: rain_delay_remaining
    name: "Rain Delay Days Remaining"
    icon: "mdi:timer-sand"
    unit_of_measurement: "days"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      if (id(rain_delay_end_time) == 0) return 0.0f;
      long current_time = id(homeassistant_time).now().timestamp;
      long remaining_seconds = id(rain_delay_end_time) - current_time;
      if (remaining_seconds <= 0) {
        id(rain_delay_end_time) = 0;
        id(rain_delay_days) = 0;
        return 0.0f;
      }
      return remaining_seconds / 86400.0f;

  # Current seasonal multiplier
  - platform: template
    id: seasonal_multiplier
    name: "Seasonal Multiplier"
    icon: "mdi:calendar-month"
    unit_of_measurement: "x"
    accuracy_decimals: 1
    update_interval: 3600s
    lambda: |-
      return id($devicename1).multiplier();

###############################################
# Configuration to set multiplier via number
###############################################
number:
  # Manual multiplier override
  - platform: template
    id: "${dev1_what}_multiplier"
    name: "${devicename1}_multiplier"
    min_value: 0.01
    max_value: 2.00
    step: 0.01
    icon: "mdi:water-percent"
    mode: slider
    lambda: "return id($devicename1).multiplier();"
    set_action:
      - sprinkler.set_multiplier:
          id: $devicename1
          multiplier: !lambda 'return x;'

  # Rain delay days
  - platform: template
    id: rain_delay_days_input
    name: "Rain Delay Days"
    min_value: 0
    max_value: 14
    step: 1
    icon: "mdi:weather-rainy"
    mode: box
    lambda: "return id(rain_delay_days);"
    set_action:
      - lambda: |-
          id(rain_delay_days) = x;
          if (x > 0) {
            id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (x * 86400);
          } else {
            id(rain_delay_end_time) = 0;
          }

  # Quick run duration
  - platform: template
    id: quick_run_duration
    name: "Quick Run Duration"
    min_value: 1
    max_value: 15
    step: 1
    initial_value: 5
    icon: "mdi:timer"
    mode: slider
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true

# Schedule start hour (12-hour format)
  - platform: template
    id: schedule_start_hour
    name: "Schedule Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    initial_value: 6
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    optimistic: true
    restore_value: true

# Schedule start minute
  - platform: template
    id: schedule_start_minute
    name: "Schedule Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    initial_value: 0
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    optimistic: true
    restore_value: true

# Cycle duration
  - platform: template
    id: cycle_duration_input
    name: "Cycle Duration"
    min_value: 3
    max_value: 20
    step: 1
    icon: "mdi:timer-play"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(cycle_duration_minutes);"
    set_action:
      - lambda: "id(cycle_duration_minutes) = x;"

  # Soak duration
  - platform: template
    id: soak_duration_input
    name: "Soak Duration"
    min_value: 3         # Match cycle minimum
    max_value: 20        # Match cycle maximum
    step: 1
    icon: "mdi:timer-pause"
    mode: slider
    unit_of_measurement: "min"
    lambda: "return id(soak_duration_minutes);"
    set_action:
      - lambda: "id(soak_duration_minutes) = x;"

# Station delay between zones
  - platform: template
    id: station_delay_input
    name: "Station Delay Between Zones"
    min_value: 0
    max_value: 60
    step: 5
    icon: "mdi:timer-cog"
    mode: slider
    unit_of_measurement: "sec"
    lambda: "return id(station_delay_seconds);"
    set_action:
      - lambda: "id(station_delay_seconds) = x;"


  # Time Restriction Window (12-hour format)
  - platform: template
    id: restrict_start_hour_input
    name: "Time Restriction Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(restrict_start_hour);"
    set_action:
      - lambda: "id(restrict_start_hour) = (int)x;"

  - platform: template
    id: restrict_start_minute_input
    name: "Time Restriction Start Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(restrict_start_minute);"
    set_action:
      - lambda: "id(restrict_start_minute) = (int)x;"

  - platform: template
    id: restrict_end_hour_input
    name: "Time Restriction End Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(restrict_end_hour);"
    set_action:
      - lambda: "id(restrict_end_hour) = (int)x;"

  - platform: template
    id: restrict_end_minute_input
    name: "Time Restriction End Minute"
    min_value: 0
    max_value: 59
    step: 5
    icon: "mdi:clock-end"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(restrict_end_minute);"
    set_action:
      - lambda: "id(restrict_end_minute) = (int)x;"

# Zone 1 Schedule Time
  - platform: template
    id: zone1_schedule_hour
    name: "Zone 1 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone1_start_hour);"
    set_action:
      - lambda: "id(zone1_start_hour) = x;"

  - platform: template
    id: zone1_schedule_minute
    name: "Zone 1 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone1_start_minute);"
    set_action:
      - lambda: "id(zone1_start_minute) = x;"

# Zone 2 Schedule Time
  - platform: template
    id: zone2_schedule_hour
    name: "Zone 2 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone2_start_hour);"
    set_action:
      - lambda: "id(zone2_start_hour) = x;"

  - platform: template
    id: zone2_schedule_minute
    name: "Zone 2 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone2_start_minute);"
    set_action:
      - lambda: "id(zone2_start_minute) = x;"

  # Zone 3 Schedule Time
  - platform: template
    id: zone3_schedule_hour
    name: "Zone 3 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone3_start_hour);"
    set_action:
      - lambda: "id(zone3_start_hour) = x;"

  - platform: template
    id: zone3_schedule_minute
    name: "Zone 3 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone3_start_minute);"
    set_action:
      - lambda: "id(zone3_start_minute) = x;"

  # Zone 4 Schedule Time
  - platform: template
    id: zone4_schedule_hour
    name: "Zone 4 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone4_start_hour);"
    set_action:
      - lambda: "id(zone4_start_hour) = x;"

  - platform: template
    id: zone4_schedule_minute
    name: "Zone 4 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone4_start_minute);"
    set_action:
      - lambda: "id(zone4_start_minute) = x;"

  # Zone 5 Schedule Time
  - platform: template
    id: zone5_schedule_hour
    name: "Zone 5 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone5_start_hour);"
    set_action:
      - lambda: "id(zone5_start_hour) = x;"

  - platform: template
    id: zone5_schedule_minute
    name: "Zone 5 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone5_start_minute);"
    set_action:
      - lambda: "id(zone5_start_minute) = x;"

  # Zone 6 Schedule Time
  - platform: template
    id: zone6_schedule_hour
    name: "Zone 6 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone6_start_hour);"
    set_action:
      - lambda: "id(zone6_start_hour) = x;"

  - platform: template
    id: zone6_schedule_minute
    name: "Zone 6 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone6_start_minute);"
    set_action:
      - lambda: "id(zone6_start_minute) = x;"

  # Zone 7 Schedule Time
  - platform: template
    id: zone7_schedule_hour
    name: "Zone 7 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone7_start_hour);"
    set_action:
      - lambda: "id(zone7_start_hour) = x;"

  - platform: template
    id: zone7_schedule_minute
    name: "Zone 7 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone7_start_minute);"
    set_action:
      - lambda: "id(zone7_start_minute) = x;"

  # Zone 8 Schedule Time
  - platform: template
    id: zone8_schedule_hour
    name: "Zone 8 Schedule Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(zone8_start_hour);"
    set_action:
      - lambda: "id(zone8_start_hour) = x;"

  - platform: template
    id: zone8_schedule_minute
    name: "Zone 8 Schedule Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(zone8_start_minute);"
    set_action:
      - lambda: "id(zone8_start_minute) = x;"

# Program A start time
  - platform: template
    id: program_a_start_hour_input
    name: "Program A Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_a_start_hour);"
    set_action:
      - lambda: "id(program_a_start_hour) = x;"

  - platform: template
    id: program_a_start_minute_input
    name: "Program A Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_a_start_minute);"
    set_action:
      - lambda: "id(program_a_start_minute) = x;"

  - platform: template
    id: program_a_interval_input
    name: "Program A Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_a_interval_days);"
    set_action:
      - lambda: "id(program_a_interval_days) = x;"

  # Program B start time
  - platform: template
    id: program_b_start_hour_input
    name: "Program B Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_b_start_hour);"
    set_action:
      - lambda: "id(program_b_start_hour) = x;"

  - platform: template
    id: program_b_start_minute_input
    name: "Program B Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_b_start_minute);"
    set_action:
      - lambda: "id(program_b_start_minute) = x;"

  - platform: template
    id: program_b_interval_input
    name: "Program B Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_b_interval_days);"
    set_action:
      - lambda: "id(program_b_interval_days) = x;"

  # Program C start time
  - platform: template
    id: program_c_start_hour_input
    name: "Program C Start Hour"
    min_value: 1
    max_value: 12
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "h"
    lambda: "return id(program_c_start_hour);"
    set_action:
      - lambda: "id(program_c_start_hour) = x;"

  - platform: template
    id: program_c_start_minute_input
    name: "Program C Start Minute"
    min_value: 0
    max_value: 59
    step: 1
    icon: "mdi:clock-start"
    mode: box
    unit_of_measurement: "min"
    lambda: "return id(program_c_start_minute);"
    set_action:
      - lambda: "id(program_c_start_minute) = x;"

  - platform: template
    id: program_c_interval_input
    name: "Program C Interval Days"
    min_value: 1
    max_value: 31
    step: 1
    icon: "mdi:calendar-range"
    mode: box
    unit_of_measurement: "days"
    lambda: "return id(program_c_interval_days);"
    set_action:
      - lambda: "id(program_c_interval_days) = x;"

script:
  # Request NORMAL mode start: start now if idle, otherwise queue it (queued_type = 3)
  - id: request_normal_start
    mode: restart
    then:
      - lambda: |-
          bool valve_active = id($devicename1).active_valve().has_value();
          bool script_running =
              id(run_zone_with_cycles).is_running() ||
              id(run_program).is_running() ||
              id(run_all_zones_cycle_soak_script).is_running();
          bool soaking = id(cycle_soak_is_soaking);

          if (id(irrigation_busy) || valve_active || script_running || soaking) {
            // one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
            id(queued_type) = 3;  // queue/overwrite a pending normal run
            ESP_LOGI("irrigation", "Queued NORMAL start (will run when system is idle)");
            return;
          }

          ESP_LOGI("irrigation", "Starting NORMAL immediately");
      - sprinkler.start_full_cycle: $devicename1

  # Wait until system is truly idle, then drain queue
  - id: wait_until_idle_then_drain
    mode: restart
    then:
      - while:
          condition:
            lambda: |-
              bool valve_active = id($devicename1).active_valve().has_value();
              bool script_running =
                  id(run_zone_with_cycles).is_running() ||
                  id(run_program).is_running() ||
                  id(run_all_zones_cycle_soak_script).is_running();
              bool soaking = id(cycle_soak_is_soaking);

              // Keep waiting while anything is still active or stopping
              return valve_active || script_running || soaking || id(irrigation_busy);
          then:
            - delay: 250ms
      - script.execute: drain_queue

  # Drain queued items from 3-item queue (Hunter Pro-C style)
  - id: drain_queue
    mode: restart
    then:
      - lambda: |-
          // === 3-ITEM QUEUE DRAINING SYSTEM ===
          
          // Check if queue is empty
          if (id(queue_count) == 0) {
            ESP_LOGD("irrigation", "âœ… Queue empty (0/3 items)");
            return;
          }

          // Hold queue if system is paused
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ PAUSED - Holding queue (%d/%d items waiting)",
                     id(queue_count), 3);
            return;
          }

          // Check if system is truly idle
          const bool valve_active = id($devicename1).active_valve().has_value();
          const bool scripts_running =
              id(run_zone_with_cycles).is_running() ||
              id(run_program).is_running() ||
              id(run_all_zones_cycle_soak_script).is_running();
          const bool soaking = id(cycle_soak_is_soaking);

          if (valve_active || scripts_running || soaking || id(irrigation_busy)) {
            ESP_LOGI("irrigation", "â³ NOT IDLE - Queue waiting (%d/%d) | valve=%d script=%d soak=%d busy=%d",
                     id(queue_count), 3, valve_active, scripts_running, soaking, id(irrigation_busy));
            id(wait_until_idle_then_drain).execute();
            return;
          }

          // === DRAIN FIRST ITEM FROM QUEUE ===
          int type = id(queue_types)[0];
          int program = id(queue_programs)[0];
          int zone = id(queue_zones)[0];
          int duration = id(queue_durations)[0];
          bool add_delay = id(queue_add_delays)[0];
          
          // Build queue contents for logging
          std::string queue_contents = "";
          for (int i = 0; i < id(queue_count) && i < 3; i++) {
            if (i > 0) queue_contents += ", ";
            if (id(queue_types)[i] == 1) {
              queue_contents += "Prg";
              queue_contents += (char)('A' + id(queue_programs)[i] - 1);
            } else if (id(queue_types)[i] == 2) {
              queue_contents += "Z";
              queue_contents += std::to_string(id(queue_zones)[i] + 1);
            } else if (id(queue_types)[i] == 3) {
              queue_contents += "Weekly";
            }
          }
          
          ESP_LOGI("irrigation", "ğŸ“¤ DRAINING queue [%s] â†’ Starting item 1/%d",
                   queue_contents.c_str(), id(queue_count));
          
          // Shift queue forward (remove first item)
          for (int i = 0; i < 2; i++) {
            id(queue_types)[i] = id(queue_types)[i + 1];
            id(queue_programs)[i] = id(queue_programs)[i + 1];
            id(queue_zones)[i] = id(queue_zones)[i + 1];
            id(queue_durations)[i] = id(queue_durations)[i + 1];
            id(queue_add_delays)[i] = id(queue_add_delays)[i + 1];
          }
          
          // Clear last slot
          id(queue_types)[2] = 0;
          id(queue_programs)[2] = 0;
          id(queue_zones)[2] = 0;
          id(queue_durations)[2] = 0;
          id(queue_add_delays)[2] = false;
          
          id(queue_count)--;
          
          // Start the appropriate item type
          if (type == 1) {
            // PROGRAM
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Program %c | Queue now: %d/3 items",
                     'A' + program - 1, id(queue_count));
            id(irrigation_busy) = true;
            id(in_program_run) = true;
            id(run_program).execute(program);
            
          } else if (type == 2) {
            // ZONE
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Zone %d (%ds) | Queue now: %d/3 items",
                     zone + 1, duration, id(queue_count));
            id(irrigation_busy) = true;
            id(in_program_run) = false;
            id(run_zone_with_cycles).execute(zone, duration, add_delay, false);
            
          } else if (type == 3) {
            // FULL CYCLE (Weekly Schedule)
            ESP_LOGI("irrigation", "â–¶ï¸ STARTING queued Weekly Schedule (Full Cycle) | Queue now: %d/3 items",
                     id(queue_count));
            id(pending_normal_start) = true;
            id(normal_start_attempts) = 0;
            id(normal_last_attempt_ms) = 0;
          }

  # Run all zones in normal mode â€“ production safe
  - id: run_all_zones_normal_script
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              return id(stop_cooldown);
          then:
            - logger.log: "â³ Stop cooldown active â€” queueing Normal start"
            - lambda: |-
                // one-slot queue: 0=none, 1=program, 2=zone, 3=normal mode
                if (id(queued_type) == 0) {
                  id(queued_type) = 3;
                }
          else:
            - logger.log: "â•â•â• STARTING NORMAL MODE â•â•â•"

            - lambda: |-
                id(irrigation_busy) = true;
                id(in_program_run) = false;

            - sprinkler.start_full_cycle: $devicename1

            - logger.log: "âœ“ Normal mode started - sprinkler managing sequence"

# Request to start a program: manual blocked while busy; scheduled can queue.
  - id: request_program_start
    mode: queued
    parameters:
      program: int
      allow_queue: bool
    then:
      - lambda: |-
          // Check if paused
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ Program %c BLOCKED - system paused", 'A' + program - 1);
            return;
          }

          bool busy = id(irrigation_busy) || id($devicename1).active_valve().has_value();
          
          if (busy) {
            if (allow_queue) {
              // === 3-ITEM QUEUE SYSTEM ===
              if (id(queue_count) < 3) {
                int pos = id(queue_count);
                id(queue_types)[pos] = 1;  // 1 = Program
                id(queue_programs)[pos] = program;
                id(queue_zones)[pos] = 0;
                id(queue_durations)[pos] = 0;
                id(queue_add_delays)[pos] = false;
                id(queue_count)++;
                
                // Build queue status for logging
                std::string q_status = "";
                for (int i = 0; i < id(queue_count); i++) {
                  if (i > 0) q_status += ", ";
                  if (id(queue_types)[i] == 1) q_status += "Prg" + std::string(1, 'A' + id(queue_programs)[i] - 1);
                  else if (id(queue_types)[i] == 2) q_status += "Z" + std::to_string(id(queue_zones)[i] + 1);
                  else if (id(queue_types)[i] == 3) q_status += "Weekly";
                }
                
                ESP_LOGI("irrigation", "ğŸ“‹ QUEUED Program %c â†’ Slot %d/3 | Queue: [%s]",
                         'A' + program - 1, pos + 1, q_status.c_str());
              } else {
                ESP_LOGW("irrigation", "âš ï¸ QUEUE FULL (3/3) - Program %c will NOT run!", 'A' + program - 1);
              }
            } else {
              ESP_LOGW("irrigation", "ğŸš« BUSY - Manual Program %c blocked", 'A' + program - 1);
            }
            return;
          }
          
          // System is idle - start immediately
          ESP_LOGI("irrigation", "â–¶ï¸ STARTING Program %c immediately (system idle)", 'A' + program - 1);
          id(irrigation_busy) = true;
          id(in_program_run) = true;
          id(run_program).execute(program);

  # Request to start a zone: manual blocked while busy; scheduled can queue.
  - id: request_zone_start
    mode: queued
    parameters:
      zone: int
      duration: int
      add_delay: bool
      allow_queue: bool
    then:
      - lambda: |-
          // CRITICAL: Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d BLOCKED - Irrigation system is DISABLED", zone + 1);
            return;
          }
          
          if (id(is_paused)) {
            ESP_LOGW("irrigation", "â¸ Paused - cannot start Zone %d", zone + 1);
            return;
          }

          // CRITICAL: Check if zone is enabled
          bool zone_enabled = false;
          switch(zone) {
            case 0: zone_enabled = id(zone1_enable).state; break;
            case 1: zone_enabled = id(zone2_enable).state; break;
            case 2: zone_enabled = id(zone3_enable).state; break;
            case 3: zone_enabled = id(zone4_enable).state; break;
            case 4: zone_enabled = id(zone5_enable).state; break;
            case 5: zone_enabled = id(zone6_enable).state; break;
            case 6: zone_enabled = id(zone7_enable).state; break;
            case 7: zone_enabled = id(zone8_enable).state; break;
          }
          if (!zone_enabled) {
            ESP_LOGW("irrigation", "ğŸš« Zone %d is DISABLED - will not run", zone + 1);
            return;
          }
          ESP_LOGI("irrigation", "âœ“ Zone %d is ENABLED - proceeding", zone + 1);

          // CRITICAL: Check weather for ALL zone requests (unless override active)
          if (!id(manual_weather_override)) {
            std::string weather = id(weather_forecast_home).state;
            if (!weather.empty() && weather != "unknown" && weather != "unavailable") {
              if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone %d BLOCKED - Bad weather: %s (Enable Weather Override to force)", 
                         zone + 1, weather.c_str());
                return;
              }
            }
            ESP_LOGI("irrigation", "â˜€ï¸ Weather check PASSED for Zone %d", zone + 1);
          } else {
            ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Skipping weather check for Zone %d", zone + 1);
          }

          // CRITICAL: Check time restriction (for manual runs only)
          if (!allow_queue) {
            if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "â° Zone %d blocked - time restriction active", zone + 1);
              return;
            }
            ESP_LOGI("irrigation", "âœ“ Time restriction check PASSED for Zone %d", zone + 1);
          }

          if (id(irrigation_busy) || id($devicename1).active_valve().has_value()) {
            if (allow_queue) {
              // 3-item queue
              if (id(queue_count) < 3) {
                int pos = id(queue_count);
                id(queue_types)[pos] = 2;  // 2 = Zone
                id(queue_programs)[pos] = 0;
                id(queue_zones)[pos] = zone;
                id(queue_durations)[pos] = duration;
                id(queue_add_delays)[pos] = add_delay;
                id(queue_count)++;
                ESP_LOGI("irrigation", "ğŸ“‹ Queued Zone %d in slot %d/3 (%d items queued)",
                         zone + 1, pos + 1, id(queue_count));
              } else {
                ESP_LOGW("irrigation", "âš ï¸ Queue FULL (3/3) - Zone %d will NOT run!", zone + 1);
              }
            } else {
              ESP_LOGW("irrigation", "ğŸš« Busy - manual Zone %d start blocked", zone + 1);
            }
            return;
          }

          ESP_LOGI("irrigation", "â–¶ï¸ Starting Zone %d immediately (system idle)", zone + 1);
          id(irrigation_busy) = true;
          id(in_program_run) = false;
          id(run_zone_with_cycles).execute(zone, duration, add_delay, false);

  # Handle cycle & soak for a zone with station delay
  - id: run_zone_with_cycles
    mode: single  # CRITICAL: Must be 'single' not 'restart' to prevent soak interruption
    parameters:
      zone: int
      duration: int
      add_delay: bool
      force_normal: bool
    then:
      - lambda: |-
          ESP_LOGI("irrigation", "ğŸš€ run_zone_with_cycles STARTED - mode should be SINGLE (not restart)");
          id(irrigation_busy) = true;
          
          // Get multiplier first
          float multiplier = id($devicename1).multiplier();
          
          ESP_LOGI("irrigation", "ğŸŒŠ ZONE %d START | Mode: %s | Duration: %ds | Multiplier: %.2f",
                   zone + 1,
                   (force_normal || !id(cycle_soak_switch).state) ? "NORMAL" : "CYCLE&SOAK",
                   duration, multiplier);
          
          if (force_normal || !id(cycle_soak_switch).state) {
            // NORMAL MODE
            int adjusted_duration = (int)(duration * multiplier);
            
            ESP_LOGI("irrigation", "==> NORMAL MODE - running %d seconds (base=%d, multiplier=%.2f)",
                     adjusted_duration, duration, multiplier);
            
            id(cycle_soak_total_duration) = 0;
            id(cycle_soak_elapsed_time) = 0;
            id(active_zone_number) = -1;
            id(total_cycles) = 0;
            id(current_cycle) = 0;
            
            // CRITICAL: Final zone enable check before relay activation
            bool zone_enabled_now = false;
            switch(zone) {
              case 0: zone_enabled_now = id(zone1_enable).state; break;
              case 1: zone_enabled_now = id(zone2_enable).state; break;
              case 2: zone_enabled_now = id(zone3_enable).state; break;
              case 3: zone_enabled_now = id(zone4_enable).state; break;
              case 4: zone_enabled_now = id(zone5_enable).state; break;
              case 5: zone_enabled_now = id(zone6_enable).state; break;
              case 6: zone_enabled_now = id(zone7_enable).state; break;
              case 7: zone_enabled_now = id(zone8_enable).state; break;
            }
            
            if (!zone_enabled_now) {
              ESP_LOGW("irrigation", "ğŸš« RELAY BLOCKED: Zone %d disabled at activation", zone + 1);
              id(irrigation_busy) = false;
              return;
            }
            
            ESP_LOGI("irrigation", "âœ… Zone %d relay activation allowed", zone + 1);
            
            // Start valve
            id($devicename1).start_single_valve(zone, adjusted_duration);
            
          } else {
            // CYCLE & SOAK MODE (no multiplier applied)
            int cycle_seconds = id(cycle_duration_minutes) * 60;
            int soak_seconds = id(soak_duration_minutes) * 60;
            int total_duration = duration;  // Use base duration without multiplier
            int cycles = (total_duration + cycle_seconds - 1) / cycle_seconds;
            int total_time = (cycles * cycle_seconds) + ((cycles - 1) * soak_seconds);
            
            ESP_LOGI("irrigation", "==> CYCLE & SOAK MODE - %d cycles of %d sec (NO multiplier) + %d sec soak",
                     cycles, cycle_seconds, soak_seconds);
            
            id(cycle_soak_total_duration) = total_time;
            id(cycle_soak_elapsed_time) = 0;
            id(active_zone_number) = zone;
            id(total_cycles) = cycles;
            id(current_cycle) = 1;
          }
      
      # NORMAL MODE EXECUTION
      - if:
          condition:
            lambda: 'return force_normal || !id(cycle_soak_switch).state;'
          then:
            - lambda: |-
                int wait_time = (int)(duration * id($devicename1).multiplier());
                ESP_LOGI("irrigation", "Waiting %d seconds for normal mode to complete...", wait_time);
            - delay: !lambda 'return (int)(duration * id($devicename1).multiplier() + 3) * 1000;'
            - lambda: |-
                ESP_LOGI("irrigation", "Zone %d COMPLETE (normal mode)", zone);
                if (!id(in_program_run)) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
      
      # CYCLE & SOAK MODE EXECUTION
      - if:
          condition:
            lambda: 'return !force_normal && id(cycle_soak_switch).state;'
          then:
            # Run first cycle (no multiplier in soak mode)
            - sprinkler.start_single_valve:
                id: $devicename1
                valve_number: !lambda "return zone;"
                run_duration: !lambda "return id(cycle_duration_minutes) * 60;"
            - delay: !lambda "return (id(cycle_duration_minutes) * 60 + 2) * 1000;"
            
            # Repeat remaining cycles
            - repeat:
                count: !lambda "return id(total_cycles) - 1;"
                then:
                  # Soak period
                  - lambda: |-
                      id(cycle_soak_is_soaking) = true;
                      int soak_min = id(soak_duration_minutes);
                      int soak_sec = soak_min * 60;
                      int soak_ms = soak_sec * 1000;
                      id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_sec;
                      ESP_LOGI("irrigation", "ğŸŒ§ï¸ SOAK START: soak_duration_minutes=%d, seconds=%d, milliseconds=%d",
                               soak_min, soak_sec, soak_ms);
                      ESP_LOGI("irrigation", "    Delay will be: %d ms (should be 600000 for 10 min)", soak_ms);
                  - delay: !lambda "return id(soak_duration_minutes) * 60 * 1000;"
                  - lambda: |-
                      ESP_LOGI("irrigation", "âœ… SOAK DELAY COMPLETED!");
                      id(cycle_soak_is_soaking) = false;
                      id(cycle_soak_soak_end_time) = 0;
                      id(current_cycle)++;
                      ESP_LOGI("irrigation", "âœ… SOAK COMPLETE! Starting cycle %d of %d",
                               id(current_cycle), id(total_cycles));
                  
                  # Next cycle (no multiplier in soak mode)
                  - sprinkler.start_single_valve:
                      id: $devicename1
                      valve_number: !lambda "return zone;"
                      run_duration: !lambda "return id(cycle_duration_minutes) * 60;"
                  - delay: !lambda "return (id(cycle_duration_minutes) * 60 + 2) * 1000;"
            
            # Cleanup
            - lambda: |-
                ESP_LOGI("irrigation", "Zone %d COMPLETE (cycle & soak)", zone);
                if (!id(in_program_run)) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
                id(active_zone_number) = -1;
                id(current_cycle) = 0;
                id(total_cycles) = 0;
                id(cycle_soak_total_duration) = 0;
                id(cycle_soak_elapsed_time) = 0;
      
      # Station delay
      - if:
          condition:
            lambda: "return add_delay;"
          then:
            - lambda: |-
                ESP_LOGI("irrigation", "Station delay: %d seconds", id(station_delay_seconds));
            - delay: !lambda "return id(station_delay_seconds) * 1000;"
            
            # Reset after all cycles
            - lambda: |-
                ESP_LOGI("irrigation", "Zone %d complete (cycle & soak)", zone);
                if (!id(in_program_run)) {
                  id(irrigation_busy) = false;
                  id(drain_queue).execute();
                }
                id(active_zone_number) = -1;
                id(current_cycle) = 0;
                id(total_cycles) = 0;
                id(cycle_soak_total_duration) = 0;
                id(cycle_soak_elapsed_time) = 0;
      
      # Add station delay if requested
      - if:
          condition:
            lambda: "return add_delay;"
          then:
            - lambda: |-
                ESP_LOGI("irrigation", "Station delay: %d seconds", id(station_delay_seconds));
            - delay: !lambda "return id(station_delay_seconds) * 1000;"

  # Continue cycle & soak after a Pause/Resume
  - id: continue_cycle_soak_after_resume
    mode: restart
    parameters:
      zone: int
      start_cycle: int
      total: int
      was_soaking: bool
      soak_remaining: int
      water_remaining: int
    then:
      # If we paused while watering, wait for the resumed watering to finish
      - if:
          condition:
            lambda: 'return !was_soaking && water_remaining > 0;'
          then:
            - delay: !lambda 'return (water_remaining + 2) * 1000;'

      # If we paused while soaking, finish the remaining soak first
      - if:
          condition:
            lambda: 'return was_soaking && soak_remaining > 0;'
          then:
            - lambda: |-
                id(cycle_soak_is_soaking) = true;
                id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_remaining;
                ESP_LOGI("irrigation", "Resuming soak for %d seconds", soak_remaining);
            - delay: !lambda 'return soak_remaining * 1000;'
            - lambda: |-
                id(cycle_soak_is_soaking) = false;
                id(cycle_soak_soak_end_time) = 0;
                // move to next cycle after soak
                id(current_cycle)++;

      # Run remaining cycles
      - while:
          condition:
            lambda: 'return id(current_cycle) < total;'
          then:
            - lambda: |-
                // soak between cycles
                id(cycle_soak_is_soaking) = true;
                int soak_s = id(soak_duration_minutes) * 60;
                id(cycle_soak_soak_end_time) = id(homeassistant_time).now().timestamp + soak_s;
                ESP_LOGI("irrigation", "Soaking for %d seconds", soak_s);
            - delay: !lambda 'return id(soak_duration_minutes) * 60 * 1000;'
            - lambda: |-
                id(cycle_soak_is_soaking) = false;
                id(cycle_soak_soak_end_time) = 0;
                id(current_cycle)++;
                ESP_LOGI("irrigation", "Starting cycle %d of %d after resume", id(current_cycle), total);
            - sprinkler.start_single_valve:
                id: $devicename1
                valve_number: !lambda 'return zone;'
                run_duration: !lambda 'return id(cycle_duration_minutes) * 60;'
            - delay: !lambda 'return (id(cycle_duration_minutes) * 60 + 2) * 1000;'

      - lambda: |-
          // Cleanup cycle/soak state
          id(active_zone_number) = -1;
          id(current_cycle) = 0;
          id(total_cycles) = 0;
          id(cycle_soak_total_duration) = 0;
          id(cycle_soak_elapsed_time) = 0;
          id(cycle_soak_is_soaking) = false;
          id(cycle_soak_soak_end_time) = 0;
          id(paused_zone) = -1;
          id(paused_cycle) = 0;
          id(time_remaining_when_paused) = 0;
          id(paused_was_soaking) = false;
          id(paused_soak_remaining_seconds) = 0;
          id(paused_total_cycles) = 0;
          id(paused_cycle_soak_total_duration) = 0;
          id(paused_cycle_soak_elapsed_time) = 0;
          // Restore Auto Advance
          id(dev1_auto_advance).turn_on();
          ESP_LOGI("irrigation", "Auto Advance restored - Cycle & Soak resume complete");

  # Run all zones in cycle & soak mode
  - id: run_all_zones_cycle_soak_script
    mode: single
    then:
      - logger.log: "Starting all enabled zones - Cycle & Soak mode"
      
      # Turn off Auto Advance for cycle & soak
      - switch.turn_off: dev1_auto_advance
      - logger.log: "Auto Advance OFF for Cycle & Soak"
      
      # Set busy flags
      - lambda: |-
          id(irrigation_busy) = true;
          id(in_program_run) = false;
      
      # Zone 1
      - if:
          condition:
            switch.is_on: zone1_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 0
                duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 2
      - if:
          condition:
            switch.is_on: zone2_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 1
                duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 3
      - if:
          condition:
            switch.is_on: zone3_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 2
                duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 4
      - if:
          condition:
            switch.is_on: zone4_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 3
                duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 5
      - if:
          condition:
            switch.is_on: zone5_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 4
                duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 6
      - if:
          condition:
            switch.is_on: zone6_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 5
                duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 7
      - if:
          condition:
            switch.is_on: zone7_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 6
                duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      # Zone 8
      - if:
          condition:
            switch.is_on: zone8_enable
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 7
                duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                add_delay: false
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - logger.log: "All enabled zones complete"
      
      # Clear busy flag
      - lambda: |-
          id(irrigation_busy) = false;
          id(in_program_run) = false;
      
      # Restore Auto Advance after completion
      - delay: 500ms
      - switch.turn_on: dev1_auto_advance
      - logger.log: "Auto Advance restored to ON"
      
      # Drain queue
      - delay: 100ms
      - script.execute: drain_queue

  # Run a specific program
  - id: run_program
    mode: single
    parameters:
      program: int  # 1=A, 2=B, 3=C
    then:
      - lambda: |-
          id(irrigation_busy) = true;
          id(in_program_run) = true;

      - lambda: |-
          // CRITICAL: Check weather before starting program
          std::string weather = id(weather_forecast_home).state;
          if (!weather.empty() && weather != "unknown" && weather != "unavailable") {
            if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
              ESP_LOGW("irrigation", "â›ˆï¸ Program %c BLOCKED - bad weather: %s", 'A' + program - 1, weather.c_str());
              id(irrigation_busy) = false;
              id(in_program_run) = false;
              return;
            }
          }
          ESP_LOGI("irrigation", "â˜€ï¸ Weather check PASSED - Program %c starting", 'A' + program - 1);
          
          ESP_LOGI("irrigation", "ğŸ¯ PROGRAM %c STARTING | Checking zone assignments...", 'A' + program - 1);
      
      # Build list of zones for this program
      - lambda: |-
          std::vector<int> zones_to_run;
          
          // Check which zones belong to this program
          if (id(zone1_program) == program && id(zone1_enable).state) zones_to_run.push_back(0);
          if (id(zone2_program) == program && id(zone2_enable).state) zones_to_run.push_back(1);
          if (id(zone3_program) == program && id(zone3_enable).state) zones_to_run.push_back(2);
          if (id(zone4_program) == program && id(zone4_enable).state) zones_to_run.push_back(3);
          if (id(zone5_program) == program && id(zone5_enable).state) zones_to_run.push_back(4);
          if (id(zone6_program) == program && id(zone6_enable).state) zones_to_run.push_back(5);
          if (id(zone7_program) == program && id(zone7_enable).state) zones_to_run.push_back(6);
          if (id(zone8_program) == program && id(zone8_enable).state) zones_to_run.push_back(7);
          
          ESP_LOGI("irrigation", "Program %c has %d enabled zones", 'A' + program - 1, zones_to_run.size());
          
          // Store the zones to run
          id(active_program) = program;
      
      # Run each zone in the program
      - if:
          condition:
            lambda: 'return id(zone1_program) == program && id(zone1_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 0
                duration: !lambda "return id(Lawn_irrigation_controller_1_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone2_program) == program && id(zone2_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 1
                duration: !lambda "return id(Lawn_irrigation_controller_2_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone3_program) == program && id(zone3_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 2
                duration: !lambda "return id(Lawn_irrigation_controller_3_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone4_program) == program && id(zone4_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 3
                duration: !lambda "return id(Lawn_irrigation_controller_4_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone5_program) == program && id(zone5_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 4
                duration: !lambda "return id(Lawn_irrigation_controller_5_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone6_program) == program && id(zone6_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 5
                duration: !lambda "return id(Lawn_irrigation_controller_6_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone7_program) == program && id(zone7_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 6
                duration: !lambda "return id(Lawn_irrigation_controller_7_duration).state * 60;"
                add_delay: true
                force_normal: false
            - script.wait: run_zone_with_cycles
      
      - if:
          condition:
            lambda: 'return id(zone8_program) == program && id(zone8_enable).state;'
          then:
            - script.execute:
                id: run_zone_with_cycles
                zone: 7
                duration: !lambda "return id(Lawn_irrigation_controller_8_duration).state * 60;"
                add_delay: false
                force_normal: false
            - script.wait: run_zone_with_cycles

      # Update last run time ONLY for interval-based schedules (type 3)
      - lambda: |-
          long now = id(homeassistant_time).now().timestamp;
          
          // Only update last_run for interval schedules (type 3)
          if (program == 1 && id(program_a_schedule_type) == 3) {
            id(program_a_last_run) = now;
            ESP_LOGI("irrigation", "Program A last run updated for interval scheduling");
          } else if (program == 2 && id(program_b_schedule_type) == 3) {
            id(program_b_last_run) = now;
            ESP_LOGI("irrigation", "Program B last run updated for interval scheduling");
          } else if (program == 3 && id(program_c_schedule_type) == 3) {
            id(program_c_last_run) = now;
            ESP_LOGI("irrigation", "Program C last run updated for interval scheduling");
          }
          
          ESP_LOGI("irrigation", "Program %c complete", 'A' + program - 1);
          id(in_program_run) = false;
          id(irrigation_busy) = false;
      
      # Restore Auto Advance
      - delay: 500ms
      - switch.turn_on: dev1_auto_advance
      - logger.log: "Auto Advance ON"
      
      # Drain queue
      - delay: 100ms
      - script.execute: drain_queue

  # Check if current time is within the restriction window
  - id: check_time_restriction
    mode: single
    then:
      - lambda: |-
          // Check if time restriction is disabled
          if (!id(time_restriction_switch).state) {
            id(is_time_restricted) = false;
            ESP_LOGD("irrigation", "â° Time restriction DISABLED");
            return;
          }
          
          // Check if manual override is active
          if (id(manual_time_restriction_override).state) {
            id(is_time_restricted) = false;
            ESP_LOGI("irrigation", "â° Time restriction OVERRIDDEN - watering allowed");
            return;
          }
          
          auto time = id(homeassistant_time).now();
          if (!time.is_valid()) {
            id(is_time_restricted) = false;
            return;
          }
          
          // Convert 12-hour to 24-hour format
          int sh = id(restrict_start_hour);
          int eh = id(restrict_end_hour);
          int start_hour24 = (id(restrict_start_am_pm) == 1) ? ((sh == 12) ? 12 : sh + 12) : ((sh == 12) ? 0 : sh);
          int end_hour24   = (id(restrict_end_am_pm) == 1) ? ((eh == 12) ? 12 : eh + 12) : ((eh == 12) ? 0 : eh);
          
          // Calculate time in minutes since midnight
          int now_min = time.hour * 60 + time.minute;
          int start_min = start_hour24 * 60 + id(restrict_start_minute);
          int end_min   = end_hour24 * 60 + id(restrict_end_minute);
          
          // Check if current time is in restricted window
          bool blocked = (start_min < end_min) ? (now_min >= start_min && now_min < end_min)
                                                : (now_min >= start_min || now_min < end_min);
          
          id(is_time_restricted) = blocked;

select:
  # AM-PM selector
  - platform: template
    id: schedule_am_pm
    name: "Schedule AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true

  # Time Restriction AM-PM
  - platform: template
    id: restrict_start_am_pm_select
    name: "Time Restriction Start AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: true
    set_action:
      - lambda: |-
          id(restrict_start_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: restrict_end_am_pm_select
    name: "Time Restriction End AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "PM"
    restore_value: true
    set_action:
      - lambda: |-
          id(restrict_end_am_pm) = (x == "AM") ? 0 : 1;

# Program A schedule type
  - platform: template
    id: program_a_schedule_type_select
    name: "Program A Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_a_schedule_type) = 0;
          else if (x == "Odd Days") id(program_a_schedule_type) = 1;
          else if (x == "Even Days") id(program_a_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_a_schedule_type) = 3;

  # Program A AM-PM
  - platform: template
    id: program_a_am_pm_select
    name: "Program A AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(program_a_am_pm) = (x == "AM") ? 0 : 1;

  # Program B schedule type
  - platform: template
    id: program_b_schedule_type_select
    name: "Program B Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_b_schedule_type) = 0;
          else if (x == "Odd Days") id(program_b_schedule_type) = 1;
          else if (x == "Even Days") id(program_b_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_b_schedule_type) = 3;

  # Program B AM-PM
  - platform: template
    id: program_b_am_pm_select
    name: "Program B AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(program_b_am_pm) = (x == "AM") ? 0 : 1;

  # Program C schedule type
  - platform: template
    id: program_c_schedule_type_select
    name: "Program C Schedule Type"
    icon: "mdi:calendar-check"
    optimistic: true
    options:
      - "Specific Days"
      - "Odd Days"
      - "Even Days"
      - "Interval (Every N Days)"
    initial_option: "Specific Days"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "Specific Days") id(program_c_schedule_type) = 0;
          else if (x == "Odd Days") id(program_c_schedule_type) = 1;
          else if (x == "Even Days") id(program_c_schedule_type) = 2;
          else if (x == "Interval (Every N Days)") id(program_c_schedule_type) = 3;

  # Program C AM-PM
  - platform: template
    id: program_c_am_pm_select
    name: "Program C AM or PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(program_c_am_pm) = (x == "AM") ? 0 : 1;

  # Zone Schedule AM-PM Selectors
  - platform: template
    id: zone1_schedule_am_pm
    name: "Zone 1 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone1_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone2_schedule_am_pm
    name: "Zone 2 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone2_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone3_schedule_am_pm
    name: "Zone 3 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone3_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone4_schedule_am_pm
    name: "Zone 4 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone4_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone5_schedule_am_pm
    name: "Zone 5 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone5_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone6_schedule_am_pm
    name: "Zone 6 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone6_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone7_schedule_am_pm
    name: "Zone 7 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone7_am_pm) = (x == "AM") ? 0 : 1;

  - platform: template
    id: zone8_schedule_am_pm
    name: "Zone 8 Schedule AM-PM"
    icon: "mdi:clock"
    optimistic: true
    options:
      - "AM"
      - "PM"
    initial_option: "AM"
    restore_value: true
    set_action:
      - lambda: |-
          id(zone8_am_pm) = (x == "AM") ? 0 : 1;

  # Zone program assignment selects
  - platform: template
    id: zone1_program_select
    name: "Zone 1 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone1_program) = 0;
          else if (x == "Program A") id(zone1_program) = 1;
          else if (x == "Program B") id(zone1_program) = 2;
          else if (x == "Program C") id(zone1_program) = 3;

  - platform: template
    id: zone2_program_select
    name: "Zone 2 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone2_program) = 0;
          else if (x == "Program A") id(zone2_program) = 1;
          else if (x == "Program B") id(zone2_program) = 2;
          else if (x == "Program C") id(zone2_program) = 3;

  - platform: template
    id: zone3_program_select
    name: "Zone 3 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone3_program) = 0;
          else if (x == "Program A") id(zone3_program) = 1;
          else if (x == "Program B") id(zone3_program) = 2;
          else if (x == "Program C") id(zone3_program) = 3;

  - platform: template
    id: zone4_program_select
    name: "Zone 4 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone4_program) = 0;
          else if (x == "Program A") id(zone4_program) = 1;
          else if (x == "Program B") id(zone4_program) = 2;
          else if (x == "Program C") id(zone4_program) = 3;

  - platform: template
    id: zone5_program_select
    name: "Zone 5 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone5_program) = 0;
          else if (x == "Program A") id(zone5_program) = 1;
          else if (x == "Program B") id(zone5_program) = 2;
          else if (x == "Program C") id(zone5_program) = 3;

  - platform: template
    id: zone6_program_select
    name: "Zone 6 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone6_program) = 0;
          else if (x == "Program A") id(zone6_program) = 1;
          else if (x == "Program B") id(zone6_program) = 2;
          else if (x == "Program C") id(zone6_program) = 3;

  - platform: template
    id: zone7_program_select
    name: "Zone 7 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone7_program) = 0;
          else if (x == "Program A") id(zone7_program) = 1;
          else if (x == "Program B") id(zone7_program) = 2;
          else if (x == "Program C") id(zone7_program) = 3;

  - platform: template
    id: zone8_program_select
    name: "Zone 8 Program"
    icon: "mdi:alpha-a-circle"
    optimistic: true
    options:
      - "None"
      - "Program A"
      - "Program B"
      - "Program C"
    initial_option: "Program A"
    restore_value: true
    set_action:
      - lambda: |-
          if (x == "None") id(zone8_program) = 0;
          else if (x == "Program A") id(zone8_program) = 1;
          else if (x == "Program B") id(zone8_program) = 2;
          else if (x == "Program C") id(zone8_program) = 3;

###############################################
# Main Sprinkler Controller
###############################################

switch:
   # Restart button
  - platform: restart
    name: "Restart $esphome_comment"
    icon: "mdi:restart"

  # Manual Master Valve Test Button
  - platform: template
    name: "Schedule 1 - Monday"
    id: schedule_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 2 - Tuesday"
    id: schedule_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 3 - Wednesday"
    id: schedule_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 4 - Thursday"
    id: schedule_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 5 - Friday"
    id: schedule_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 6 - Saturday"
    id: schedule_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Schedule 7 - Sunday"
    id: schedule_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Cycle and Soak Enable/Disable
  - platform: template
    name: "Cycle and Soak Mode"
    id: cycle_soak_switch
    icon: "mdi:water-sync"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(cycle_soak_enabled);"
    turn_on_action:
      - lambda: "id(cycle_soak_enabled) = true;"
    turn_off_action:
      - lambda: "id(cycle_soak_enabled) = false;"

  # Master Valve Enable (Optional - Hunter Pro-C Style)
  # Global enable/disable for entire master valve system
  - platform: template
    name: "Time Restriction Override"
    id: manual_time_restriction_override
    icon: "mdi:shield-check"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Time of Day Restriction (10am-3pm block)
  - platform: template
    name: "Time Restriction Enable"
    id: time_restriction_switch
    icon: "mdi:clock-alert"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

  # Weekly schedule enable
  - platform: template
    name: "Enable Weekly Schedule"
    id: weekly_schedule_switch
    icon: "mdi:calendar-clock"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Manual Rain Delay Override
  - platform: template
    name: "Disable Auto Rain Delay"
    id: manual_rain_delay_override_switch
    icon: "mdi:cloud-off-outline"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(manual_rain_delay_override);"
    turn_on_action:
      - lambda: |-
          id(manual_rain_delay_override) = true;
          // Clear any active rain delay immediately so it stops blocking runs
          id(rain_delay_end_time) = 0;
          id(rain_delay_days) = 0;
          id(rain_delay_days_input).publish_state(0);
          ESP_LOGI("irrigation", "Manual rain delay override enabled - active rain delay CLEARED");
    turn_off_action:
      - lambda: |-
          id(manual_rain_delay_override) = false;
          ESP_LOGI("irrigation", "Manual rain delay override disabled - checking weather immediately");
          
          // Immediately check current weather and apply rain delay if needed
          std::string weather = id(weather_forecast_home).state;
          if (weather.empty() || weather == "unknown" || weather == "unavailable") {
            ESP_LOGW("irrigation", "Weather state unavailable - rain delay will be set on next weather update");
            return;
          }
          
          if (weather == "rainy" || weather == "pouring" || weather == "snowy" || weather == "snowy-rainy") {
            id(rain_delay_end_time) = id(homeassistant_time).now().timestamp + (86400 * 2);
            id(rain_delay_days) = 2;
            id(rain_delay_days_input).publish_state(2);
            ESP_LOGI("irrigation", "Auto rain delay IMMEDIATELY activated - weather is %s", weather.c_str());
          } else {
            ESP_LOGI("irrigation", "Weather is %s - no rain delay needed", weather.c_str());
          }

  # Manual Weather Override - Force watering in bad weather
  - platform: template
    name: "Weather Override (Force Watering)"
    id: manual_weather_override_switch
    icon: "mdi:weather-lightning-rainy"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(manual_weather_override);"
    turn_on_action:
      - lambda: |-
          id(manual_weather_override) = true;
      - logger.log:
          format: "âš ï¸ WEATHER OVERRIDE ENABLED - Will water in any weather!"
          level: WARN
    turn_off_action:
      - lambda: |-
          id(manual_weather_override) = false;
      - logger.log:
          format: "âœ“ Weather override disabled - Normal weather checks active"
          level: INFO

# Vacation Mode
  - platform: template
    name: "Vacation Mode"
    id: vacation_mode_switch
    icon: "mdi:airplane"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(vacation_mode_active);"
    turn_on_action:
      - lambda: |-
          id(vacation_mode_active) = true;
          // Save current multiplier
          id(normal_multiplier) = id($devicename1).multiplier();
          // Reduce watering by 50%
          id($devicename1).set_multiplier(id(normal_multiplier) * 0.5);
          // Disable all individual zone schedules
          id(zone1_schedule_enabled) = false;
          id(zone2_schedule_enabled) = false;
          id(zone3_schedule_enabled) = false;
          id(zone4_schedule_enabled) = false;
          id(zone5_schedule_enabled) = false;
          id(zone6_schedule_enabled) = false;
          id(zone7_schedule_enabled) = false;
          id(zone8_schedule_enabled) = false;
          ESP_LOGI("irrigation", "Vacation mode activated - watering reduced to 50%%, individual zone schedules disabled");
    turn_off_action:
      - lambda: |-
          id(vacation_mode_active) = false;
          // Restore normal multiplier
          id($devicename1).set_multiplier(id(normal_multiplier));
          ESP_LOGI("irrigation", "Vacation mode deactivated - normal watering restored");

# System Enable/Disable - Master control
  - platform: template
    name: "Irrigation System Enable"
    id: irrigation_system_enable
    icon: "mdi:water"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON  # Defaults to ON (enabled)
    turn_off_action:
      # Stop everything when disabled
      - sprinkler.shutdown: $devicename1
      - script.stop: run_zone_with_cycles
      - lambda: |-
          id(active_zone_number) = -1;
          id(current_cycle) = 0;
          id(total_cycles) = 0;
          id(cycle_soak_total_duration) = 0;
          id(cycle_soak_elapsed_time) = 0;
          id(is_paused) = false;
          ESP_LOGI("irrigation", "Irrigation system DISABLED");
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "System Disabled"

 # Zone Schedule Enable Switches
  - platform: template
    name: "Zone 1 Schedule Enable"
    id: zone1_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone1_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone1_schedule_enabled) = false;"

  - platform: template
    name: "Zone 2 Schedule Enable"
    id: zone2_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone2_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone2_schedule_enabled) = false;"

  - platform: template
    name: "Zone 3 Schedule Enable"
    id: zone3_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone3_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone3_schedule_enabled) = false;"

  - platform: template
    name: "Zone 4 Schedule Enable"
    id: zone4_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone4_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone4_schedule_enabled) = false;"

  - platform: template
    name: "Zone 5 Schedule Enable"
    id: zone5_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone5_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone5_schedule_enabled) = false;"

  - platform: template
    name: "Zone 6 Schedule Enable"
    id: zone6_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone6_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone6_schedule_enabled) = false;"

  - platform: template
    name: "Zone 7 Schedule Enable"
    id: zone7_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone7_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone7_schedule_enabled) = false;"

  - platform: template
    name: "Zone 8 Schedule Enable"
    id: zone8_schedule_switch
    icon: "mdi:timer"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: "id(zone8_schedule_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone8_schedule_enabled) = false;"

# Master Valve per-zone enable (Hunter Pro-C style)
# Each zone can independently enable/disable master valve usage
  - platform: template
    name: "Zone 1 - Use Master Valve"
    id: zone1_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone1_master_valve_enabled);"
    turn_on_action:
      - lambda: |-
          id(zone1_master_valve_enabled) = true;
          ESP_LOGI("irrigation", "Zone 1: Master Valve ENABLED");
    turn_off_action:
      - lambda: |-
          id(zone1_master_valve_enabled) = false;
          ESP_LOGI("irrigation", "Zone 1: Master Valve DISABLED");
          
  - platform: template
    name: "Zone 2 - Use Master Valve"
    id: zone2_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone2_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone2_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone2_master_valve_enabled) = false;"
      
  - platform: template
    name: "Zone 3 - Use Master Valve"
    id: zone3_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone3_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone3_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone3_master_valve_enabled) = false;"
      
  - platform: template
    name: "Zone 4 - Use Master Valve"
    id: zone4_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone4_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone4_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone4_master_valve_enabled) = false;"
      
  - platform: template
    name: "Zone 5 - Use Master Valve"
    id: zone5_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone5_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone5_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone5_master_valve_enabled) = false;"
      
  - platform: template
    name: "Zone 6 - Use Master Valve"
    id: zone6_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone6_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone6_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone6_master_valve_enabled) = false;"
      
  - platform: template
    name: "Zone 7 - Use Master Valve"
    id: zone7_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone7_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone7_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone7_master_valve_enabled) = false;"
      
  - platform: template
    name: "Zone 8 - Use Master Valve"
    id: zone8_mv_switch
    icon: "mdi:valve"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(zone8_master_valve_enabled);"
    turn_on_action:
      - lambda: "id(zone8_master_valve_enabled) = true;"
    turn_off_action:
      - lambda: "id(zone8_master_valve_enabled) = false;"

# Program enable switches
  - platform: template
    name: "Enable Program A"
    id: program_a_enable_switch
    icon: "mdi:alpha-a-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    lambda: "return id(program_a_enabled);"
    turn_on_action:
      - lambda: "id(program_a_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_a_enabled) = false;"

  - platform: template
    name: "Enable Program B"
    id: program_b_enable_switch
    icon: "mdi:alpha-b-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(program_b_enabled);"
    turn_on_action:
      - lambda: "id(program_b_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_b_enabled) = false;"

  - platform: template
    name: "Enable Program C"
    id: program_c_enable_switch
    icon: "mdi:alpha-c-circle"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: "return id(program_c_enabled);"
    turn_on_action:
      - lambda: "id(program_c_enabled) = true;"
    turn_off_action:
      - lambda: "id(program_c_enabled) = false;"

# Program A day selection (only used when schedule type is "Specific Days")
  - platform: template
    name: "Program A - 1 Monday"
    id: program_a_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 2 Tuesday"
    id: program_a_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 3 Wednesday"
    id: program_a_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 4 Thursday"
    id: program_a_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 5 Friday"
    id: program_a_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 6 Saturday"
    id: program_a_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program A - 7 Sunday"
    id: program_a_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Program B day selection
  - platform: template
    name: "Program B - 1 Monday"
    id: program_b_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 2 Tuesday"
    id: program_b_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 3 Wednesday"
    id: program_b_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 4 Thursday"
    id: program_b_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 5 Friday"
    id: program_b_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 6 Saturday"
    id: program_b_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program B - 7 Sunday"
    id: program_b_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  # Program C day selection
  - platform: template
    name: "Program C - 1 Monday"
    id: program_c_monday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 2 Tuesday"
    id: program_c_tuesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 3 Wednesday"
    id: program_c_wednesday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 4 Thursday"
    id: program_c_thursday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 5 Friday"
    id: program_c_friday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 6 Saturday"
    id: program_c_saturday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

  - platform: template
    name: "Program C - 7 Sunday"
    id: program_c_sunday
    icon: "mdi:calendar"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF  # USER-FACING ZONE SWITCHES (enforce all checks)
  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_1
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 1 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_1).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 1 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_1).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone1_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone1 Active"); 
    on_turn_off:
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone1_start_time);
          if (duration > 120) {
            id(zone1_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 1 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO13
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_2
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 2 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_2).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 2 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_2).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone2_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone2 Active"); 
    on_turn_off:
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone2_start_time);
          if (duration > 120) {
            id(zone2_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 2 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO33
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_3
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 3 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_3).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 3 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_3).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time
          id(zone3_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone3 Active");
    on_turn_off:
      - text_sensor.template.publish:
          id: dev1_valve_status
          state: "Idle"
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone3_start_time);
          if (duration > 120) {
            id(zone3_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 3 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO04
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_4
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 4 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_4).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 4 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_4).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone4_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone4 Active");
          id(dev1_valve_status).publish_state("$dev1_zone4 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone4_start_time);
          if (duration > 120) {
            id(zone4_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 4 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO14
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_5
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 5 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_5).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 5 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_5).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone5_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone5 Active");
          id(dev1_valve_status).publish_state("$dev1_zone5 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone5_start_time);
          if (duration > 120) {
            id(zone5_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 5 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO16
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_6
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 6 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_6).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 6 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_6).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone6_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone6 Active");
          id(dev1_valve_status).publish_state("$dev1_zone6 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone6_start_time);
          if (duration > 120) {
            id(zone6_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 6 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO32
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_7
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 7 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_7).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 7 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_7).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone7_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone7 Active");
          id(dev1_valve_status).publish_state("$dev1_zone7 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone7_start_time);
          if (duration > 120) {
            id(zone7_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 7 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO25
    inverted: true

  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: ${devicename1}_8
    on_turn_on:
      - lambda: |-
          // Check if irrigation system is enabled
          if (!id(irrigation_system_enable).state) {
            ESP_LOGW("irrigation", "ğŸš« Zone 8 BLOCKED - Irrigation system is DISABLED");
            id(${devicename1}_8).turn_off();
            id(dev1_valve_status).publish_state("Idle");
            return;
          }
          
          // Weather check (unless override is active)
          if (!id(manual_weather_override)) {
            std::string w = id(weather_forecast_home).state;
            if (!w.empty() && w != "unknown" && w != "unavailable") {
              if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                ESP_LOGW("irrigation", "â›ˆï¸ Zone 8 BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                id(${devicename1}_8).turn_off();
                id(dev1_valve_status).publish_state("Idle");
                return;
              }
            }
          }
          
          // All checks passed - record start time and show active
          id(zone8_start_time) = id(homeassistant_time).now().timestamp;
          id(dev1_valve_status).publish_state("$dev1_zone8 Active");
          id(dev1_valve_status).publish_state("$dev1_zone8 Active");
 
    on_turn_off:
      - lambda: |-
          // Only record if valve ran for more than 2 minutes (120 seconds)
          long duration = id(homeassistant_time).now().timestamp - id(zone8_start_time);
          if (duration > 120) {
            id(zone8_last_watered) = id(homeassistant_time).now().timestamp;
            ESP_LOGI("irrigation", "Zone 8 watering completed (%ld seconds) - timestamp saved", duration);
          }
    pin: GPIO26
    inverted: true

# Master Valve (Optional - like Hunter Pro-C)
# Can be enabled/disabled via "Enable Master Valve" switch
# Automatically opens when any zone is active (if enabled)
  - platform: gpio
    restore_mode: ALWAYS_OFF
    internal: true
    id: master_valve_relay
    name: "Master Valve Relay"
    pin: $master_valve_pin
    inverted: true
sprinkler:
  - id: $devicename1
    main_switch:
      name: "$dev1_what Start-Stop-Resume"
      id: dev1_main_switch
      internal: true
      on_turn_off:
        - lambda: |-
            // Don't stop run_zone_with_cycles during cycle/soak mode with multiple cycles
            // Only stop if we're in normal mode or if it's a manual stop
            bool in_cycle_soak = (id(total_cycles) > 0 && id(current_cycle) > 0);
            
            if (!in_cycle_soak) {
              ESP_LOGI("irrigation", "Main switch OFF - stopping run_zone_with_cycles (normal mode)");
              id(run_zone_with_cycles).stop();
              
              // Reset soak countdown when stopping
              id(cycle_soak_is_soaking) = false;
              id(cycle_soak_soak_end_time) = 0;
              id(soak_countdown_seconds) = 0;
            } else {
              ESP_LOGI("irrigation", "Main switch OFF - NOT stopping script (in cycle/soak, cycle %d/%d)",
                       id(current_cycle), id(total_cycles));
            }
            
            if (id(is_paused)) return;

            // Only clear state if not in active cycle/soak
            if (!in_cycle_soak) {
              id(active_zone_number) = -1;
              id(current_cycle) = 0;
              id(total_cycles) = 0;
              id(cycle_soak_total_duration) = 0;
              id(cycle_soak_elapsed_time) = 0;
            }

            if (id(irrigation_busy) && !id(in_program_run)) {
              id(irrigation_busy) = false;
              id(drain_queue).execute();
            }

      on_turn_on:
        - lambda: |-
            // CRITICAL: Check if irrigation system is enabled
            if (!id(irrigation_system_enable).state) {
              ESP_LOGW("irrigation", "ğŸš« BLOCKED - Irrigation system is DISABLED");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            // Check rain delay
            if (id(rain_delay_end_time) > id(homeassistant_time).now().timestamp) {
              ESP_LOGW("irrigation", "â›ˆï¸ BLOCKED - Rain delay is active");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            // Weather check (unless override is active)
            if (!id(manual_weather_override)) {
              std::string w = id(weather_forecast_home).state;
              if (!w.empty() && w != "unknown" && w != "unavailable") {
                if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                  ESP_LOGW("irrigation", "â›ˆï¸ BLOCKED - Bad weather: %s (Enable Weather Override to force)", w.c_str());
                  id(dev1_main_switch).turn_off();
                  return;
                }
              }
            }
            
            // Time restriction check
            if (id(is_time_restricted)) {
              ESP_LOGW("irrigation", "â° BLOCKED - Time restriction active");
              id(dev1_main_switch).turn_off();
              return;
            }
            
            ESP_LOGI("irrigation", "âœ… Main switch turned ON - all checks passed");

    auto_advance_switch:
      name: "$dev1_what Auto Advance"
      id: dev1_auto_advance
      restore_mode: ALWAYS_ON

    valve_open_delay: 2s
    valves:
      - valve_switch: $dev1_zone1
        enable_switch:
          name: Enable $dev1_zone1
          id: zone1_enable
        run_duration_number:
          id: "${devicename1}_1_duration"
          name: "${dev1_zone1} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_1
        
      - valve_switch: $dev1_zone2
        enable_switch:
          name: Enable $dev1_zone2
          id: zone2_enable
        run_duration_number:
          id: "${devicename1}_2_duration"
          name: "${dev1_zone2} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_2
        
      - valve_switch: $dev1_zone3
        enable_switch:
          name: Enable $dev1_zone3
          id: zone3_enable
        run_duration_number:
          id: "${devicename1}_3_duration"
          name: "${dev1_zone3} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_3
        
      - valve_switch: $dev1_zone4
        enable_switch:
          name: Enable $dev1_zone4
          id: zone4_enable
        run_duration_number:
          id: "${devicename1}_4_duration"
          name: "${dev1_zone4} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_4
        
      - valve_switch: $dev1_zone5
        enable_switch:
          name: Enable $dev1_zone5
          id: zone5_enable
        run_duration_number:
          id: "${devicename1}_5_duration"
          name: "${dev1_zone5} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_5
        
      - valve_switch: $dev1_zone6
        enable_switch:
          name: Enable $dev1_zone6
          id: zone6_enable
        run_duration_number:
          id: "${devicename1}_6_duration"
          name: "${dev1_zone6} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_6
        
      - valve_switch: $dev1_zone7
        enable_switch:
          name: Enable $dev1_zone7
          id: zone7_enable
        run_duration_number:
          id: "${devicename1}_7_duration"
          name: "${dev1_zone7} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_7
        
      - valve_switch: $dev1_zone8
        enable_switch:
          name: Enable $dev1_zone8
          id: zone8_enable
        run_duration_number:
          id: "${devicename1}_8_duration"
          name: "${dev1_zone8} Run Duration"
          initial_value: 30
          unit_of_measurement: $uom
          mode: slider
          min_value: 1
          max_value: 60
          step: 1
          restore_value: true
        valve_switch_id: ${devicename1}_8


button:
  - platform: template
    id: start_all_zones_normal
    name: "$dev1_what Start All Zones (Normal)"
    icon: "mdi:play-circle-outline"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Start All Zones (NORMAL)");
            
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: |-
                      // Check rain delay (unless manual override is active)
                      if (!id(manual_rain_delay_override)) {
                        return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;
                      }
                      return false;  // Override active, don't block
                  then:
                    - logger.log:
                        format: "â›ˆï¸ BLOCKED: Rain delay is active (Disable Auto Rain Delay to override)"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: |-
                            // Time restriction check
                            return id(is_time_restricted);
                        then:
                          - logger.log:
                              format: "â° BLOCKED: Time restriction active (outside allowed hours)"
                              level: WARN
                        else:
                          - if:
                              condition:
                                lambda: |-
                                  // Weather check (unless override is active)
                                  if (!id(manual_weather_override)) {
                                    std::string w = id(weather_forecast_home).state;
                                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                                        return true;  // Bad weather - block
                                      }
                                    }
                                  }
                                  return false;  // Weather OK or override active
                              then:
                                - logger.log:
                                    format: "â›ˆï¸ BLOCKED: Bad weather (Enable Weather Override to force)"
                                    level: WARN
                              else:
                                - lambda: |-
                                    std::string w = id(weather_forecast_home).state;
                                    if (id(manual_weather_override)) {
                                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                                    } else {
                                      ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                                    }
                                    id(pending_normal_start) = true;
                                    id(normal_start_attempts) = 0;
                                    id(normal_last_attempt_ms) = 0;
                                    ESP_LOGI("irrigation", "âœ… Queued NORMAL start (will begin when system ready)");

# Manual program run buttons
  - platform: template
    name: "Run Program A Now"
    icon: "mdi:alpha-a-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run Program A");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log: "Rain delay active"
                  else:
                    - script.execute:
                        id: request_program_start
                        program: 1
                        allow_queue: true
                        
  - platform: template
    name: "Run Program B Now"
    icon: "mdi:alpha-b-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run Program A");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log: "Rain delay active"
                  else:
                    - script.execute:
                        id: request_program_start
                        program: 2
                        allow_queue: true

  - platform: template
    name: "Run Program C Now"
    icon: "mdi:alpha-c-circle"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Run Program A");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log: "Rain delay active"
                  else:
                    - script.execute:
                        id: request_program_start
                        program: 3
                        allow_queue: true

# Pause button - Actually stops the valve
  - platform: template
    id: dev1_sprinkler_pause
    name: "$dev1_what Pause"
    icon: "mdi:pause"
    on_press:
      then:
        - lambda: |-
            // Save current state if a valve is active
            if (id($devicename1).active_valve().has_value()) {
              id(paused_zone) = id($devicename1).active_valve().value();
              id(paused_cycle) = id(current_cycle);
              id(time_remaining_when_paused) = id($devicename1).time_remaining_active_valve().value_or(0);
              id(is_paused) = true;

              // Snapshot cycle/soak state for resume
              id(paused_total_cycles) = id(total_cycles);
              id(paused_cycle_soak_total_duration) = id(cycle_soak_total_duration);
              id(paused_cycle_soak_elapsed_time) = id(cycle_soak_elapsed_time);
              id(paused_was_soaking) = false;
              id(paused_soak_remaining_seconds) = 0;
              
              ESP_LOGI("irrigation", "Paused: Zone %d, Cycle %d/%d, Time remaining: %d sec, Elapsed: %d/%d sec",
                       id(paused_zone), id(paused_cycle), id(total_cycles),
                       id(time_remaining_when_paused),
                       id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
              
              // ADDED: Confirm progress tracking is paused
              ESP_LOGI("irrigation", "Progress tracking PAUSED - elapsed time frozen at %d seconds",
                       id(cycle_soak_elapsed_time));
              
            } else if (id(cycle_soak_is_soaking) && id(active_zone_number) >= 0 && id(total_cycles) > 0) {
              id(paused_zone) = id(active_zone_number);
              id(paused_cycle) = id(current_cycle);
              long now = id(homeassistant_time).now().timestamp;
              long rem = id(cycle_soak_soak_end_time) - now;
              if (rem < 0) rem = 0;
              id(paused_soak_remaining_seconds) = (int) rem;
              id(time_remaining_when_paused) = 0;
              id(paused_was_soaking) = true;
              id(is_paused) = true;
              id(paused_total_cycles) = id(total_cycles);
              id(paused_cycle_soak_total_duration) = id(cycle_soak_total_duration);
              id(paused_cycle_soak_elapsed_time) = id(cycle_soak_elapsed_time);
              
              ESP_LOGI("irrigation", "Paused during soak: Zone %d, Cycle %d/%d, Soak remaining: %d sec, Elapsed: %d/%d sec",
                       id(paused_zone), id(paused_cycle), id(paused_total_cycles),
                       id(paused_soak_remaining_seconds),
                       id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
              
              // ADDED: Confirm progress tracking is paused
              ESP_LOGI("irrigation", "Progress tracking PAUSED during soak - elapsed time frozen at %d seconds",
                       id(cycle_soak_elapsed_time));
            } else {
              ESP_LOGI("irrigation", "Nothing active to pause");
            }
        - sprinkler.shutdown: $devicename1
        - script.stop: run_zone_with_cycles
        - script.stop: run_all_zones_cycle_soak_script
        - script.stop: run_program
        - text_sensor.template.publish:
            id: dev1_valve_status
            state: "Paused"

# Resume button - Restarts from saved position
  - platform: template
    id: dev1_sprinkler_resume
    name: "$dev1_what Resume"
    icon: "mdi:play"
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(is_paused) && id(paused_zone) >= 0;'
            then:
              - lambda: |-
                  // Restore cycle/soak snapshot BEFORE mode checks
                  id(total_cycles) = id(paused_total_cycles);
                  id(cycle_soak_total_duration) = id(paused_cycle_soak_total_duration);
                  id(cycle_soak_elapsed_time) = id(paused_cycle_soak_elapsed_time);

                  ESP_LOGI("irrigation", "Resuming: Zone %d, Cycle %d/%d, Elapsed restored to: %d/%d sec",
                           id(paused_zone), id(paused_cycle), id(total_cycles),
                           id(cycle_soak_elapsed_time), id(cycle_soak_total_duration));
                  
                  // ADDED: Confirm progress tracking will resume
                  ESP_LOGI("irrigation", "Progress tracking will RESUME from %d seconds",
                           id(cycle_soak_elapsed_time));

                  id(is_paused) = false;
                  id(active_zone_number) = id(paused_zone);
                  id(current_cycle) = id(paused_cycle);

              # If we paused while watering, restart valve for remaining time
              - if:
                  condition:
                    lambda: 'return !id(paused_was_soaking);'
                  then:
                    - sprinkler.start_single_valve:
                        id: $devicename1
                        valve_number: !lambda 'return id(paused_zone);'
                        run_duration: !lambda 'return id(time_remaining_when_paused);'

              # Force Auto Advance state based on mode
              - delay: 100ms
              - if:
                  condition:
                    lambda: 'return id(total_cycles) > 0;'
                  then:
                    - switch.turn_off: dev1_auto_advance
                    - logger.log: "Auto Advance forced OFF (Cycle & Soak mode)"
                    - script.execute:
                        id: continue_cycle_soak_after_resume
                        zone: !lambda 'return id(paused_zone);'
                        start_cycle: !lambda 'return id(current_cycle);'
                        total: !lambda 'return id(total_cycles);'
                        was_soaking: !lambda 'return id(paused_was_soaking);'
                        soak_remaining: !lambda 'return id(paused_soak_remaining_seconds);'
                        water_remaining: !lambda 'return id(time_remaining_when_paused);'
                  else:
                    - switch.turn_on: dev1_auto_advance
                    - logger.log: "Auto Advance ON (Normal mode)"

              - text_sensor.template.publish:
                  id: dev1_valve_status
                  state: "Resumed"

              # Clear pause flags for normal mode; cycle/soak cleanup happens in continuation script
              - if:
                  condition:
                    lambda: 'return id(total_cycles) <= 0;'
                  then:
                    - lambda: |-
                        id(paused_zone) = -1;
                        id(paused_cycle) = 0;
                        id(time_remaining_when_paused) = 0;
                        id(paused_was_soaking) = false;
                        id(paused_soak_remaining_seconds) = 0;
                        id(paused_total_cycles) = 0;
                        id(paused_cycle_soak_total_duration) = 0;
                        id(paused_cycle_soak_elapsed_time) = 0;

            else:
              - logger.log: "Nothing to resume - not paused or no saved state"

  - platform: template
    id: dev1_sprinkler_stop
    name: "$dev1_what Stop"
    icon: "mdi:stop"
    on_press:
      then:
        - logger.log: "â•â•â• STOP BUTTON PRESSED â•â•â•"

        # Cancel pending normal-mode retry worker (but preserve queued programs/zones)
        - lambda: |-
            id(pending_normal_start) = false;
            id(normal_start_attempts) = 0;
            id(normal_last_attempt_ms) = 0;

            // Clear ONLY queued NORMAL start (type 3). Preserve Program (1) and Zone (2).
            if (id(queued_type) == 3) {
              ESP_LOGI("irrigation", "Clearing queued NORMAL request (type 3) on STOP");
              id(queued_type) = 0;
            }

            ESP_LOGI(
              "irrigation",
              "â¹ STOPPING: Zone=%d, Cycle=%d/%d, queued_type=%d",
              id(active_zone_number),
              id(current_cycle),
              id(total_cycles),
              id(queued_type)
            );

            // Keep busy flag SET during shutdown/cleanup
            id(irrigation_busy) = true;

        # Stop sprinkler controller (shutdown respects internal stop delays)
        - sprinkler.shutdown: $devicename1

        # Stop helper scripts
        - script.stop: run_zone_with_cycles
        - script.stop: run_all_zones_cycle_soak_script
        - script.stop: run_program
        - script.stop: run_all_zones_normal_script
        - script.stop: wait_until_idle_then_drain

        # Clear run-state variables (do NOT clear queued_program/queued_zone)
        - lambda: |-
            ESP_LOGI("irrigation", "ğŸ§¹ Clearing run state variables");
            id(active_zone_number) = -1;
            id(current_cycle) = 0;
            id(total_cycles) = 0;
            id(cycle_soak_total_duration) = 0;
            id(cycle_soak_elapsed_time) = 0;
            id(is_paused) = false;
            id(paused_zone) = -1;
            id(paused_cycle) = 0;
            id(time_remaining_when_paused) = 0;
            id(in_program_run) = false;

        - text_sensor.template.publish:
            id: dev1_valve_status
            state: "Stopped"

        # Give the sprinkler component time to finish its internal shutdown window
        - delay: 8s

        # Now mark idle
        - lambda: |-
            ESP_LOGI("irrigation", "âœ“ Stop cleanup complete (idle)");
            id(irrigation_busy) = false;

        # If a Program (type 1) or Zone (type 2) is queued, run it now
        - if:
            condition:
              lambda: |-
                return id(queued_type) != 0;
            then:
              - logger.log: "â–¶ Starting queued request after STOP"
              - script.execute: drain_queue

# Start All Zones - CYCLE & SOAK MODE
  - platform: template
    id: start_all_zones_cycle_soak
    name: "$dev1_what Start All Zones (Cycle & Soak)"
    icon: "mdi:water-sync"
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("irrigation", "");
            ESP_LOGI("irrigation", "ğŸ”µ BUTTON PRESSED: Start All Zones (CYCLE & SOAK)");
        - if:
            condition:
              switch.is_off: irrigation_system_enable
            then:
              - logger.log:
                  format: "âŒ BLOCKED: Irrigation system is DISABLED"
                  level: WARN
            else:
              - if:
                  condition:
                    lambda: 'return id(rain_delay_end_time) > id(homeassistant_time).now().timestamp;'
                  then:
                    - logger.log:
                        format: "â›ˆï¸ BLOCKED: Rain delay is active"
                        level: WARN
                  else:
                    - if:
                        condition:
                          lambda: |-
                            // Time restriction check
                            return id(is_time_restricted);
                        then:
                          - logger.log:
                              format: "â° BLOCKED: Time restriction active (outside allowed hours)"
                              level: WARN
                        else:
                          - if:
                              condition:
                                lambda: |-
                                  // Weather check (unless override is active)
                                  if (!id(manual_weather_override)) {
                                    std::string w = id(weather_forecast_home).state;
                                    if (!w.empty() && w != "unknown" && w != "unavailable") {
                                      if (w == "rainy" || w == "pouring" || w == "snowy" || w == "snowy-rainy") {
                                        return true;  // Bad weather - block
                                      }
                                    }
                                  }
                                  return false;  // Weather OK or override active
                              then:
                                - logger.log:
                                    format: "â›ˆï¸ BLOCKED: Bad weather (Enable Weather Override to force)"
                                    level: WARN
                              else:
                                - lambda: |-
                                    std::string w = id(weather_forecast_home).state;
                                    if (id(manual_weather_override)) {
                                      ESP_LOGW("irrigation", "âš ï¸ Weather override ACTIVE - Starting despite weather: %s", w.c_str());
                                    } else {
                                      ESP_LOGI("irrigation", "âœ… Weather check PASSED: %s", w.c_str());
                                    }
                                # Turn ON cycle and soak mode
                                - switch.turn_on: cycle_soak_switch
                                - logger.log:
                                    format: "âœ… Cycle & Soak Mode ON - Starting all enabled zones"
                                    level: INFO
                                - script.execute: run_all_zones_cycle_soak_script

  - platform: template
    name: "$dev1_zone1 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 0
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true

  - platform: template
    name: "$dev1_zone2 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 1
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone3 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 2
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone4 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 3
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone5 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 4
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone6 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 5
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone7 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 6
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
  - platform: template
    name: "$dev1_zone8 Quick Run"
    icon: "mdi:play-speed"
    on_press:
      then:
        - script.execute:
            id: request_zone_start
            zone: 7
            duration: !lambda "return id(quick_run_duration).state * 60;"
            add_delay: true
            allow_queue: true
